// EDES-U1.3 - CodigoIntermedio
// Banco de preguntas sobre código intermedio y máquinas virtuales
// CE 1.d - Generación de código intermedio

::CE 1.d – Entrega multiplataforma sin sorpresas::
El equipo de release quiere enviar la misma aplicación Java a clientes en Windows, Linux y macOS. ¿Qué estrategia minimiza retrabajos?
{
=Distribuir el mismo bytecode `.class/.jar` y pedir a cada cliente que ejecute con la JVM de su plataforma. #Correcto: El código intermedio es independiente de la arquitectura y cada JVM lo convierte a instrucciones nativas. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Compilar el código fuente a ejecutables nativos distintos para cada sistema operativo en cada entrega. #Incorrecto: Eso eliminaría la ventaja de la portabilidad del bytecode descrita en la unidad. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%Enviar el código fuente y que el cliente lo compile con cualquier editor de texto. #Incorrecto: El cliente necesitaría herramientas de compilación y perderíamos control del proceso. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%Convertir el bytecode a HTML para que se ejecute directamente en el navegador. #Incorrecto: Los navegadores no ejecutan bytecode Java sin una JVM o plugin específico. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
}

::CE 1.d – Colaboración con operaciones::
Operaciones pregunta qué instalar en servidores donde sólo se ejecutarán aplicaciones Java ya compiladas. ¿Qué debes recomendar?
{
=Instalar el JRE/JVM porque sólo necesitan ejecutar bytecode, no compilar. #Correcto: El JDK es necesario para desarrollar/compilar, mientras que el JRE basta para ejecutar. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección 'JDK vs JRE en desarrollo'.
~%-33.3333%Instalar únicamente el compilador `javac` para convertir bytecode a código fuente. #Incorrecto: El compilador transforma código fuente a bytecode; no sirve para ejecutar. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección 'JDK vs JRE en desarrollo'.
~%-33.3333%Eliminar la JVM y ejecutar los `.class` con el sistema operativo directamente. #Incorrecto: Sin JVM no se puede interpretar/compilar el bytecode. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Reemplazar el bytecode por scripts Bash para evitar dependencias. #Incorrecto: No se podrían ejecutar las aplicaciones Java y se perdería funcionalidad. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1'.
}

::CE 1.d – Latencia tras reinicio::
Después de reiniciar un microservicio Java, las métricas muestran más latencia durante los primeros minutos. ¿Cómo lo explicas?
{
=La JVM está en fase de warm-up: comienza interpretando y luego compila JIT los hotspots para optimizar. #Correcto: La unidad describe el proceso JIT y cómo mejora el rendimiento tras recopilar perfiles. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%El bytecode se corrompe y necesita regenerarse manualmente tras cada reinicio. #Incorrecto: No hace falta regenerar bytecode; el warm-up es un comportamiento normal de la JVM. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%El sistema operativo impide ejecutar bytecode hasta que pase una hora. #Incorrecto: La latencia inicial se debe al proceso de optimización JIT, no a una restricción del SO. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%Las clases Java se recompilan a código fuente para verificar errores. #Incorrecto: No se recompilan a código fuente; la JVM optimiza el bytecode en tiempo de ejecución. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
}

::CE 1.d – Auditoría de seguridad::
Seguridad quiere saber cómo evita la JVM que un bytecode malicioso dañe el servidor. ¿Qué argumento ofrece la teoría?
{
=La máquina virtual verifica el bytecode antes de ejecutarlo, comprobando el uso correcto de tipos y accesos. #Correcto: Las JVM realizan verificación para proteger el sistema. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%La JVM convierte todo el bytecode en comentarios para que no se ejecute. #Incorrecto: La JVM ejecuta el bytecode, no lo convierte en comentarios. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%El bytecode se ejecuta directamente sin comprobaciones porque siempre es seguro. #Incorrecto: Sin la verificación se perdería la capa de seguridad mencionada. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%La verificación se realiza una vez en el compilador y nunca en la JVM. #Incorrecto: El compilador genera bytecode, pero la verificación ocurre en la máquina virtual antes de la ejecución. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
}

::CE 1.d – Soporte ARM vs x86::
Un cliente con servidores ARM pregunta si puede ejecutar vuestra aplicación compilada en x86. ¿Qué respondes?
{
=Sí, mientras disponga de una JVM para ARM, porque la JVM traducirá el mismo bytecode a instrucciones de su arquitectura. #Correcto: El bytecode es independiente de la arquitectura; la JVM se encarga de la traducción. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%No, porque el bytecode incluye instrucciones x86 y fallará en ARM. #Incorrecto: El bytecode no está ligado a una arquitectura específica. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%Sí, pero primero debe recompilar el código fuente con `javac` en la máquina ARM. #Incorrecto: No es necesario recompilar; basta con tener la JVM adecuada. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%Sólo funcionará si convierte el bytecode a C y lo recompila de nuevo. #Incorrecto: No hace falta convertir a otro lenguaje; el bytecode ya es portable. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
}

::CE 1.d – Pipeline de desarrollo compartido::
Un nuevo desarrollador cree que puede ejecutar el `.java` directamente porque “es lo mismo que el `.class`”. ¿Cómo aclares el flujo?
{
=El `.java` es código fuente legible; debe compilarse con `javac` para generar el `.class`, que luego ejecuta la JVM. #Correcto: La unidad describe la secuencia fuente → bytecode → ejecución en la JVM. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%El `.java` se abre con un navegador y se ejecuta sin pasos previos. #Incorrecto: El código fuente no se ejecuta en navegadores ni sin compilación. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4'.
~%-33.3333%El `.class` sólo contiene comentarios y no sirve para ejecutar. #Incorrecto: El `.class` es precisamente el bytecode ejecutable por la JVM. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4'.
~%-33.3333%Compilar el `.java` genera directamente un `.exe` que ya no necesita JVM. #Incorrecto: El proceso estándar genera bytecode `.class`, no ejecutables nativos. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4'.
}

::CE 1.d – Debate sobre eliminar la JVM::
Un responsable propone “compilar todo a nativo” para evitar instalar JVM en producción. ¿Qué pierden?
{
=Portabilidad y facilidad de despliegue, ya que habría que compilar y mantener ejecutables distintos por plataforma. #Correcto: Sin código intermedio se perdería la ventaja de “Write Once, Run Anywhere”. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5. ¿Qué Ocurre si No Usamos Código Intermedio?'.
~%-33.3333%La posibilidad de usar estructuras de control en el lenguaje fuente. #Incorrecto: La decisión sobre código intermedio no afecta a la sintaxis del lenguaje. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5'.
~%-33.3333%El acceso al código fuente, que quedaría inaccesible. #Incorrecto: El código fuente seguiría existiendo; lo que cambia es la estrategia de despliegue. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5'.
~%-33.3333%La capacidad de escribir código Java o Kotlin, que dejarían de compilar. #Incorrecto: El problema es la portabilidad, no la posibilidad de escribir en esos lenguajes. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5'.
}

::CE 1.d – Ejecutar bytecode en navegadores::
Una persona propone cargar directamente archivos `.class` en el navegador sin plugins. ¿Cómo respondes?
{
=Explicas que el bytecode necesita una máquina virtual (JVM o similar); los navegadores no ejecutan `.class` sin esa capa. #Correcto: Se enfatiza que el código intermedio requiere una VM para traducirlo a instrucciones reales. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Indicas que basta renombrar el `.class` a `.js` para que el navegador lo interprete. #Incorrecto: Renombrar no cambia el contenido; los navegadores no entienden bytecode Java. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1'.
~%-33.3333%Sugieres incrustar el `.class` en una etiqueta `<iframe>` para ejecutarlo. #Incorrecto: Sin una VM embebida no se ejecutará. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1'.
~%-33.3333%Comentaste que los navegadores modernos incluyen JVM integrada por defecto. #Incorrecto: La mayoría de navegadores no incluyen JVM integrada; requieren plugins o tecnologías alternativas. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1'.
}

::CE 1.d – Formación de equipo sobre ventajas del bytecode::
En una sesión interna preguntas por qué Java es útil en entornos heterogéneos. ¿Qué ejemplo práctico extraerías?
{
=El mismo `.jar` se prueba en Windows del equipo de QA y en Linux del equipo de DevOps sin recompilar, gracias a la JVM. #Correcto: La portabilidad entre plataformas es uno de los beneficios descritos. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Cada equipo necesita recompilar el código fuente con su propio compilador nativo. #Incorrecto: El bytecode evita recompilaciones por plataforma. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%Solo funciona si ambos equipos tienen la misma versión de sistema operativo. #Incorrecto: La JVM se encarga de las diferencias de SO. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
~%-33.3333%Es necesario actualizar el lenguaje fuente cada vez que se cambia de plataforma. #Incorrecto: El lenguaje fuente permanece igual; lo que cambia es la JVM instalada. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3'.
}

::CE 1.d – Conclusión para documentación técnica::
Antes de cerrar la guía de arquitectura, quieres recordar por qué entender el pipeline fuente → bytecode → VM es clave. ¿Qué mensaje recuerdas?
{
=Conocer las fases ayuda a usar correctamente compiladores/JVM, diagnosticar problemas y valorar la portabilidad del enfoque. #Correcto: La conclusión resalta que comprender el proceso completo permite aprovechar sus ventajas. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '7. Conclusión'.
~%-33.3333%Saberlo permite ejecutar bytecode sin ninguna máquina virtual. #Incorrecto: El bytecode siempre requiere una VM. Consulta `EDES-U1.3.-CodigoIntermedio.md`, secciones '1' y '7'.
~%-33.3333%La conclusión anima a reemplazar el bytecode por ejecutables nativos en todos los casos. #Incorrecto: La unidad defiende el código intermedio por sus beneficios. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '7'.
~%-33.3333%Comprenderlo evita la necesidad de documentar los procesos de despliegue. #Incorrecto: Entender las fases no elimina la documentación; la complementa. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '7'.
}
