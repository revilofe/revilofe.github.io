// EDES-U1.5 - Lenguajes
// Banco de preguntas sobre clasificación y características de lenguajes de programación
// CE 1.e - Lenguajes de programación

::CE 1.e – Elección de lenguaje para sistema embebido::
Debes programar el firmware de un microcontrolador para un dispositivo médico con memoria limitada (32KB RAM). ¿Qué tipo de lenguaje es más apropiado y por qué?
{
=Lenguaje de bajo nivel como C o ensamblador, porque permiten control preciso de memoria, acceso directo a hardware y generan código compacto sin overhead de runtime. #Correcto\: Características de lenguajes de bajo nivel para embebidos\: (1) CONTROL DE MEMORIA\: Gestión manual de memoria (malloc/free), sin garbage collector que consuma RAM impredecible. (2) ACCESO HARDWARE\: Manipulación directa de registros (0x40021000 \= valor), puertos, interrupciones. (3) CÓDIGO COMPACTO\: Sin bibliotecas pesadas, sin runtime, ejecutable pequeño. (4) PREDECIBILIDAD\: Timing determinístico (crítico para dispositivos médicos). (5) EFICIENCIA\: Cada byte de RAM y ciclo de CPU cuentan. C domina en embebidos\: 90% del firmware está en C/C++. Ensamblador para partes ultra-críticas. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Python es ideal porque su sintaxis sencilla facilita el desarrollo rápido y reduce errores de programación. #Incorrecto\: Python es INADECUADO para microcontroladores con 32KB RAM\: • Python (CPython) requiere\: Intérprete (\~500KB+), bibliotecas estándar, garbage collector, estructuras dinámicas. NO cabe en 32KB. • MicroPython existe para embebidos, pero necesita \~256KB+ de RAM/Flash. Aún así, 32KB es muy limitado. • Python NO permite control fino de hardware (registros, interrupciones, timing preciso). • Para dispositivos médicos (certificación, timing crítico), Python es arriesgado. C/C++ son estándar en embebidos por buenas razones\: eficiencia, control, tamaño. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Java es perfecto porque el bytecode es portable entre diferentes microcontroladores sin recompilar. #Incorrecto\: Java es COMPLETAMENTE INADECUADO para microcontroladores pequeños\: • JVM requiere\: Varios MB de RAM, procesador potente, SO. Imposible en 32KB. • Existe Java ME (Micro Edition) para embebidos, pero necesita >>32KB. • El bytecode NO es portable a microcontroladores sin JVM (y 32KB no permite JVM). • Garbage collector introduce latencias impredecibles (inaceptable en dispositivos médicos). • Sin acceso directo a hardware. Java es para servidores/móviles con recursos. Para embebidos pequeños\: C/ensamblador. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%JavaScript con Node.js es apropiado porque permite programación asíncrona eficiente para manejar sensores. #Incorrecto\: JavaScript/Node.js es TOTALMENTE INAPROPIADO para microcontroladores\: • Node.js requiere\: Motor V8 (JIT compiler), event loop, libuv, bibliotecas → Varios MB de RAM. Imposible en 32KB. • JavaScript NO tiene acceso directo a hardware de microcontrolador (registros, interrupciones). • Garbage collector, tipado dinámico → overhead inaceptable. • La programación asíncrona NO requiere JavaScript; C puede hacer multitarea, interrupciones, RTOS eficientemente. JavaScript es para web/servidor, NO para embebidos con recursos extremadamente limitados. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
}

::CE 1.e – Paradigma para sistema de gestión de biblioteca::
Desarrollas un sistema de biblioteca que gestiona libros, usuarios, préstamos y reservas. ¿Qué paradigma de programación facilita modelar este dominio y por qué?
{
=Paradigma orientado a objetos (OOP), porque permite modelar entidades del mundo real (Libro, Usuario, Préstamo) como clases con atributos y comportamientos encapsulados. #Correcto\: OOP para dominio de biblioteca\: (1) MODELADO NATURAL\: • class Libro\: atributos (título, autor, ISBN), métodos (prestar(), devolver()). • class Usuario\: atributos (nombre, ID), métodos (solicitarPrestamo()). • class Prestamo\: atributos (libro, usuario, fecha), métodos (calcularMulta()). (2) ENCAPSULACIÓN\: Oculta detalles internos, expone interfaz pública. (3) HERENCIA\: UsuarioEstudiante extends Usuario (especialización). (4) POLIMORFISMO\: Diferentes tipos de préstamos con comportamiento específico. (5) REUTILIZACIÓN\: Clases reutilizables, mantenibles. Lenguajes\: Java, C#, Python, C++ son ideales para este tipo de aplicación. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Paradigma funcional puro como Haskell, porque las bibliotecas son sistemas sin estado que solo consultan datos. #Incorrecto\: FALSO. Las bibliotecas SÍ tienen estado mutable\: • Estado\: Libros disponibles/prestados, fechas de préstamo, multas acumuladas. • Operaciones con efectos\: Prestar libro CAMBIA su disponibilidad, devolver MODIFICA estado. • Funcional puro (Haskell)\: Evita mutación, trabaja con transformaciones inmutables. Aunque Haskell PUEDE modelar estado (mónadas, IO), NO es "natural" para este dominio. • OOP es más DIRECTO para modelar entidades con estado mutable (libro prestado ↔ disponible). Funcional puro es mejor para\: procesamiento de datos, transformaciones, cómputo matemático. OOP es mejor para\: modelado de dominios con entidades y estado. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Paradigma lógico como Prolog, porque permite definir reglas de préstamo y el sistema infiere automáticamente las decisiones. #Incorrecto\: Prolog NO es adecuado como paradigma principal aquí\: • Prolog es excelente para\: Inferencia lógica, sistemas expertos, resolución de restricciones, búsqueda. • Biblioteca necesita\: GESTIÓN de estado (CRUD de libros/usuarios), interfaz de usuario, persistencia (base de datos). • Prolog NO es fuerte en\: Interfaces gráficas, acceso a bases de datos relacionales, arquitectura de aplicaciones típicas. • Podrías usar Prolog para un SUBSISTEMA (ej. motor de reglas de préstamo\: "¿puede usuario X prestar libro Y?"). Pero la aplicación completa en Prolog sería complicada. OOP (Java, C#) es más apropiado para la aplicación completa. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Paradigma imperativo con programación estructurada en C, porque es el más eficiente para manejar bases de datos grandes. #Incorrecto\: Aunque C es eficiente, NO es el más ADECUADO para este dominio\: • C es imperativo/procedural\: Funciones + estructuras de datos (struct). Sin clases, herencia, polimorfismo. • Modelar biblioteca en C\: Posible pero ENGORROSO. Necesitas\: structs para Libro/Usuario, arrays/listas enlazadas manuales, gestión manual de memoria. • Eficiencia NO es crítica aquí\: Una biblioteca escolar/universitaria tiene \~10K-100K libros (manejable en cualquier lenguaje moderno). • OOP (Java, C#) ofrece\: Modelado más natural, menos errores, desarrollo más rápido, mantenimiento más fácil. Para aplicaciones de gestión/CRUD, OOP es superior a C procedural (a menos que tengas restricciones extremas de rendimiento). Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
}

::CE 1.e – Clasificación por modo de ejecución::
Un colega pregunta por qué Python se considera "interpretado" si genera archivos .pyc (bytecode). ¿Cómo explicarías la clasificación correcta?
{
=Python compila a bytecode (.pyc) que luego es interpretado por la PVM. Se clasifica como interpretado porque el bytecode no es código nativo y se ejecuta en una máquina virtual. #Correcto\: Clasificación de Python\: (1) PROCESO\: python script.py → Compila a bytecode (.pyc en __pycache__) → PVM interpreta bytecode. (2) BYTECODE NO ES NATIVO\: Instrucciones stack-based para la Python Virtual Machine, NO instrucciones del procesador. (3) INTERPRETADO\: Aunque hay compilación a bytecode (paso intermedio), el bytecode se INTERPRETA (no se ejecuta nativamente). (4) COMPARACIÓN\: • C++\: Compila a código NATIVO → Ejecuta directamente en CPU. COMPILADO. • Java\: Compila a bytecode → JVM interpreta/compila JIT. MÁQUINA VIRTUAL. • Python\: Compila a bytecode → PVM interpreta (sin JIT agresivo en CPython). INTERPRETADO. La clasificación depende del paso FINAL de ejecución. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python es compilado porque genera archivos .pyc, igual que Java genera .class. Ambos son lenguajes compilados. #Incorrecto\: SIMPLIFICACIÓN EXCESIVA. Aunque ambos generan bytecode, la clasificación difiere por detalles\: • Ambos compilan a bytecode (correcto). • Java (JVM)\: Usa JIT agresivo → Compila bytecode a código nativo en runtime → Rendimiento cercano a compilado. Se clasifica como "máquina virtual" o "híbrido". • Python (CPython)\: Interpreta bytecode SIN JIT agresivo (aunque PyPy sí tiene JIT). Se clasifica como "interpretado". • La distinción es sutil y hay debate. Clasificaciones comunes\: • C++\: Compilado (AOT a nativo). • Java\: Máquina virtual / Compilado JIT. • Python\: Interpretado (bytecode interpretado). Python se considera "interpretado" por convención y rendimiento. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python es interpretado puro que lee el archivo .py línea por línea cada vez; los .pyc son solo caché para acelerar. #Incorrecto\: PARCIALMENTE CORRECTO pero IMPRECISO. Python NO interpreta el .py línea por línea\: • Proceso REAL\: (1) Lee .py → Parsea a AST → Compila a bytecode → Cachea .pyc. (2) Ejecuta\: Interpreta BYTECODE (no archivo .py). • Los .pyc NO son "solo caché opcional"; son el FORMATO EJECUTABLE real. La PVM ejecuta bytecode, no código fuente. • Si ya existe .pyc válido, Python NO toca el .py; carga el .pyc directamente. • La interpretación es de BYTECODE, no de código fuente. Python SÍ tiene paso de compilación (fuente→bytecode), aunque transparente. NO es intérprete puro de código fuente (eso sería shell scripts bash leídos línea por línea). Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python debería clasificarse como lenguaje de máquina virtual igual que Java porque ambos usan bytecode. #Incorrecto\: Hay diferencias que justifican clasificaciones distintas\: • SIMILITUD\: Ambos usan bytecode + VM. • DIFERENCIAS CLAVE\: (1) JVM\: JIT agresivo (HotSpot, C2 compiler) → Compila bytecode a código nativo optimizado. (2) CPython\: Interpretación de bytecode SIN JIT (aunque PyPy sí tiene JIT). (3) Rendimiento\: Java (con JIT) → Cercano a C++. Python (CPython) → 10-100x más lento. • Clasificación tradicional\: Java \= "Máquina Virtual" (por JIT potente). Python \= "Interpretado" (por falta de JIT en implementación estándar). • Técnicamente, AMBOS son "máquina virtual", pero convencionalmente se distinguen por rendimiento/JIT. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
}

::CE 1.e – Lenguaje de alto nivel vs bajo nivel::
Necesitas escribir un driver de dispositivo que manipule registros de hardware. Un compañero sugiere usar Python por su simplicidad. ¿Por qué podría ser problemático?
{
=Python es de alto nivel y abstrae el hardware. No permite acceso directo a direcciones de memoria ni manipulación de registros hardware, necesario para drivers. #Correcto\: Limitaciones de alto nivel para drivers\: (1) ABSTRACCIÓN\: Python esconde detalles de hardware (gestión de memoria automática, sin punteros). (2) SIN ACCESO DIRECTO\: • No puedes hacer "*(volatile uint32_t*)0x40021000 \= 0x01;" (escribir en registro). • No hay punteros, no hay acceso a direcciones de memoria arbitrarias. (3) DRIVERS NECESITAN\: Bajo nivel (C/ensamblador) para\: Mapear memoria (mmap), acceder registros, manejar interrupciones, timing preciso. (4) PYTHON PODRÍA\: Usar ctypes/cffi para llamar código C, pero entonces estás escribiendo el driver en C de todas formas. Drivers del kernel Linux\: 99.9% en C, 0.1% ensamblador. Python NO es para drivers. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
~%-33.3333%Python es perfecto para drivers porque su simplicidad reduce errores y el código es más legible. #Incorrecto\: La simplicidad NO compensa la INCAPACIDAD de acceder hardware\: • Python NO puede\: Acceder directamente a registros hardware, manejar interrupciones de bajo nivel, ejecutar con timing determinístico. • Los drivers del kernel se ejecutan en KERNEL SPACE con privilegios máximos. Python (intérprete) ejecuta en USER SPACE. • Aunque "menos errores" es deseable, un driver QUE NO PUEDE ACCEDER AL HARDWARE es inútil. • Para drivers de espacio de usuario (libusb, libftdi), podrías usar Python con wrappers C, pero el trabajo real lo hace código C/C++. La "simplicidad" no supera las limitaciones técnicas fundamentales. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
~%-33.3333%Python puede acceder a hardware usando bibliotecas como GPIO en Raspberry Pi, por lo que es apropiado para drivers. #Incorrecto\: CONFUSIÓN entre scripts de usuario y drivers reales\: • Raspberry Pi GPIO\: Bibliotecas Python (RPi.GPIO, gpiozero) que LLAMAN a código C/drivers del kernel. El trabajo de bajo nivel lo hace C. • Python es la INTERFAZ de usuario, NO el driver real. • Un driver REAL del kernel\: Se carga en kernel space, maneja interrupciones, accede registros. Escrito en C. • Scripts Python GPIO\: User space, llaman a syscalls/APIs del driver C. Para "drivers de usuario" (comunicación con dispositivos USB/I2C/SPI desde espacio de usuario), Python es CONVENIENTE pero NO esencial. El driver real está en C en el kernel. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
~%-33.3333%Python genera código nativo tan eficiente como C cuando se compila con optimizaciones, así que funciona para drivers. #Incorrecto\: TOTALMENTE FALSO. Python (CPython) NO genera código nativo comparable a C\: • CPython\: Compila a bytecode interpretado (mucho más lento que C). • PyPy\: Usa JIT → Más rápido, pero aún no alcanza C optimizado. • Ni CPython ni PyPy generan "código nativo tan eficiente como C". • Incluso si el rendimiento fuera similar, Python NO tiene capacidades de bajo nivel (punteros, acceso memoria, inline assembly) necesarias para drivers. • Herramientas como Cython/Nuitka pueden compilar Python → C, pero entonces estás usando C como paso intermedio. Python puro NO es para drivers de kernel. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
}

::CE 1.e – Multiparadigma (Python)::
Python permite combinar programación imperativa, orientada a objetos y funcional. ¿Qué ventaja ofrece esa flexibilidad?
{
=Permite elegir el estilo más adecuado para cada tarea: orientación a objetos para modelar entidades, imperativo para flujos de control y funcional para procesar datos. #Correcto: La unidad destaca que lenguajes como Python permiten aplicar varios paradigmas en un mismo proyecto, dando más herramientas según el problema. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Obliga a escribir el programa completo usando un solo paradigma y limita la creatividad. #Incorrecto: Justo al contrario, el multiparadigma abre opciones en vez de restringirlas. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Hace que el código sea automático más rápido porque mezcla los paradigmas en tiempo de ejecución. #Incorrecto: La velocidad depende de la implementación, no de mezclar paradigmas durante la ejecución. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Demuestra que Python es un lenguaje de bajo nivel pensado para manejar hardware directamente. #Incorrecto: Python es de alto nivel; el multiparadigma no lo convierte en lenguaje de bajo nivel. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
}

::CE 1.e – Elección de lenguaje para ciencia de datos::
Necesitas procesar datasets de millones de registros, entrenar modelos de machine learning y visualizar resultados. ¿Qué lenguaje es más popular en este dominio y por qué?
{
=Python, porque tiene ecosistema maduro de bibliotecas científicas (NumPy, pandas, scikit-learn, TensorFlow) y sintaxis accesible para científicos sin formación en programación. #Correcto\: Python para ciencia de datos\: (1) BIBLIOTECAS\: • NumPy\: Arrays multidimensionales, operaciones vectorizadas (implementadas en C → rápido). • pandas\: DataFrames, manipulación de datos tabulares. • scikit-learn\: ML clásico (regresión, clasificación, clustering). • TensorFlow/PyTorch\: Deep learning. • Matplotlib/Seaborn\: Visualización. (2) SINTAXIS SIMPLE\: Científicos (estadísticos, biólogos, físicos) pueden aprender rápidamente. (3) JUPYTER NOTEBOOKS\: Entorno interactivo ideal para exploración. (4) COMUNIDAD\: Enorme cantidad de tutoriales, cursos, Stack Overflow. Python domina ciencia de datos (\~80% del mercado según encuestas). Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%C++ es mejor porque procesa millones de registros mucho más rápido que cualquier otro lenguaje. #Incorrecto\: C++ es MÁS RÁPIDO pero MENOS APROPIADO para ciencia de datos típica\: • VELOCIDAD\: C++ es más rápido en código puro. • PRODUCTIVIDAD\: Python con NumPy/pandas (que internamente usan C/C++) es CASI TAN RÁPIDO para operaciones vectorizadas, pero MUCHO MÁS RÁPIDO de desarrollar. • ECOSISTEMA\: Python tiene bibliotecas maduras (scikit-learn, TensorFlow). C++ tiene menos opciones (dlib, mlpack, menos documentadas). • CASO DE USO\: C++ se usa para\: Producción de modelos entrenados, sistemas de baja latencia. Python se usa para\: Exploración, entrenamiento, experimentación. La mayoría del tiempo en ciencia de datos es EXPLORACIÓN, donde Python brilla. Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%R es el único lenguaje apropiado porque fue diseñado específicamente para estadística y análisis de datos. #Incorrecto\: R es EXCELENTE pero NO el "único" apropiado\: • R\: Diseñado para estadística, excelentes bibliotecas (ggplot2, dplyr, caret), comunidad académica fuerte. • Python\: Más versátil (web, automatización, scripting, ciencia de datos), bibliotecas potentes (pandas, scikit-learn). • TENDENCIA\: Python ha superado a R en popularidad en ciencia de datos (según Stack Overflow, Kaggle surveys). • ELECCIÓN PRÁCTICA\: (1) R\: Si trabajas principalmente en estadística académica, investigación. (2) Python\: Si quieres combinar ciencia de datos con ingeniería de software, producción. Ambos son válidos; Python es más popular actualmente por versatilidad. Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Java es ideal porque empresas grandes lo usan y tiene mejor rendimiento que Python para procesamiento de datos. #Incorrecto\: Java NO es popular en ciencia de datos aunque tiene ventajas\: • VENTAJAS DE JAVA\: Rendimiento, escalabilidad, integración empresarial (Hadoop, Spark). • DESVENTAJAS PARA CIENCIA DE DATOS\: (1) Verbosidad\: Código más largo que Python/R. (2) Ecosistema limitado\: Pocas bibliotecas de ML comparado con Python (Weka, Deeplearning4j existen pero menos populares). (3) Curva de aprendizaje\: Más difícil para científicos sin background en programación. • USO REAL\: Java se usa en PRODUCCIÓN de sistemas de ML a escala (Spark MLlib), pero EXPLORACIÓN y ENTRENAMIENTO se hace típicamente en Python. Python domina exploración; Java es opción para producción. Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
}


::CE 1.e – Lenguajes compilados vs interpretados (características)::
Un desarrollador junior pregunta\: "¿Por qué C++ se compila a ejecutables pero Python se distribuye como archivos .py?". ¿Cómo explicarías la diferencia?
{
=C++ es compilado AOT a código nativo específico de plataforma (distribuyes ejecutables). Python es interpretado (compila a bytecode en runtime), distribuyes código fuente que el intérprete ejecuta. #Correcto\: Comparación de distribución\: • C++ COMPILADO AOT\: (1) Desarrollo\: Escribes .cpp. (2) Compilación\: g++ → ejecutable (.exe, .out). (3) Distribución\: Envías ejecutable binario (código máquina). (4) Usuario\: Ejecuta binario directamente (NO necesita compilador). (5) Plataforma-específico\: Windows .exe NO funciona en Linux. • PYTHON INTERPRETADO\: (1) Desarrollo\: Escribes .py. (2) Distribución\: Envías archivos .py (código fuente). (3) Usuario\: Necesita intérprete Python instalado (python script.py). (4) Plataforma-independiente\: Mismo .py funciona en Windows/Linux/macOS (si tienen Python). Trade-off\: C++ \= Rendimiento, sin dependencias | Python \= Portabilidad, requiere intérprete. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%C++ y Python funcionan igual; ambos generan bytecode que luego se ejecuta en una máquina virtual. #Incorrecto\: FALSO. C++ NO genera bytecode ni usa máquina virtual\: • C++\: Compila a código MÁQUINA NATIVO (instrucciones x86/ARM). Se ejecuta DIRECTAMENTE en el procesador, sin VM. • Python\: Compila a bytecode (instrucciones PVM). Se ejecuta EN la Python Virtual Machine (PVM). • Resultado\: (1) C++\: Rendimiento máximo, específico de plataforma. (2) Python\: Rendimiento menor, portable. La afirmación confunde completamente los modelos de ejecución de ambos lenguajes. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python es más seguro distribuir como .py porque el código fuente puede ser auditado; C++ oculta el código en ejecutables. #Incorrecto\: Aunque es cierto que .py es auditable y .exe no, NO es la RAZÓN de la distribución\: • RAZÓN REAL\: Python es INTERPRETADO (necesita código fuente o bytecode para ejecutar). C++ es COMPILADO (genera ejecutables autónomos). • SEGURIDAD/AUDITABILIDAD\: Es un EFECTO SECUNDARIO, no la razón principal. • Para Python, PUEDES distribuir bytecode (.pyc, .pyo) o empaquetado (PyInstaller, .pyz), ocultando código fuente. • Para C++, PUEDES distribuir código fuente (open source). • La diferencia NO es filosófica (auditoría); es TÉCNICA (interpretado vs compilado). El modelo de ejecución determina qué distribuyes. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%C++ genera ejecutables porque es más antiguo. Lenguajes modernos como Python usan código fuente porque es mejor. #Incorrecto\: La edad NO determina el modelo de ejecución\: • Lenguajes ANTIGUOS compilados\: Fortran (1957), C (1972), C++ (1985). • Lenguajes ANTIGUOS interpretados\: Lisp (1958), BASIC (1964). • Lenguajes MODERNOS compilados\: Rust (2010), Go (2009). • Lenguajes MODERNOS interpretados\: JavaScript (1995), Python (1991). • La elección es DISEÑO, no edad\: (1) Compilado\: Rendimiento, distribución de binarios. (2) Interpretado\: Portabilidad, desarrollo rápido. Ambos coexisten porque tienen DIFERENTES TRADE-OFFS para diferentes casos de uso, no porque uno sea "mejor" o "más moderno". Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
}

::CE 1.e – Paradigma funcional (ventajas)::
Necesitas procesar un stream de datos donde cada elemento se transforma, filtra y agrega. Un colega sugiere usar programación funcional. ¿Qué ventaja ofrece?
{
=Permite encadenar transformaciones inmutables (map, filter, reduce) de forma declarativa, facilitando razonamiento sobre el código y paralelización sin efectos secundarios. #Correcto\: Programación funcional para procesamiento de datos\: (1) COMPOSICIÓN\: data.map(x \=> x*2).filter(x \=> x>10).reduce((a,b) \=> a+b, 0) (declarativo, legible). (2) INMUTABILIDAD\: Cada operación retorna NUEVA colección sin modificar original → Sin efectos secundarios. (3) RAZONAMIENTO\: Más fácil entender qué hace el código (cada función es pura\: misma entrada → misma salida). (4) PARALELIZACIÓN\: Sin estado compartido → Puede ejecutarse en paralelo (map/reduce distribuido\: Hadoop, Spark). (5) TESTABILIDAD\: Funciones puras son fáciles de testear (sin setup complejo). Para procesamiento de datos, streams, transformaciones\: funcional es excelente. Python, JavaScript, Scala, Kotlin soportan estilo funcional. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%La programación funcional es más rápida porque evita usar memoria para variables mutables. #Incorrecto\: FALSO. Funcional NO es necesariamente más rápido\: • INMUTABILIDAD\: Cada transformación crea NUEVA colección → PUEDE usar MÁS memoria que mutación in-place. • Ejemplo\: (1) Imperativo\: for(i\=0;i<n;i++) arr[i] *\= 2; (modifica array existente). (2) Funcional\: newArr \= arr.map(x \=> x*2); (crea nuevo array). Funcional usa MÁS memoria (2 arrays temporalmente). • OPTIMIZACIÓN\: Compiladores modernos pueden optimizar código funcional (fusion, eliminación de estructuras intermedias), pero NO es automáticamente más rápido. • Ventaja NO es velocidad; es CLARIDAD, PARALELIZACIÓN, MENOS BUGS. Para rendimiento puro, código imperativo optimizado puede ser más rápido. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Solo Haskell soporta programación funcional. Lenguajes como JavaScript y Python no pueden hacer transformaciones funcionales. #Incorrecto\: TOTALMENTE FALSO. Muchos lenguajes multiparadigma soportan funcional\: • JavaScript\: array.map(), filter(), reduce(), arrow functions, first-class functions. • Python\: lambda, map(), filter(), reduce(), list comprehensions, functools. • Kotlin\: map, filter, fold, lambdas, immutable collections. • Scala\: Fuertemente funcional, híbrido con OOP. • Java (moderno)\: Streams API (stream().map().filter().reduce()). • Haskell\: Funcional PURO (obliga inmutabilidad). Otros permiten estilo funcional pero no lo obligan. La programación funcional es un ESTILO que muchos lenguajes soportan, NO exclusivo de Haskell. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Programación funcional significa usar funciones en lugar de clases, por lo que es lo opuesto a orientación a objetos. #Incorrecto\: SIMPLIFICACIÓN INCORRECTA. Funcional NO es solo "usar funciones"\: • CARACTERÍSTICAS FUNCIONAL\: (1) Funciones como ciudadanos de primera clase (pasar funciones como argumentos). (2) Inmutabilidad (no modificar estado). (3) Funciones puras (sin efectos secundarios). (4) Composición de funciones. • NO es "opuesto" a OOP\: (1) PUEDES combinar ambos (Scala, Kotlin\: OOP + Funcional). (2) Ejemplo\: class Collection \{ map(fn) \{...\} filter(fn) \{...\} \} → Métodos funcionales en clase OOP. • JavaScript, Python, Kotlin\: Multiparadigma (OOP + Funcional). No son opuestos; son complementarios. Funcional es sobre INMUTABILIDAD y FUNCIONES PURAS, no solo "usar funciones". Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
}

::CE 1.e – Tendencias TIOBE (interpretación)::
Según el índice TIOBE de 2024, Python, C, Java y C++ están en el top 5. ¿Qué indica esto sobre las preferencias de la industria?
{
=Coexisten lenguajes compilados (C, C++, Java con JIT) e interpretados (Python), mostrando que la elección depende del dominio\: sistemas (C/C++), empresas (Java), ciencia de datos (Python). #Correcto\: Interpretación de TIOBE top 5\: (1) DIVERSIDAD\: NO hay "un lenguaje ganador"; diferentes dominios usan diferentes lenguajes. (2) DOMINIOS\: • Python\: Ciencia de datos, ML, automatización, scripting, educación. • C\: Sistemas embebidos, kernels, drivers, programación de bajo nivel. • Java\: Desarrollo empresarial, Android, backend a gran escala. • C++\: Videojuegos, motores gráficos, sistemas de alto rendimiento. (3) TENDENCIA\: Python ha crecido enormemente (boom de ML/Data Science). C/C++ se mantienen (sistemas críticos). Java estable (empresas grandes). (4) CONCLUSIÓN\: El "mejor lenguaje" depende del contexto. La industria usa MÚLTIPLES lenguajes especializados. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Python está desplazando a todos los demás lenguajes y pronto será el único usado en la industria. #Incorrecto\: EXAGERADO. Python crece pero NO desplazará a todos\: • Python es EXCELENTE para\: Scripting, ciencia de datos, ML, automatización, web (Django/Flask). • Python es INADECUADO para\: (1) Sistemas embebidos (demasiado pesado). (2) Kernels de SO (necesita bajo nivel). (3) Videojuegos AAA (rendimiento crítico). (4) Drivers de dispositivos (acceso hardware). • C/C++ SEGUIRÁN siendo esenciales para\: Sistemas operativos, firmware, motores de juegos, compiladores. • REALIDAD\: Especialización. Python domina ciencia de datos; C domina sistemas; Java domina empresas. NO habrá "un lenguaje único"; cada dominio tiene necesidades diferentes. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%TIOBE muestra que lenguajes compilados (C, C++, Java) son más populares porque son más rápidos. #Incorrecto\: INTERPRETACIÓN INCORRECTA. El top 5 incluye INTERPRETADO (Python)\: • Top 5 (2024)\: Python (#1), C (#2), C++ (#3), Java (#4), C# (#5) (orden aproximado varía). • Python (INTERPRETADO) está #1, superando a C/C++ compilados. • RAZÓN de popularidad NO es solo velocidad\: (1) Python\: Popular por FACILIDAD, ECOSISTEMA (bibliotecas ML), COMUNIDAD. (2) C/C++\: Populares por RENDIMIENTO, CONTROL, LEGACY (código existente). (3) Java\: Popular por ECOSISTEMA EMPRESARIAL, PORTABILIDAD (JVM). La popularidad depende de\: Ecosistema, comunidad, casos de uso, facilidad de aprendizaje, NO solo velocidad. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%TIOBE solo mide búsquedas en Google, no uso real, por lo que no refleja la industria real. #Incorrecto\: PARCIALMENTE CIERTO pero sigue siendo INDICADOR útil\: • METODOLOGÍA TIOBE\: Cuenta búsquedas en \~25 motores (Google, Bing, Yahoo, Wikipedia, YouTube, etc.) con queries específicas ("+ programming"). • LIMITACIÓN\: Mide INTERÉS/BÚSQUEDAS, no LÍNEAS DE CÓDIGO escritas en producción. • SESGO\: Lenguajes problemáticos o difíciles pueden tener más búsquedas (no necesariamente más uso). • ALTERNATIVAS\: Stack Overflow Survey, GitHub Octoverse, RedMonk (miden código real, preguntas, repos). • UTILIDAD\: TIOBE es UN INDICADOR entre varios. Correlaciona razonablemente con uso real (Python alto en TIOBE Y en Stack Overflow Y en GitHub). Aunque imperfecto, sigue siendo útil para ver TENDENCIAS (Python subiendo, Perl bajando). Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
}

::CE 1.e – Evolución de lenguajes (Kotlin vs Java)::
Kotlin es un lenguaje moderno que compila a bytecode JVM, compatible con Java. ¿Por qué crear un nuevo lenguaje en lugar de evolucionar Java?
{
=Kotlin introduce features modernos (null-safety, coroutines, sintaxis concisa) sin romper compatibilidad con código Java existente, permitiendo adopción gradual en proyectos legacy. #Correcto\: Razones para Kotlin\: (1) LIMITACIONES JAVA\: Verbosidad, sin null-safety nativo, checked exceptions problemáticas, sintaxis antigua. (2) FEATURES KOTLIN\: • Null-safety\: val x\: String \= null → Error compilación. En Java\: NullPointerException en runtime. • Concisión\: data class User(val name\: String) vs Java\: 20+ líneas (getters, setters, equals, hashCode). • Coroutines\: Concurrencia simplificada vs Java threads/callbacks. • Funciones de extensión, lambdas mejoradas, smart casts. (3) COMPATIBILIDAD\: Kotlin y Java coexisten en el MISMO proyecto (ambos → bytecode JVM). Puedes migrar gradualmente. (4) ANDROID\: Google adoptó Kotlin como lenguaje preferido (2019). Kotlin es "Java mejorado" sin romper el ecosistema. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Kotlin es más rápido en ejecución que Java porque es un lenguaje moderno con mejor compilador. #Incorrecto\: FALSO. Kotlin y Java tienen rendimiento SIMILAR\: • Ambos compilan a bytecode JVM. • Ambos se ejecutan en la MISMA JVM (HotSpot, OpenJ9, etc.). • El bytecode generado es muy similar (a veces idéntico para código equivalente). • Algunas features de Kotlin (inline functions, reified generics) PUEDEN ser más eficientes. • Algunas features (lambdas, DSLs) PUEDEN tener overhead mínimo. • EN GENERAL\: Rendimiento es \~99% similar. Diferencia es PRODUCTIVIDAD y SEGURIDAD (null-safety, less boilerplate), NO velocidad. Benchmarks muestran diferencias <5% entre Kotlin y Java equivalente. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Kotlin reemplazará completamente a Java en pocos años porque Java es obsoleto y en desuso. #Incorrecto\: EXAGERADO. Java NO desaparecerá pronto\: • BASE DE CÓDIGO\: Billones de líneas de código Java existente en empresas (legacy). • EVOLUCIÓN JAVA\: Java sigue evolucionando (Java 17 LTS, Java 21 LTS\: records, pattern matching, virtual threads). • ADOPCIÓN KOTLIN\: Crece (especialmente Android), pero Java sigue dominando\: (1) Empresas grandes (bancos, seguros) con código Java legacy. (2) Frameworks (Spring, Hibernate) siguen siendo Java-first (aunque soportan Kotlin). • COEXISTENCIA\: Kotlin y Java coexisten bien (puedes mezclar en el mismo proyecto). Kotlin es una ALTERNATIVA, no un REEMPLAZO completo. Java seguirá siendo relevante durante décadas por código legacy y adopción empresarial. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Kotlin usa un runtime diferente a Java, por lo que no son realmente compatibles en la práctica. #Incorrecto\: FALSO. Kotlin usa el MISMO runtime que Java (JVM)\: • Kotlin compila a bytecode JVM (mismo que Java). • Ejecuta en la MISMA JVM (OpenJDK, Oracle JDK, etc.). • Kotlin stdlib (biblioteca estándar) es una JAR adicional (pequeña, \~1.5MB). • INTEROPERABILIDAD\: (1) Código Java puede llamar código Kotlin sin modificaciones. (2) Código Kotlin puede usar bibliotecas Java directamente. (3) Puedes mezclar .java y .kt en el mismo proyecto/módulo. • La compatibilidad es EXCELENTE (es uno de los diseños clave de Kotlin). NO hay "runtime diferente"; comparten la JVM. Kotlin añade su stdlib, pero NO reemplaza la JVM. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
}
