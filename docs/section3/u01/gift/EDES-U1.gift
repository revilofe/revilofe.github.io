// EDES-U1.1 - Software-PC
// Banco de preguntas sobre la relación entre software y hardware
// CE 1.a - Relación Hardware-Software


::CE 1.a – Camino de datos (teclado -> pantalla)::
En un mini-juego tipo Tetris, al pulsar una flecha del teclado la pieza se mueve en pantalla. ¿Qué secuencia simplificada describe mejor la interacción?
{
=Teclado (entrada) -> CPU/SO procesan el evento -> estado en memoria se actualiza -> salida a pantalla. #Correcto\: Esta es la secuencia correcta del flujo de datos\: (1) El TECLADO captura la pulsación y envía la señal al sistema; (2) La CPU/SO procesan qué tecla se pulsó; (3) Se actualiza el estado del juego en MEMORIA RAM (nueva posición de la pieza); (4) Se envía la imagen actualizada a la PANTALLA. Es el ciclo básico de entrada-proceso-almacenamiento-salida. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%Pantalla -> GPU envía una señal al teclado -> CPU guarda en disco. #Incorrecto\: Esta secuencia no tiene sentido\: la pantalla es un dispositivo de SALIDA, no puede iniciar el proceso. Además, el teclado recibe señales del usuario, no de la GPU. Y guardar cada movimiento en disco sería extremadamente lento e innecesario. La secuencia correcta comienza con el teclado como entrada. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%CPU escribe en el teclado y el monitor ejecuta el juego. #Incorrecto\: La CPU no "escribe" en el teclado, el teclado es un dispositivo de ENTRADA (el usuario escribe en él). Además, el monitor no ejecuta nada, solo MUESTRA lo que la GPU le envía. La ejecución del juego ocurre en la CPU/GPU, no en la pantalla. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%RAM ordena al teclado y el disco duro dibuja el frame. #Incorrecto\: La RAM es memoria de almacenamiento temporal, no "ordena" nada. El disco duro tampoco "dibuja", es un dispositivo de almacenamiento permanente. El dibujo en pantalla lo hace la GPU tomando datos de la RAM. La RAM no tiene control sobre los periféricos. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
}

::CE 1.a – Volatilidad de memoria (apagón sin guardar)::
Estás editando un documento en Word y se va la luz antes de pulsar "Guardar". Al volver a encender, el archivo no tiene los cambios. ¿Dónde estaban los datos no persistidos?
{
=En la memoria RAM, que es volátil y pierde su contenido al apagarse. #Correcto\: La RAM (Random Access Memory) es VOLÁTIL\: necesita energía eléctrica constante para mantener los datos. Cuando trabajas en Word, los cambios se almacenan temporalmente en RAM para acceso rápido. Al irse la luz, la RAM pierde toda la información que no se guardó en el disco. Por eso es importante guardar frecuentemente. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%En el disco SSD, porque siempre refleja el último estado del programa. #Incorrecto\: El disco SSD es PERSISTENTE (no pierde datos sin electricidad), pero solo contiene lo que GUARDASTE explícitamente. Los cambios sin guardar están en RAM, no en disco. El disco solo se actualiza cuando presionas "Guardar" o cuando Word hace autoguardado. Si no guardaste, el disco tiene la versión antigua. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%En la CPU, que almacena los documentos mientras se editan. #Incorrecto\: La CPU PROCESA instrucciones, pero no ALMACENA documentos. La CPU tiene cachés pequeñas (L1, L2, L3) para datos temporales de cálculos, pero no guarda documentos completos. Los datos del documento editado están en RAM. La CPU solo lee/escribe en RAM mientras ejecuta instrucciones. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%En la caché del monitor, que conserva la última imagen. #Incorrecto\: La pantalla/monitor no tiene "caché" de datos de aplicaciones. La pantalla solo MUESTRA píxeles que recibe de la GPU en tiempo real. No almacena el contenido del documento. Si apagas la pantalla, los datos siguen en RAM; si apagas el ordenador, los datos se pierden de la RAM. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
}

::CE 1.a – Periféricos de E/S (clasificación práctica)::
Copias una carpeta de 2GB desde tu ordenador a una memoria USB. ¿Cómo se clasifica la memoria USB dentro del sistema?
{
=Como periférico de entrada/salida (E/S), porque permite tanto lectura como escritura de datos. #Correcto\: Una memoria USB es un dispositivo de E/S (Entrada/Salida) porque realiza AMBAS operaciones\: puedes LEER datos de ella (entrada al sistema) y ESCRIBIR datos en ella (salida desde el sistema). Otros ejemplos de E/S\: discos duros, tarjetas de red, pantallas táctiles. El teclado sería solo entrada; la impresora solo salida. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%Como unidad central de proceso (CPU), porque procesa la transferencia de archivos. #Incorrecto\: La CPU es el procesador del ordenador, no un periférico. La CPU COORDINA la transferencia, pero la memoria USB es un PERIFÉRICO externo. La CPU ejecuta las instrucciones para copiar, pero el dispositivo físico que almacena los datos es la USB, que es un periférico de almacenamiento E/S. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%Como memoria principal (RAM), porque almacena temporalmente los datos. #Incorrecto\: La RAM es memoria interna VOLÁTIL del ordenador, no un periférico externo. La memoria USB es almacenamiento PERSISTENTE (no pierde datos sin electricidad) y es un periférico EXTERNO conectado por USB. Durante la copia, los datos pueden pasar temporalmente por RAM, pero la USB no ES RAM. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%Como software de sistema, porque gestiona el almacenamiento de archivos. #Incorrecto\: La memoria USB es HARDWARE (componente físico), no software. El SOFTWARE de sistema (como el Sistema Operativo) gestiona cómo se accede a la USB, pero la USB en sí es un dispositivo físico de almacenamiento. No confundir el dispositivo físico con el software que lo controla. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
}

::CE 1.a – Persistencia al guardar (flujo HW/SW)::
Estás escribiendo en LibreOffice Writer y pulsas "Guardar". ¿Qué describe mejor la secuencia de persistencia de los datos?
{
=El SO toma los datos en RAM y los escribe en almacenamiento persistente (SSD/HDD), asegurando que no se pierdan al apagar. #Correcto\: Cuando guardas\: (1) El SO toma el contenido del documento que está en RAM; (2) Lo escribe en el disco duro/SSD (almacenamiento PERSISTENTE); (3) El disco confirma que se escribió correctamente. Ahora los datos sobrevivirán a un apagón, porque el disco no es volátil. Esta es la función clave del guardado\: pasar de RAM (volátil) a disco (persistente). Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%La CPU guarda el documento en su caché L1 de forma permanente para acceso rápido. #Incorrecto\: Las cachés de la CPU (L1, L2, L3) son memorias VOLÁTILES extremadamente rápidas pero TEMPORALES, usadas para acelerar el acceso a datos frecuentes. Son aún más volátiles que la RAM. No sirven para guardar documentos permanentemente. Al apagar el PC, las cachés se vacían. El guardado permanente requiere disco SSD/HDD. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%La GPU renderiza el texto y lo almacena en su memoria VRAM para no perderlo. #Incorrecto\: La GPU se encarga de MOSTRAR el texto en pantalla, pero su memoria VRAM es VOLÁTIL (como la RAM) y solo contiene datos temporales para renderizado gráfico. La GPU no almacena documentos permanentemente. El guardado lo hace el SO escribiendo en el disco duro/SSD, no en la GPU. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%El teclado envía los bytes directamente al disco duro, que los conserva automáticamente. #Incorrecto\: El teclado envía las pulsaciones a la CPU/SO, que las procesa y las guarda TEMPORALMENTE en RAM. El disco duro NO recibe datos directamente del teclado. Solo cuando presionas "Guardar" el SO toma los datos de RAM y los escribe al disco. Sin "Guardar", los datos solo están en RAM y se pierden al apagar. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
}

::CE 1.a – Ejecución de instrucciones en un juego::
Estás jugando a un videojuego y presionas la tecla de salto. ¿Qué componente del sistema es el responsable de calcular la altura del salto y ejecutar las instrucciones del juego?
{
=El Procesador (CPU), porque ejecuta las instrucciones del programa paso a paso. #Correcto\: La CPU es el "cerebro" del ordenador que EJECUTA cada instrucción del código del juego secuencialmente. Cuando presionas salto, la CPU\: (1) lee el evento del teclado; (2) ejecuta el código de física del juego (calcula altura, velocidad, gravedad); (3) actualiza la posición del personaje en RAM. Todo el procesamiento lógico lo hace la CPU. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%La Memoria RAM, porque almacena las teclas presionadas y las ejecuta. #Incorrecto\: La RAM es memoria de ALMACENAMIENTO temporal, no EJECUTA instrucciones. La RAM almacena\: el código del juego, la posición del personaje, las texturas, etc. Pero quien LEE estos datos y EJECUTA las instrucciones es la CPU. La RAM es pasiva (solo guarda), la CPU es activa (ejecuta y calcula). Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%El Disco duro, porque guarda la partida y controla la lógica del juego. #Incorrecto\: El disco duro es almacenamiento PERMANENTE y LENTO, usado para guardar/cargar partidas, pero no ejecuta nada. Cuando juegas, el juego está cargado en RAM y ejecutándose en la CPU, no en el disco. El disco solo interviene cuando guardas o cargas, no durante el juego en tiempo real. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%La Tarjeta gráfica (GPU), porque muestra los gráficos del salto y ejecuta toda la lógica. #Incorrecto\: La GPU RENDERIZA los gráficos (dibuja al personaje saltando en pantalla), pero NO ejecuta la lógica del juego. Es la CPU quien ejecuta el código que calcula la física del salto. La GPU solo recibe órdenes de "dibuja esto aquí" de la CPU. División de trabajo\: CPU=lógica, GPU=gráficos. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
}

::CE 1.a – Almacenamiento temporal en programa Python::
Ejecutas un programa en Python que pide tu nombre y lo muestra en pantalla. Mientras el programa está corriendo, ¿dónde se almacena temporalmente tu nombre?
{
=En la memoria RAM, porque es donde se almacenan los datos en uso durante la ejecución del programa. #Correcto\: Cuando un programa se ejecuta, todas sus variables y datos en uso se almacenan en la RAM. La RAM es memoria VOLÁTIL pero MUY RÁPIDA, perfecta para datos temporales que la CPU necesita acceder constantemente. Tu nombre se guarda en una variable en RAM. Al cerrar el programa, esa zona de RAM se libera y puede ser reutilizada. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%En el disco duro, porque todos los datos de los programas van al disco. #Incorrecto\: El disco duro es almacenamiento PERMANENTE pero LENTO. Los programas y datos en ejecución están en RAM, no en disco. El disco solo se usa para\: (1) cargar el programa al iniciar; (2) guardar datos permanentemente si lo solicitas. Durante la ejecución, acceder al disco constantemente sería demasiado lento. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%En el procesador (CPU), porque el procesador guarda todas las variables del programa. #Incorrecto\: La CPU tiene pequeñas memorias caché (L1, L2, L3) para datos MUY frecuentes, pero son muy pequeñas (KB o pocos MB). No almacena variables completas de programas. La CPU LEE/ESCRIBE variables que están en RAM. Las variables se almacenan en RAM; la CPU solo las procesa temporalmente. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%En la máquina virtual de Python, que crea un espacio aislado del sistema. #Incorrecto\: Aunque Python usa un intérprete (máquina virtual), este también se ejecuta en la CPU y usa RAM para almacenar datos. La "máquina virtual" no es un lugar físico de almacenamiento, es un programa que gestiona la ejecución. Los datos de tu programa Python están en RAM, igual que cualquier otro programa. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
}

::CE 1.a – Sistema Operativo como intermediario::
Instalas una nueva impresora en tu ordenador Windows. ¿Qué componente de software actúa como intermediario entre la aplicación que quieres imprimir y el hardware de la impresora?
{
=El Sistema Operativo, porque gestiona la comunicación entre software y hardware mediante drivers. #Correcto\: El Sistema Operativo (Windows, Linux, macOS) es el intermediario fundamental entre aplicaciones y hardware. Cuando imprimes\: (1) La aplicación pide al SO "imprime esto"; (2) El SO usa el DRIVER (controlador) de la impresora; (3) El SO envía los datos formateados a la impresora. El SO abstrae el hardware, permitiendo que las aplicaciones no necesiten conocer detalles técnicos de cada dispositivo. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%El procesador (CPU), porque envía directamente los datos a imprimir al hardware. #Incorrecto\: La CPU EJECUTA instrucciones, pero no gestiona directamente la comunicación con periféricos. Es el SISTEMA OPERATIVO (ejecutándose en la CPU) quien coordina la comunicación. La CPU es hardware que ejecuta el SO; el SO es el software intermediario que gestiona dispositivos mediante drivers. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%La aplicación de edición de texto, porque ella controla directamente todos los periféricos. #Incorrecto\: Las aplicaciones NO controlan directamente el hardware (sería caótico y peligroso). Las aplicaciones usan APIS del Sistema Operativo para solicitar servicios. La aplicación le pide al SO "imprime esto" y el SO se encarga de todo. Esta abstracción simplifica enormemente el desarrollo de software. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%La memoria RAM, porque almacena los drivers de todos los dispositivos conectados. #Incorrecto\: La RAM SÍ almacena los drivers cargados en memoria, pero es el SISTEMA OPERATIVO quien EJECUTA y GESTIONA estos drivers. La RAM es solo almacenamiento temporal. El intermediario activo es el SO, que lee los drivers de RAM y los usa para comunicarse con el hardware. La RAM es pasiva, el SO es activo. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
}

::CE 1.a – Tipos de software en el sistema::
Tu profesor de programación te pide que instales Visual Studio Code en tu ordenador. ¿A qué categoría de software pertenece Visual Studio Code?
{
=Software de desarrollo, porque es una herramienta para crear y editar programas. #Correcto\: Visual Studio Code es un EDITOR DE CÓDIGO, que pertenece a la categoría de Software de Desarrollo (también llamado herramientas de programación). Esta categoría incluye\: editores, compiladores, depuradores, IDEs. Son herramientas que los programadores usan para CREAR otro software. Otros ejemplos\: IntelliJ IDEA, Eclipse, GCC. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%Software de sistema, porque controla el funcionamiento básico del ordenador. #Incorrecto\: El Software de Sistema incluye el Sistema Operativo, drivers, y utilidades del sistema que GESTIONAN el hardware y recursos básicos. VS Code no gestiona hardware ni es parte del sistema operativo, es una APLICACIÓN que usas para programar. El Software de Sistema sería Windows/Linux, no un editor de código. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%Software de aplicación, porque es un programa que el usuario final utiliza. #Incorrecto\: El Software de Aplicación son programas para usuarios finales\: procesadores de texto, navegadores, videojuegos, reproductores de música. Aunque VS Code es técnicamente una "aplicación", se clasifica más específicamente como Software de DESARROLLO porque su propósito es crear otros programas, no usarlos directamente. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%Sistema operativo, porque permite ejecutar otros programas de desarrollo. #Incorrecto\: Un Sistema Operativo (Windows, Linux, macOS) es el software fundamental que gestiona hardware y permite ejecutar aplicaciones. VS Code NO es un SO, es una APLICACIÓN que se ejecuta SOBRE un SO. VS Code depende del SO para funcionar; el SO no depende de VS Code. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
}

::CE 1.a – Diferencia RAM vs almacenamiento permanente::
Tienes un ordenador con 8GB de RAM y 512GB de SSD. Apagas el ordenador. ¿Qué ocurre con los datos almacenados en cada uno?
{
=La RAM pierde todos los datos (volátil), mientras que el SSD mantiene los datos intactos (persistente). #Correcto\: Esta es la diferencia clave entre ambas memorias\: • RAM es VOLÁTIL\: necesita electricidad constante. Al apagar, se vacía completamente. Es rápida pero temporal. • SSD/HDD es PERSISTENTE\: almacena datos magnética/electrónicamente incluso sin electricidad. Al apagar, los archivos permanecen. Es más lento que RAM pero permanente. Por eso guardamos documentos en disco, no en RAM. Consulta `EDES-U1.1.-Software-PC.md`, secciones '1. ¿Qué es el Hardware?' y '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%Tanto la RAM como el SSD pierden todos los datos, porque ambos necesitan electricidad. #Incorrecto\: FALSO. Solo la RAM es volátil. El SSD/HDD es PERSISTENTE\: utiliza tecnologías (memoria flash en SSD, magnetismo en HDD) que mantienen los datos sin electricidad. Si ambos fueran volátiles, perderíamos todos nuestros archivos cada vez que apagáramos el ordenador. El disco guarda permanentemente. Consulta `EDES-U1.1.-Software-PC.md`, secciones '1. ¿Qué es el Hardware?' y '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%La RAM mantiene los datos indefinidamente, mientras que el SSD necesita borrado manual. #Incorrecto\: Es JUSTO AL REVÉS. La RAM es VOLÁTIL (pierde datos al apagar). El SSD es PERSISTENTE (mantiene datos indefinidamente hasta que los borras manualmente). La RAM está diseñada para datos temporales de alta velocidad; el SSD para almacenamiento permanente. Esta confusión es grave, son memorias completamente opuestas. Consulta `EDES-U1.1.-Software-PC.md`, secciones '1. ¿Qué es el Hardware?' y '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%Ambos mantienen los datos, porque la batería de la BIOS los alimenta constantemente. #Incorrecto\: La batería de la BIOS solo alimenta un chip CMOS muy pequeño con configuración del sistema (fecha/hora, configuración de arranque), NO la RAM ni el SSD. La RAM pierde datos al apagar. El SSD mantiene datos SIN necesitar alimentación, no porque tenga batería, sino por su tecnología de memoria flash. Consulta `EDES-U1.1.-Software-PC.md`, secciones '1. ¿Qué es el Hardware?' y '3. ¿Cómo se Comunican el Software y el Hardware?'.
}

::CE 1.a – Rol del procesador durante ejecución::
Estás ejecutando un navegador web con varias pestañas abiertas. ¿Cuál es el papel principal del procesador (CPU) mientras navegas?
{
=Ejecutar las instrucciones del navegador y gestionar los recursos para cada pestaña abierta. #Correcto\: La CPU es el coordinador central\: (1) Ejecuta el código del navegador; (2) Procesa eventos (clics, teclas); (3) Gestiona memoria para cada pestaña; (4) Ejecuta JavaScript de las páginas web; (5) Coordina con GPU para renderizar. Todo el procesamiento lógico pasa por la CPU. Los navegadores modernos son multi-proceso, y la CPU gestiona todos estos procesos simultáneamente. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%Almacenar permanentemente las páginas web visitadas en su memoria interna. #Incorrecto\: La CPU NO almacena datos permanentemente. Tiene cachés pequeñas (L1/L2/L3) para datos temporales frecuentes, pero son VOLÁTILES y pequeñas. Las páginas web visitadas pueden guardarse en\: (1) RAM (temporal); (2) Disco (caché del navegador, permanente). La CPU PROCESA, no almacena permanentemente. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%Mostrar directamente las imágenes y textos de las páginas en la pantalla. #Incorrecto\: Mostrar contenido en pantalla es trabajo de la GPU (tarjeta gráfica). La CPU EJECUTA el código que determina QUÉ mostrar, pero delega a la GPU el renderizado de píxeles. División de trabajo\: CPU=lógica y coordinación, GPU=renderizado gráfico. Los navegadores modernos usan aceleración por hardware (GPU) para suavidad. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
~%-33.3333%Conectar el ordenador a Internet mediante el protocolo TCP/IP. #Incorrecto\: Conectar a Internet es trabajo de la TARJETA DE RED (hardware de red) y el SOFTWARE de red del Sistema Operativo. La CPU sí EJECUTA el software de red, pero el hardware que envía/recibe paquetes físicamente es la tarjeta de red. La CPU coordina, pero no es el dispositivo que conecta físicamente. Consulta `EDES-U1.1.-Software-PC.md`, sección '1. ¿Qué es el Hardware?'.
}

::CE 1.a – Periféricos\: tipos entrada/salida::
Clasifica los siguientes dispositivos como entrada, salida o entrada/salida\: micrófono, altavoces, webcam, impresora, disco duro externo.
{
=Entrada\: micrófono, webcam. Salida\: altavoces, impresora. E/S\: disco duro externo. #Correcto\: Clasificación correcta\: • ENTRADA (datos AL sistema)\: micrófono (captura sonido), webcam (captura vídeo/imagen). • SALIDA (datos DESDE sistema)\: altavoces (emiten sonido), impresora (imprime documentos). • ENTRADA/SALIDA (ambos)\: disco duro externo (lees y escribes archivos). Esta clasificación depende de la dirección del flujo de datos respecto al ordenador.
~%-33.3333%Todos son de entrada, porque envían información al ordenador desde el exterior. #Incorrecto\: NO. Los dispositivos de SALIDA (altavoces, impresora) RECIBEN datos DEL ordenador, no envían al ordenador. El micrófono/webcam sí son entrada (capturan del exterior). Los altavoces/impresora son salida (emiten hacia el exterior). El disco externo es E/S (ambas direcciones). La dirección del flujo de datos determina la clasificación.
~%-33.3333%Todos son de salida, porque muestran o emiten información procesada por el ordenador. #Incorrecto\: NO. El micrófono y la webcam son de ENTRADA\: capturan datos del mundo real y los envían AL ordenador. No emiten nada hacia el exterior, capturan del exterior hacia dentro. Solo altavoces/impresora son salida. No confundir captura (entrada) con emisión (salida).
~%-33.3333%Entrada\: disco duro. Salida\: webcam, micrófono. E/S\: altavoces, impresora. #Incorrecto\: Clasificación totalmente invertida. Webcam y micrófono CAPTURAN (entrada), no emiten. Altavoces/impresora EMITEN (salida), no capturan. Disco duro es E/S porque permite LEER (entrada) y ESCRIBIR (salida). Esta respuesta confunde la dirección del flujo de datos.
}

::CE 1.a – Arquitectura Von Neumann (flujo de datos)::
En un programa que calcula el factorial de un número, se carga el código desde el disco, se ejecuta en el procesador usando datos en RAM, y se muestra el resultado en pantalla. ¿Qué principio arquitectónico describe este flujo?
{
=Arquitectura Von Neumann\: programa y datos se almacenan en la misma memoria y se procesan secuencialmente por la CPU. #Correcto\: La arquitectura Von Neumann (base de ordenadores modernos) establece\: (1) Programa y datos en la MISMA memoria (RAM); (2) La CPU BUSCA instrucciones secuencialmente de memoria; (3) EJECUTA cada instrucción; (4) ALMACENA resultados en memoria; (5) Usa buses para comunicar CPU-Memoria-E/S. Este es el modelo fundamental de cómo funcionan los ordenadores desde los años 1940. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%Arquitectura Cliente-Servidor\: el disco es el servidor y la CPU es el cliente que solicita datos. #Incorrecto\: Cliente-Servidor es un modelo de ARQUITECTURA DE SOFTWARE para sistemas distribuidos (web, bases de datos), NO de hardware de ordenadores. Describe cómo programas se comunican en red, no cómo funciona internamente un ordenador. La relación disco-CPU no es cliente-servidor, es un flujo de datos según arquitectura Von Neumann. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%Arquitectura en Capas\: cada componente (disco, RAM, CPU) es una capa independiente. #Incorrecto\: Arquitectura en Capas es un patrón de DISEÑO DE SOFTWARE (interfaz, lógica, datos), NO arquitectura de hardware. Aunque el hardware tiene jerarquías (CPU->Caché->RAM->Disco por velocidad), el modelo fundamental es VON NEUMANN\: programa y datos en memoria unificada, procesamiento secuencial. No confundir capas de software con arquitectura de hardware. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
~%-33.3333%Arquitectura Distribuida\: cada componente trabaja independientemente en paralelo. #Incorrecto\: Arquitectura Distribuida describe SISTEMAS con múltiples ordenadores trabajando juntos (cloud, clusters), NO el funcionamiento interno de un ordenador. Dentro de un PC, CPU, RAM y disco SÍ interactúan coordinadamente (no independientemente) siguiendo la arquitectura Von Neumann. La CPU coordina todo secuencialmente, no distribuido. Consulta `EDES-U1.1.-Software-PC.md`, sección '3. ¿Cómo se Comunican el Software y el Hardware?'.
}

::CE 1.a – Software de sistema vs aplicación (ejemplo práctico)::
Tu ordenador ejecuta simultáneamente\: Windows 10, Chrome, Spotify y un antivirus. ¿Cómo se clasifican estos programas?
{
=Sistema\: Windows 10, antivirus. Aplicación\: Chrome, Spotify. #Correcto\: Clasificación correcta\: • SOFTWARE DE SISTEMA\: Windows 10 (Sistema Operativo base), Antivirus (seguridad del sistema). Gestionan recursos y protegen el sistema. • SOFTWARE DE APLICACIÓN\: Chrome (navegador), Spotify (reproductor música). Son aplicaciones para tareas específicas del usuario. Los programas de sistema permiten que las aplicaciones funcionen; las aplicaciones aportan funcionalidad al usuario. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%Sistema\: Windows 10. Aplicación\: Chrome, Spotify, antivirus. #Incorrecto\: Casi correcto, pero el ANTIVIRUS se clasifica como SOFTWARE DE SISTEMA, no aplicación. Aunque los usuarios lo instalan como una app, cumple funciones de SISTEMA\: protege recursos, previene malware, opera a bajo nivel. Es una utilidad del sistema más cercana al SO que a aplicaciones de usuario final como Chrome/Spotify. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%Todos son software de sistema porque se ejecutan sobre Windows. #Incorrecto\: NO. Que algo se ejecute SOBRE Windows no lo convierte en software de sistema. Chrome y Spotify son SOFTWARE DE APLICACIÓN\: programas que aportan funcionalidad específica al usuario final. Software de sistema son programas que GESTIONAN el ordenador a bajo nivel (SO, drivers, utilidades). La clasificación depende del propósito, no dónde se ejecuta. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
~%-33.3333%Todos son software de aplicación porque el usuario los usa directamente. #Incorrecto\: FALSO. Windows 10 es un SISTEMA OPERATIVO (software de sistema), no una aplicación. Es la base fundamental que permite ejecutar aplicaciones. El antivirus también es software de sistema (utilidad de seguridad). Que el usuario interactúe con algo no lo convierte en aplicación; la clasificación depende de su función\: gestión del sistema vs funcionalidad de usuario. Consulta `EDES-U1.1.-Software-PC.md`, sección '2. ¿Qué es el Software?'.
}

::CE 1.a – Relación hardware-software en videojuego (ejemplo integrado)::
En Fortnite, presionas las teclas WASD para moverte, la CPU calcula la nueva posición, la RAM guarda el estado del juego, la GPU dibuja los gráficos, y la pantalla muestra el resultado. ¿Qué describe mejor esta interacción?
{
=Es un ejemplo de cómo el software (Fortnite) coordina múltiples componentes de hardware (teclado, CPU, RAM, GPU, pantalla) para realizar una tarea compleja. #Correcto\: Este ejemplo muestra perfectamente la RELACIÓN HARDWARE-SOFTWARE\: El SOFTWARE (juego Fortnite) es un conjunto de instrucciones que COORDINA el HARDWARE\: (1) Teclado captura entrada; (2) CPU ejecuta lógica; (3) RAM almacena estado; (4) GPU renderiza; (5) Pantalla muestra. Software y hardware se necesitan mutuamente\: sin software, el hardware no sabe qué hacer; sin hardware, el software no puede ejecutarse. Consulta `EDES-U1.1.-Software-PC.md`, sección '4. Ejemplo: El Juego del Tetris'.
~%-33.3333%La CPU es el único componente importante; los demás solo asisten sin contribuir realmente. #Incorrecto\: FALSO. Todos los componentes son ESENCIALES\: • Sin teclado, no hay entrada. • Sin CPU, no hay cálculos. • Sin RAM, no hay memoria temporal. • Sin GPU, no hay gráficos fluidos. • Sin pantalla, no hay salida visible. Los ordenadores modernos funcionan mediante COLABORACIÓN de componentes especializados. La CPU coordina, pero no lo hace todo sola. Consulta `EDES-U1.1.-Software-PC.md`, sección '4. Ejemplo: El Juego del Tetris'.
~%-33.3333%Es un proceso completamente automático del hardware; el software solo observa sin intervenir. #Incorrecto\: AL REVÉS. El SOFTWARE (Fortnite) CONTROLA todo el proceso\: define QUÉ hace cada hardware y CUÁNDO. El hardware es pasivo\: ejecuta instrucciones del software. Sin software, el hardware no haría nada útil (sería solo metal y silicio). El software es el "director de orquesta" que coordina a los músicos (hardware). Software dice qué hacer; hardware lo ejecuta. Consulta `EDES-U1.1.-Software-PC.md`, sección '4. Ejemplo: El Juego del Tetris'.
~%-33.3333%La GPU es responsable de toda la lógica del juego, incluyendo cálculos de física y entrada. #Incorrecto\: NO. La GPU está especializada en RENDERIZADO GRÁFICO (dibujar píxeles), NO en lógica del juego. La LÓGICA (física, colisiones, IA, entrada) la ejecuta la CPU. División de trabajo\: CPU=lógica/cálculos generales; GPU=gráficos/cálculos paralelos gráficos. Aunque GPUs modernas hacen computación general (GPGPU), la lógica principal del juego sigue en CPU. Consulta `EDES-U1.1.-Software-PC.md`, sección '4. Ejemplo: El Juego del Tetris'.
}

// EDES-U1.2 - CodigoFuenteObjetoEjecutable
// Banco de preguntas sobre código fuente, objeto y ejecutable
// CE 1.c - Diferencia entre código fuente, objeto y ejecutable

::CE 1.c – Definición de código fuente::
Escribes un programa en C con instrucciones legibles por personas. ¿Cómo describe la unidad el código fuente?
{
=Como el conjunto de instrucciones en un lenguaje de programación legible que actúa como plano inicial del programa. #Correcto: El código fuente es el primer paso que escribe la persona desarrolladora utilizando lenguajes como C o Python. Es legible para humanos y sirve como plano del software. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
~%-33.3333%Como el binario final que la CPU ejecuta directamente sin más pasos. #Incorrecto: El binario final corresponde al código ejecutable, no al código fuente. El código fuente todavía debe traducirse para que la máquina lo entienda. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
~%-33.3333%Como la documentación que acompaña a un programa para explicar su uso. #Incorrecto: La documentación puede acompañar al software, pero no es código fuente. El código fuente son instrucciones ejecutables escritas en un lenguaje de programación. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
~%-33.3333%Como el conjunto de ficheros de configuración del sistema operativo. #Incorrecto: Los ficheros de configuración son datos para el sistema, no el código fuente del programa que estamos desarrollando. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
}

::CE 1.c – Herramienta que genera código objeto::
Tras escribir un archivo `hola.c`, ejecutas `gcc -c hola.c`. ¿Qué herramienta se describe en la unidad y qué obtiene?
{
=El compilador, que traduce el código fuente a código objeto listo para ser enlazado. #Correcto: El compilador analiza el código fuente y genera código objeto, una versión más cercana al lenguaje máquina pero aún sin enlazar. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
~%-33.3333%El enlazador, que fusiona directamente el código fuente con bibliotecas externas. #Incorrecto: El enlazador actúa después del compilador. Primero se necesita generar el código objeto con el compilador. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
~%-33.3333%El intérprete, que ejecuta línea a línea el código fuente sin generar ficheros intermedios. #Incorrecto: En esta unidad se describe un proceso compilado. Un intérprete no produce código objeto como paso intermedio. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
~%-33.3333%El depurador, que transforma el código para poder analizarlo. #Incorrecto: El depurador ayuda a revisar la ejecución, pero no traduce código fuente a código objeto. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
}

::CE 1.c – Finalidad del código objeto::
Después de compilar varios módulos obtienes varios ficheros objeto. ¿Qué papel se les asigna en la unidad?
{
=Ser piezas intermedias que contienen instrucciones casi en lenguaje máquina listas para enlazarse con otros módulos y bibliotecas. #Correcto: El código objeto aproxima el programa al lenguaje de la máquina, pero aún necesita unirse con el resto de módulos y bibliotecas mediante el enlazador. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
~%-33.3333%Ser el ejecutable definitivo que puede ejecutarse sin más pasos. #Incorrecto: El ejecutable se obtiene tras enlazar todos los objetos y bibliotecas necesarias. Los objetos por sí mismos no son ejecutables completos. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
~%-33.3333%Ser ficheros de configuración que indican cómo compilar el programa. #Incorrecto: Los objetos contienen instrucciones traducidas, no configuraciones de compilación. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
~%-33.3333%Ser copias exactas del código fuente guardadas en otro formato de texto. #Incorrecto: El código objeto no es texto legible ni copia del código fuente; ya contiene instrucciones cercanas al lenguaje máquina. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '2. ¿Qué es el Código Objeto?'.
}

::CE 1.c – Rol del enlazador::
Tras compilar todos tus módulos, ejecutas el enlazador. ¿Qué función cumple esta fase durante el proceso?
{
=Une todos los ficheros objeto y las bibliotecas necesarias para generar un único código ejecutable. #Correcto: El enlazador resuelve referencias entre módulos y bibliotecas para producir un ejecutable completo que el sistema operativo puede cargar. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Traduce el código fuente de alto nivel a código objeto. #Incorrecto: Esa es tarea del compilador. El enlazador actúa después, tomando los objetos ya generados. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Optimiza el código ejecutable para que sea más legible por las personas. #Incorrecto: El enlazador no mejora la legibilidad humana, su objetivo es generar un binario ejecutable para la máquina. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Convierte automáticamente el ejecutable en código fuente para su documentación. #Incorrecto: El enlazador no revierte el proceso; trabaja en sentido hacia el ejecutable final. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
}

::CE 1.c – Características del código ejecutable::
Generas el archivo final de tu programa. ¿Qué propiedad destaca la unidad sobre el código ejecutable?
{
=Contiene instrucciones en lenguaje máquina que el sistema operativo puede cargar y la CPU ejecutar directamente. #Correcto: El código ejecutable es el resultado final del proceso y está en el formato que entiende el procesador. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '3. ¿Qué es el Código Ejecutable?'.
~%-33.3333%Es un archivo de texto legible que sirve como documentación del programa. #Incorrecto: El ejecutable no es legible por personas; está en lenguaje máquina binario. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '3. ¿Qué es el Código Ejecutable?'.
~%-33.3333%Solo puede ejecutarse si se recompila cada vez que se usa. #Incorrecto: Una vez generado, el ejecutable se puede ejecutar tantas veces como se quiera sin recompilar. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '3. ¿Qué es el Código Ejecutable?'.
~%-33.3333%Es independiente del sistema operativo y se ejecuta igual en cualquier plataforma sin cambios. #Incorrecto: El ejecutable está adaptado al sistema operativo y a la arquitectura para la que se compiló. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '3. ¿Qué es el Código Ejecutable?'.
}

::CE 1.c – Orden de las etapas::
Selecciona el orden correcto de las etapas descritas en la unidad para crear un programa en C listo para ejecutarse.
{
=Escribir código fuente -> Compilar a código objeto -> Enlazar objetos y bibliotecas -> Ejecutar el binario. #Correcto: La unidad detalla que primero se redacta el código fuente, luego se compila a objeto, después se enlaza y finalmente se ejecuta el programa resultante. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Escribir código fuente -> Ejecutar directamente -> Compilar -> Enlazar. #Incorrecto: No se puede ejecutar directamente el código fuente; primero debe compilarse y enlazarse. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Ejecutar el binario -> Enlazar -> Compilar -> Escribir código fuente. #Incorrecto: El proceso no puede comenzar ejecutando un binario que aún no existe; el orden debe respetar las fases de desarrollo. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Compilar -> Escribir código fuente -> Enlazar -> Ejecutar. #Incorrecto: Primero se escribe el código, después se compila. No se puede compilar algo que todavía no existe. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
}

::CE 1.c – Ejemplo visual de la receta::
En el ejemplo visual de la unidad se compara el proceso con traducir una receta para un robot. ¿Qué representa el código ejecutable en esa analogía?
{
=La versión totalmente detallada en el lenguaje que entiende el robot, lista para ejecutarse. #Correcto: El código ejecutable equivale a las instrucciones definitivas que el robot puede seguir sin más traducciones. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '4. Ejemplo Visual: El Proceso de Traducción de Código'.
~%-33.3333%La receta original escrita en tu idioma antes de traducirla. #Incorrecto: Esa receta inicial representa el código fuente, no el ejecutable final. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '4. Ejemplo Visual: El Proceso de Traducción de Código'.
~%-33.3333%El listado de ingredientes sin pasos de preparación. #Incorrecto: Un listado de ingredientes sería información incompleta, similar a datos de entrada, no al código ejecutable completo. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '4. Ejemplo Visual: El Proceso de Traducción de Código'.
~%-33.3333%Las notas personales del chef sobre cómo mejorar la receta. #Incorrecto: Las notas personales no forman parte del flujo código fuente -> objeto -> ejecutable descrito en la unidad. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '4. Ejemplo Visual: El Proceso de Traducción de Código'.
}

::CE 1.c – Necesidad de compilar el código fuente::
¿Por qué insiste la unidad en que el código fuente debe transformarse antes de ejecutarse?
{
=Porque los ordenadores solo entienden lenguaje máquina y el código fuente está pensado para ser legible por personas. #Correcto: La unidad recuerda que el código fuente es legible para humanos y debe traducirse a código que la CPU pueda interpretar. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
~%-33.3333%Porque compilar permite que el programa funcione sin usar memoria RAM. #Incorrecto: La compilación no elimina la necesidad de memoria RAM durante la ejecución. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
~%-33.3333%Porque el código fuente se pierde automáticamente si no se compila cada minuto. #Incorrecto: El código fuente no desaparece; la compilación se hace para generar ejecutables, no para conservarlo. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
~%-33.3333%Porque al compilar el código se convierte en documentación para el equipo. #Incorrecto: La documentación no es el objetivo de la compilación; se compila para obtener código ejecutable. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '1. ¿Qué es el Código Fuente?'.
}

::CE 1.c – Importancia del enlazado::
Si omites la etapa de enlazado después de tener los objetos, ¿qué ocurre según la unidad?
{
=No obtienes un ejecutable completo porque las referencias entre módulos y bibliotecas quedan sin resolver. #Correcto: El enlazado es imprescindible para combinar los objetos y producir el ejecutable final. Sin esa fase, el programa no se puede ejecutar. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%El programa se ejecuta igualmente porque el código objeto es suficiente. #Incorrecto: El código objeto necesita enlazarse para resolver dependencias y formar el ejecutable final. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Solo se pierden los comentarios del código fuente, pero el binario se genera. #Incorrecto: El enlazado no tiene que ver con comentarios; sin enlazar no hay binario ejecutable. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
~%-33.3333%Obtienes un archivo ejecutable, pero sin icono ni nombre descriptivo. #Incorrecto: La ausencia de enlazado impide obtener el ejecutable; no se trata de detalles estéticos del archivo. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección '5. Proceso de Conversión: Compilación y Ejecución'.
}

::CE 1.c – Utilidad de conocer las fases::
¿Qué ventaja señala la conclusión de la unidad sobre entender las etapas de código fuente, objeto y ejecutable?
{
=Permite trabajar mejor con compiladores y enlazadores para crear aplicaciones funcionales de forma consciente. #Correcto: La conclusión destaca que comprender las etapas ayuda a usar adecuadamente las herramientas y a saber qué ocurre en cada paso. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección 'Conclusión'.
~%-33.3333%Evita tener que utilizar cualquier herramienta de desarrollo. #Incorrecto: Conocer las fases no elimina la necesidad de usar herramientas; precisamente ayuda a utilizarlas mejor. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección 'Conclusión'.
~%-33.3333%Garantiza que el programa nunca tendrá errores. #Incorrecto: Comprender las fases no garantiza la ausencia de errores, aunque facilita su análisis. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección 'Conclusión'.
~%-33.3333%Permite saltarse la fase de pruebas porque el código ya está traducido. #Incorrecto: Las pruebas siguen siendo necesarias; entender las fases no elimina el proceso de verificación y pruebas. Consulta `EDES-U1.2.-CodigoFuenteObjetoEjecutable.md`, sección 'Conclusión'.
}

// EDES-U1.3 - CodigoIntermedio
// Banco de preguntas sobre código intermedio y máquinas virtuales
// CE 1.d - Generación de código intermedio

::CE 1.d – Definición de código intermedio::
Compilas un programa en Java y obtienes archivos `.class`. ¿Cómo define la unidad ese código intermedio?
{
=Como un conjunto de instrucciones independientes de la plataforma que necesita una máquina virtual para ejecutarse. #Correcto: El código intermedio no está ligado a una arquitectura física; es interpretado o compilado por la JVM o la CLR según la plataforma. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Como el ejecutable final que el sistema operativo carga directamente. #Incorrecto: El ejecutable final se obtiene tras la interpretación o compilación JIT del código intermedio; no es el mismo archivo. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Como el código fuente tal y como lo escribió la persona desarrolladora. #Incorrecto: El código fuente es el paso anterior; el código intermedio es generado a partir de él. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Como un documento de diseño que orienta la implementación final. #Incorrecto: El código intermedio no es documentación, son instrucciones reales listas para ejecutarse en una VM. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
}

::CE 1.d – Papel de la máquina virtual::
¿Qué papel asigna la unidad a la máquina virtual (JVM o CLR) dentro del proceso?
{
=Traducir o compilar el código intermedio a instrucciones específicas de la arquitectura donde se ejecuta. #Correcto: La máquina virtual actúa como intérprete/compilador que convierte el bytecode en código máquina para cada plataforma. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Guardar el código fuente original para permitir volver atrás en el proyecto. #Incorrecto: La máquina virtual no gestiona versiones del código fuente; se centra en ejecutar el bytecode. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Elegir automáticamente el lenguaje de programación más eficiente para el proyecto. #Incorrecto: La VM no cambia de lenguaje; ejecuta el código intermedio generado por el compilador del lenguaje elegido. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
~%-33.3333%Convertir el código intermedio en documentación para el equipo funcional. #Incorrecto: La VM no genera documentación, transforma bytecode en instrucciones ejecutables. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '1. ¿Qué es el Código Intermedio?'.
}

::CE 1.d – Flujo de trabajo en Java::
Según la unidad, ¿cuál es la secuencia correcta para desarrollar y ejecutar un programa en Java?
{
=Escribir código fuente -> Compilar con `javac` a bytecode -> Ejecutar con `java` en la JVM. #Correcto: La unidad detalla que primero se crea el archivo `.java`, luego se compila a `.class` y finalmente la JVM lo ejecuta. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%Escribir bytecode -> Interpretarlo con la JVM -> Generar código fuente automáticamente. #Incorrecto: El bytecode se genera a partir del código fuente; no se escribe manualmente. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%Escribir código fuente -> Ejecutar directamente el `.java` -> Compilar si hay errores. #Incorrecto: El `.java` no se ejecuta directamente; debe compilarse primero. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%Compilar con `javac` -> Enlazar bibliotecas nativas -> Crear un ejecutable `.exe` portátil. #Incorrecto: El proceso estándar produce bytecode `.class` que se ejecuta en la JVM, no un `.exe` nativo. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
}

::CE 1.d – Ventaja de portabilidad::
Tu equipo quiere distribuir una aplicación Java en Windows, Linux y macOS. ¿Qué ventaja resalta la unidad sobre el código intermedio?
{
=Que el mismo bytecode puede ejecutarse en cualquier plataforma que tenga instalada la máquina virtual correspondiente. #Correcto: Es el famoso "Write Once, Run Anywhere"; solo se requiere la JVM adecuada en cada sistema. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Que el bytecode se convierte automáticamente en ejecutables nativos distintos para cada sistema. #Incorrecto: No se generan ejecutables nativos separados; se usa el mismo bytecode y cada JVM lo interpreta o compila. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Que el bytecode se adapta a la interfaz gráfica de cada sistema sin intervención. #Incorrecto: La portabilidad no implica adaptar interfaces automáticamente; eso depende del programa, no del bytecode. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Que la máquina virtual reescribe el código fuente en el idioma local de cada país. #Incorrecto: La VM no traduce idiomas; solo ejecuta bytecode. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
}

::CE 1.d – Seguridad en máquinas virtuales::
¿Qué aporta la máquina virtual a nivel de seguridad según la unidad?
{
=Verifica y controla el acceso del código intermedio al sistema operativo y al hardware. #Correcto: La VM añade una capa de seguridad que evita que bytecode malicioso acceda libremente a recursos del sistema. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Permite que el código intermedio modifique directamente la BIOS para ganar rendimiento. #Incorrecto: La VM limita el acceso al hardware, no lo amplía de forma directa. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Reemplaza automáticamente el antivirus del sistema operativo. #Incorrecto: La VM no sustituye herramientas de seguridad tradicionales; complementa la protección. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Impide que se instalen actualizaciones del sistema para evitar riesgos. #Incorrecto: La VM no gestiona las actualizaciones del sistema operativo. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
}

::CE 1.d – Compilación JIT::
Durante la ejecución, la JVM activa la compilación Just-In-Time (JIT). ¿Qué beneficio destaca la unidad?
{
=Optimizar el rendimiento convirtiendo las partes más usadas del bytecode en código nativo en tiempo de ejecución. #Correcto: La JIT analiza el comportamiento real y convierte los puntos calientes en instrucciones nativas optimizadas. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Permitir que el bytecode se ejecute sin máquina virtual. #Incorrecto: La JIT sigue necesitando la JVM; simplemente compila fragmentos a código nativo. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Convertir automáticamente el programa en código fuente de C para depurarlo. #Incorrecto: La JIT no traduce a otros lenguajes de alto nivel; produce código nativo temporal. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Reducir el tamaño del bytecode eliminando clases y métodos. #Incorrecto: La JIT optimiza la ejecución, no modifica el tamaño del bytecode almacenado. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
}

::CE 1.d – Resultado de `javac`::
Compilas `Suma.java` siguiendo el ejemplo de la unidad. ¿Qué archivo obtienes tras ejecutar `javac Suma.java`?
{
=El archivo `Suma.class`, que contiene el bytecode portable del programa. #Correcto: El compilador genera un `.class` con bytecode listo para que la JVM lo ejecute. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%Un archivo `Suma.exe` nativo para Windows. #Incorrecto: El proceso estándar genera `.class`, no ejecutables nativos. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%Un archivo `Suma.pyc` compatible con Python. #Incorrecto: El compilador de Java no genera archivos para Python. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
~%-33.3333%Un documento `Suma.txt` con un resumen de la ejecución. #Incorrecto: El compilador no produce documentos de texto con resúmenes; genera bytecode. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '4. Ejemplo Completo: Java y la JVM'.
}

::CE 1.d – Si no se usara código intermedio::
¿Qué desventaja menciona la unidad si un lenguaje no generara código intermedio?
{
=Que habría que compilar versiones distintas del programa para cada sistema operativo y arquitectura. #Correcto: Sin código intermedio perderíamos la portabilidad y tendríamos que mantener binarios específicos por plataforma. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5. ¿Qué Ocurre si No Usamos Código Intermedio?'.
~%-33.3333%Que el programa sería automáticamente más rápido en todos los sistemas. #Incorrecto: La velocidad no aumenta solo por eliminar el código intermedio; al contrario, se pierde portabilidad. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5. ¿Qué Ocurre si No Usamos Código Intermedio?'.
~%-33.3333%Que ya no sería necesario probar el software en varias plataformas. #Incorrecto: Sin código intermedio habría que probar cada versión nativa, lo que complica aún más el proceso. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5. ¿Qué Ocurre si No Usamos Código Intermedio?'.
~%-33.3333%Que el código fuente se convertiría en documentación técnica. #Incorrecto: El código fuente seguiría siendo código; lo que cambia es la portabilidad. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '5. ¿Qué Ocurre si No Usamos Código Intermedio?'.
}

::CE 1.d – Ejecución en diferentes arquitecturas::
Compilas tu aplicación Java en un Mac ARM y quieres ejecutarla en un servidor Linux x86-64. ¿Qué ocurrirá?
{
=Funcionará si el servidor tiene JVM, porque el bytecode es independiente de la arquitectura y la JVM lo traduce a la CPU disponible. #Correcto: La portabilidad es posible gracias a que cada JVM convierte el bytecode a instrucciones nativas de su plataforma. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Fallará porque el bytecode está compilado para ARM y no puede ejecutarse en x86-64. #Incorrecto: El bytecode no está ligado a una arquitectura concreta; la JVM maneja la traducción. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Requerirá recompilar el `.java` en el servidor Linux antes de ejecutarse. #Incorrecto: No es necesario recompilar si ya tienes el bytecode; basta con tener la JVM. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
~%-33.3333%Solo funcionará si instalas un emulador de ARM en el servidor Linux. #Incorrecto: No se necesita emulación de CPU; la JVM se encarga de traducir el bytecode. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '3. ¿Por Qué Usar Código Intermedio?'.
}

::CE 1.d – Conclusión de la unidad::
Según la conclusión, ¿por qué es importante comprender la generación de código intermedio?
{
=Porque permite crear software portable y entender cómo las máquinas virtuales equilibran portabilidad, seguridad y rendimiento. #Correcto: La unidad remarca que dominar estas fases ayuda a aprovechar la portabilidad y las optimizaciones de la VM. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '7. Conclusión'.
~%-33.3333%Porque elimina la necesidad de conocer el lenguaje de alto nivel. #Incorrecto: Entender el código intermedio no sustituye aprender el lenguaje fuente. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '7. Conclusión'.
~%-33.3333%Porque permite generar código ejecutable sin máquinas virtuales. #Incorrecto: La conclusión destaca la importancia de las máquinas virtuales, no su eliminación. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '7. Conclusión'.
~%-33.3333%Porque garantiza que el programa no necesitará mantenimiento futuro. #Incorrecto: Comprender el proceso no elimina la necesidad de mantenimiento; simplemente facilita el desarrollo. Consulta `EDES-U1.3.-CodigoIntermedio.md`, sección '7. Conclusión'.
}

// EDES-U1.4 - Traductores
// Banco de preguntas sobre compiladores, intérpretes y traductores
// CE 1.4 - Tipos de traductores y proceso de compilación

::CE 1.4 – Compilación AOT para videojuego::
Estás desarrollando un videojuego AAA en C++ que requiere máximo rendimiento. El equipo debate si usar compilación AOT o interpretación. ¿Qué ventaja ofrece la compilación AOT en este escenario?
{
=El código se traduce completamente a instrucciones máquina nativas antes de ejecutar, permitiendo optimizaciones agresivas y rendimiento máximo sin overhead de interpretación. #Correcto\: Compilación AOT (Ahead-Of-Time) para videojuegos\: (1) PROCESO\: g++ -O3 juego.cpp → juego.exe (código máquina x86/ARM nativo). (2) OPTIMIZACIONES\: Loop unrolling, vectorización SIMD, inline agresivo, eliminación código muerto, optimizaciones específicas de CPU. (3) EJECUCIÓN\: El .exe contiene instrucciones directas de CPU, sin intérprete, sin VM, sin overhead. (4) RENDIMIENTO\: Crítico para videojuegos AAA donde cada frame cuenta (60+ FPS). El compilador tiene TODO el tiempo del mundo para optimizar antes de distribuir. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%La interpretación es mejor porque permite modificar el código del juego en tiempo real sin recompilar. #Incorrecto\: Aunque la interpretación permite modificación dinámica, el COSTO de rendimiento es INACEPTABLE para videojuegos AAA\: • Interpretación\: Lee código, traduce a acciones, ejecuta (overhead significativo). • Videojuegos AAA necesitan\: Renderizar millones de polígonos, física compleja, IA, audio, red, TODO a 60+ FPS. • Incluso con JIT, el warm-up y overhead serían problemáticos. • La modificación dinámica NO vale la pérdida de 50-90% de rendimiento. Los estudios AAA usan C++ compilado AOT por rendimiento. Algunos usan scripting interpretado (Lua/Python) solo para LÓGICA de juego, no motor. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%AOT genera bytecode portable que funciona en todas las plataformas de consolas sin cambios. #Incorrecto\: CONFUSIÓN con máquinas virtuales. AOT NO genera bytecode portable\: • AOT\: Compilación a código NATIVO específico de plataforma (PlayStation→ARM, Xbox→x86-64, PC→x86-64/ARM). • Bytecode portable\: Es lo que genera Java/C#, NO C++ con AOT. • Para consolas, DEBES compilar separadamente\: PlayStation build, Xbox build, PC build (arquitecturas diferentes). • La ventaja de AOT NO es portabilidad; es RENDIMIENTO máximo. Sacrificas portabilidad (código fuente portable, binarios no) a cambio de velocidad extrema. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%AOT permite al juego ejecutarse sin sistema operativo directamente en el hardware de la consola. #Incorrecto\: PARCIALMENTE CIERTO pero NO es la ventaja principal. Aunque videojuegos consola SÍ ejecutan "cerca del metal"\: (1) Las consolas TIENEN un SO ligero (FreeBSD modificado en PS, Windows modificado en Xbox). (2) AOT permite código nativo que el SO de consola carga y ejecuta directamente. (3) Pero esto NO es exclusivo de AOT; cualquier código compilado hace esto. La ventaja REAL de AOT vs interpretación es RENDIMIENTO (código optimizado nativo), NO la ausencia de SO. El SO sigue existiendo en consolas. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
}

::CE 1.4 – Interpretación para scripting web::
Desarrollas un servidor web Node.js que ejecuta JavaScript del lado servidor. ¿Por qué JavaScript usa interpretación (con JIT) en lugar de compilación AOT como C?
{
=Permite ejecución inmediata del código fuente sin pasos de compilación separados, facilitando desarrollo rápido, despliegue dinámico y modificación de código en caliente. #Correcto\: Ventajas de interpretación para JavaScript/Node.js\: (1) DESARROLLO\: Editas código.js → refrescas → cambios inmediatos. Sin compilación lenta. (2) DESPLIEGUE\: Subes archivos .js al servidor → funcionan inmediatamente. Sin build process. (3) DINÁMICO\: eval(), require() dinámico, código generado en runtime. (4) JIT MODERNO\: V8 (motor de Node.js) compila JIT a código nativo → rendimiento cercano a compilado. (5) PRODUCTIVIDAD\: Ciclo edit-run instantáneo vs edit-compile-link-run de C++. Para servidores web (I/O bound más que CPU bound), la velocidad de desarrollo vale más que el último 10% de rendimiento. Consulta `EDES-U1.4.-Traductores.md`, sección '2. Interpretación y lenguajes interpretados'.
~%-33.3333%JavaScript no puede compilarse a código nativo bajo ninguna circunstancia por limitaciones del lenguaje. #Incorrecto\: FALSO. JavaScript SÍ puede compilarse a código nativo\: • V8 (motor Node.js/Chrome)\: Usa JIT para compilar JavaScript → código máquina en runtime. • Hermes (React Native)\: Compila JavaScript a bytecode ahead-of-time. • QuickJS\: Puede compilar JavaScript a ejecutables nativos. • WebAssembly\: JavaScript puede compilar WASM a código nativo. La RAZÓN de interpretación es DISEÑO y CONVENIENCIA, NO imposibilidad técnica. JavaScript fue diseñado para ejecución inmediata en navegadores, no compilación previa. Consulta `EDES-U1.4.-Traductores.md`, sección '2. Interpretación y lenguajes interpretados'.
~%-33.3333%La interpretación es más rápida que compilación AOT porque evita la fase de compilación. #Incorrecto\: CONFUNDE desarrollo vs ejecución. DESARROLLAR es más rápido con interpretación (sin esperar compilación), pero EJECUTAR es más lento\: • Interpretación pura\: Lee código fuente, traduce, ejecuta (overhead en cada ejecución). • AOT\: Compilación lenta UNA VEZ, ejecución rápida SIEMPRE. • JIT (híbrido)\: Compila en primera ejecución, optimiza con datos reales. • Para Node.js, el trade-off es\: Desarrollo ágil + rendimiento "suficientemente bueno" con JIT > Rendimiento máximo con AOT. La interpretación NO es más rápida en ejecución; es más rápida en desarrollo. Consulta `EDES-U1.4.-Traductores.md`, sección '2. Interpretación y lenguajes interpretados'.
~%-33.3333%JavaScript interpretado consume menos memoria que código compilado porque no genera archivos binarios. #Incorrecto\: FALSO. Interpretación puede consumir MÁS memoria\: • Interpretación\: Mantiene código fuente en memoria + estructuras AST + bytecode + datos del intérprete. • Compilado AOT\: Solo código máquina (compacto) + datos. • JIT (Node.js/V8)\: Código fuente + bytecode + código máquina generado JIT + metadata de optimización → MUCHO más que solo binario. Node.js es notorio por uso alto de RAM comparado con lenguajes compilados. La ventaja NO es memoria; es flexibilidad y velocidad de desarrollo. Consulta `EDES-U1.4.-Traductores.md`, sección '2. Interpretación y lenguajes interpretados'.
}

::CE 1.4 – Compilador JIT en acción::
Tu aplicación Java corre en un servidor 24/7 procesando transacciones. Notas que después de una hora, el throughput aumenta un 30% sin cambios en el código. ¿Qué está ocurriendo?
{
=El compilador JIT de la JVM detectó métodos "calientes" (ejecutados frecuentemente) y los recompiló a código máquina nativo optimizado, mejorando el rendimiento. #Correcto\: Proceso JIT detallado\: (1) INICIO\: JVM interpreta bytecode (lento pero arranque rápido). (2) PROFILING\: Cuenta ejecuciones de cada método (invocation counter). (3) THRESHOLD\: Cuando método se ejecuta >N veces (ej. 10000), se marca "hot". (4) COMPILACIÓN C1\: Compilador JIT C1 (client) genera código nativo con optimizaciones ligeras (rápido). (5) COMPILACIÓN C2\: Compilador C2 (server) recompila con optimizaciones agresivas\: inline, especialización, eliminación código muerto. (6) RESULTADO\: Código crítico ejecuta a velocidad nativa. El 30% de mejora es típico después de warm-up JIT. Consulta `EDES-U1.4.-Traductores.md`, sección '3. Compilación en tiempo de ejecución'.
~%-33.3333%El sistema operativo optimizó la asignación de memoria automáticamente después de analizar patrones de uso. #Incorrecto\: El SO hace gestión de memoria, pero NO explica mejora tan significativa y consistente\: • El SO gestiona\: paginación, swap, caché de disco (continuo, no "después de 1 hora"). • Una mejora de 30% de throughput NO viene de optimización de SO. • Si fuera SO, afectaría a TODAS las aplicaciones, no solo Java. El patrón de "mejora gradual en primera hora" es CARACTERÍSTICO de JIT warm-up. Experimentos\: (1) -Xint (solo interpretación)\: NO hay mejora. (2) -Xcomp (compilar todo al inicio)\: Rendimiento bueno desde el principio, pero sin optimizaciones basadas en datos reales. El JIT es la causa. Consulta `EDES-U1.4.-Traductores.md`, sección '3. Compilación en tiempo de ejecución'.
~%-33.3333%La JVM está descargando trabajo a la GPU después de la primera hora de análisis de carga. #Incorrecto\: FALSO. La JVM estándar NO descarga automáticamente a GPU\: • La GPU se usa para\: gráficos, cómputo paralelo (CUDA/OpenCL), aprendizaje automático. • La JVM NO migra código arbitrario a GPU automáticamente (requiere APIs específicas\: JOCL, Aparapi). • Procesar transacciones (lógica de negocio, base de datos, red) NO es paralelizable en GPU. • La mejora de 30% viene de JIT compilando bytecode → código CPU nativo optimizado, NO de GPU. Esta respuesta confunde JIT con computación heterogénea (CPU+GPU). Consulta `EDES-U1.4.-Traductores.md`, sección '3. Compilación en tiempo de ejecución'.
~%-33.3333%El garbage collector mejora después de aprender los patrones de creación de objetos. #Incorrecto\: Aunque el GC SÍ tiene adaptación, NO causa mejoras de 30% tan claras\: • GC moderno (G1, ZGC, Shenandoah)\: Adapta tamaños de generaciones, ajusta pausas. • Mejoras de GC\: Típicamente reducción de pausas (latencia), no tanto aumento de throughput. • Una mejora de throughput de 30% es DEMASIADO para ser solo GC. El JIT compilation es el factor DOMINANTE en mejora de rendimiento de aplicaciones Java long-running. GC contribuye, pero el JIT es la causa principal. Experimento\: Medir con -XX\:+PrintCompilation muestra compilaciones JIT correlacionadas con mejora de rendimiento. Consulta `EDES-U1.4.-Traductores.md`, sección '3. Compilación en tiempo de ejecución'.
}

::CE 1.4 – Transpilador TypeScript a JavaScript::
Tu equipo de frontend usa TypeScript pero los navegadores solo ejecutan JavaScript. ¿Qué hace el transpilador TypeScript (tsc) en este proceso?
{
=Convierte código fuente TypeScript (con tipos estáticos) a código fuente JavaScript (sin tipos), permitiendo que el navegador ejecute el resultado. #Correcto\: Proceso de transpilación TypeScript\: (1) ENTRADA\: archivo.ts con TypeScript (tipos estáticos, interfaces, genéricos, etc.). (2) VERIFICACIÓN DE TIPOS\: tsc comprueba que los tipos sean correctos (errores en tiempo de compilación). (3) TRANSPILACIÓN\: tsc genera archivo.js ELIMINANDO los tipos (JavaScript no los entiende). (4) SALIDA\: JavaScript estándar que cualquier navegador ejecuta. (5) VENTAJA\: Seguridad de tipos en desarrollo + compatibilidad con navegadores. TypeScript es un SUPERSET de JavaScript\: todo JS válido es TS válido, pero TS añade tipos. El transpilador "borra" los tipos. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%Compila TypeScript directamente a bytecode que el navegador ejecuta más rápido que JavaScript. #Incorrecto\: FALSO. Los navegadores NO ejecutan bytecode de TypeScript\: • Navegadores ejecutan\: JavaScript (interpretado/compilado JIT por motor V8/SpiderMonkey/JavaScriptCore). • TypeScript NO genera bytecode; genera JavaScript (código fuente). • El proceso es\: TypeScript → (transpilación) → JavaScript → (navegador compila JIT) → código máquina. • El rendimiento del JavaScript generado es IDÉNTICO a si escribieras JavaScript manualmente. TypeScript NO es más rápido en ejecución; es más SEGURO en desarrollo (detecta errores de tipos). Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%Interpreta TypeScript directamente en el navegador sin necesidad de convertirlo a JavaScript. #Incorrecto\: FALSO. Los navegadores NO entienden TypeScript nativamente\: • Los navegadores solo ejecutan\: JavaScript, WebAssembly. • NO hay motor TypeScript en navegadores. • DEBES transpilar TS → JS ANTES de cargar en el navegador. • Workflow típico\: (1) Desarrollo\: Escribes .ts. (2) Build\: tsc genera .js. (3) Despliegue\: Subes .js al servidor. (4) Navegador\: Descarga y ejecuta .js (NO .ts). Algunos bundlers (webpack + ts-loader) pueden hacer esto transparentemente, pero SIEMPRE hay transpilación TS→JS. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%Convierte JavaScript a TypeScript para añadir tipos automáticamente al código existente. #Incorrecto\: AL REVÉS. TypeScript → JavaScript, NO JavaScript → TypeScript\: • Transpilación es\: TypeScript (con tipos) → JavaScript (sin tipos). • Convertir JavaScript → TypeScript (añadir tipos) es POSIBLE pero\: (1) Requiere herramientas diferentes (no tsc, sino análisis estático). (2) Los tipos serían inferidos/adivinados, no garantizados correctos. (3) NO es lo que hace el transpilador tsc. tsc hace lo contrario\: ELIMINA tipos. Puedes migrar código JS a TS manualmente (renombrar .js→.ts y añadir tipos gradualmente), pero no es transpilación automática. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
}

::CE 1.4 – Análisis léxico en compilación::
Un compilador de C está procesando el código "int suma = a + b;". ¿Qué hace la fase de análisis léxico con esta línea?
{
=Divide el texto en tokens\: 'int' (keyword), 'suma' (identifier), '=' (operator), 'a' (identifier), '+' (operator), 'b' (identifier), ';' (delimiter). #Correcto\: Análisis léxico (Lexer/Scanner)\: (1) ENTRADA\: Secuencia de caracteres (texto del código). (2) PROCESO\: Agrupa caracteres en TOKENS (unidades con significado)\: • 'int'\: KEYWORD (palabra reservada del lenguaje). • 'suma'\: IDENTIFIER (nombre de variable). • '='\: OPERATOR (asignación). • 'a', 'b'\: IDENTIFIER. • '+'\: OPERATOR (suma). • ';'\: DELIMITER (fin de sentencia). (3) SALIDA\: Secuencia de tokens que alimenta el análisis sintáctico. (4) ELIMINA\: Espacios, comentarios (irrelevantes para sintaxis). El lexer NO entiende significado; solo clasifica. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%Verifica que las variables 'a' y 'b' estén declaradas antes de usarse en la expresión. #Incorrecto\: Eso es ANÁLISIS SEMÁNTICO, NO léxico. Las fases del compilador\: (1) LÉXICO\: Divide texto en tokens (no entiende variables, tipos, declaraciones). (2) SINTÁCTICO\: Construye AST (verifica gramática\: "int X = Y;" es válido). (3) SEMÁNTICO\: Verifica SIGNIFICADO\: variables declaradas, tipos compatibles, scope correcto. En análisis léxico, el compilador NO sabe que 'a' y 'b' son variables ni si están declaradas. Solo sabe que son "identificadores" (tokens de tipo IDENTIFIER). La verificación de declaración viene DESPUÉS. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%Genera el código máquina correspondiente a la operación de suma de 'a' y 'b'. #Incorrecto\: Eso es GENERACIÓN DE CÓDIGO, la ÚLTIMA fase, NO léxico. Orden de fases\: (1) LÉXICO\: texto → tokens. (2) SINTÁCTICO\: tokens → AST. (3) SEMÁNTICO\: AST → AST anotado (con tipos, símbolos). (4) GENERACIÓN CÓDIGO INTERMEDIO\: AST → IR. (5) OPTIMIZACIÓN\: IR → IR optimizado. (6) GENERACIÓN CÓDIGO MÁQUINA\: IR → assembly/binario. El análisis léxico es la PRIMERA fase; solo tokeniza. No genera código máquina (eso sería saltar todas las fases intermedias). Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%Construye el árbol de sintaxis abstracta (AST) representando la estructura de la declaración. #Incorrecto\: Eso es ANÁLISIS SINTÁCTICO (Parser), NO léxico. Diferencia\: • ANÁLISIS LÉXICO\: texto → lista plana de tokens (secuencial). Ejemplo\: ['int', 'suma', '=', 'a', '+', 'b', ';']. • ANÁLISIS SINTÁCTICO\: tokens → árbol AST (jerárquico). Ejemplo\: Declaration(type=int, name=suma, init=BinaryOp(left=a, op=+, right=b)). El lexer produce entrada para el parser; el parser construye el AST. El lexer NO entiende estructura; solo clasifica tokens. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
}

::CE 1.4 – Análisis sintáctico con error::
Compilas código C con la línea "int x = (5 + 3;". El compilador da error en análisis sintáctico. ¿Qué detectó?
{
=Falta el paréntesis de cierre ')' antes del punto y coma, violando la gramática del lenguaje que requiere paréntesis balanceados. #Correcto\: Análisis sintáctico (Parser)\: (1) ENTRADA\: Secuencia de tokens del lexer\: ['int', 'x', '=', '(', '5', '+', '3', ';']. (2) PROCESO\: Construye AST según GRAMÁTICA del lenguaje C. (3) GRAMÁTICA espera\: expresión entre paréntesis debe tener '(' y ')' balanceados. (4) ERROR DETECTADO\: '(' sin ')' correspondiente. (5) MENSAJE\: "syntax error\: expected ')' before ';'". El parser verifica ESTRUCTURA del código (gramática), NO significado. Detecta errores como\: paréntesis desbalanceados, falta punto y coma, orden incorrecto de tokens. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%La variable 'x' no está declarada previamente, causando un error de referencia. #Incorrecto\: ESO sería error SEMÁNTICO, y además la línea SÍ declara 'x'\: • "int x = ..." ES una declaración de variable (tipo int, nombre x). • Si el problema fuera "x no declarado", sería usar 'x' SIN declararla antes (ej. "x = 5;" sin "int x" previo). • Ese error se detecta en ANÁLISIS SEMÁNTICO (tabla de símbolos), NO sintáctico. El error REAL es sintáctico\: paréntesis desbalanceados. El parser detecta estructura incorrecta, no significado de variables. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%El valor 5 + 3 debería calcularse antes de asignar, pero el compilador no puede hacerlo. #Incorrecto\: CONFUSIÓN múltiple\: (1) Los compiladores SÍ pueden calcular expresiones constantes (constant folding)\: "5+3" → "8" en optimización. (2) Pero NO es un ERROR no hacerlo; es una optimización opcional. (3) El error REAL es sintáctico\: paréntesis desbalanceados "( ... ;" sin ')'. (4) Incluso si el compilador NO optimizara 5+3, generaría código que lo calcula en runtime (sin error). El problema NO es evaluación de expresión; es sintaxis incorrecta. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%El operador '+' no puede usarse entre literales numéricos en C, solo entre variables. #Incorrecto\: TOTALMENTE FALSO. En C (y casi todos los lenguajes)\: • Puedes sumar literales\: "5 + 3" es PERFECTAMENTE válido. • Puedes mezclar literales y variables\: "5 + x", "x + 3", "5 + 3 + x". • El compilador puede optimizar sumas de literales (constant folding). El error REAL es paréntesis desbalanceados. Esta respuesta inventa una restricción inexistente del lenguaje C. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
}

::CE 1.4 – Análisis semántico con error de tipos::
Compilas en Java "String nombre = 42;". El compilador da error. ¿En qué fase se detecta y por qué?
{
=En análisis semántico, porque detecta incompatibilidad de tipos\: intentas asignar un int (42) a una variable de tipo String. #Correcto\: Análisis semántico verifica SIGNIFICADO del código\: (1) SINTAXIS\: "String nombre = 42;" es sintácticamente correcto (estructura válida\: tipo + nombre + '=' + expresión + ';'). (2) TOKENS y AST\: Correctos. (3) SEMÁNTICA\: Verifica TIPOS\: • Variable 'nombre' es tipo String. • Expresión '42' es tipo int. • Regla\: Tipo de expresión debe ser compatible con tipo de variable. • ERROR\: int NO es compatible con String (no hay conversión automática). (4) MENSAJE\: "Type mismatch\: cannot convert from int to String". La verificación de tipos es ANÁLISIS SEMÁNTICO. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%En análisis léxico, porque el lexer detecta que números no pueden asignarse a variables String. #Incorrecto\: El lexer NO entiende tipos ni variables. Análisis léxico solo\: (1) Divide texto en tokens\: ['String', 'nombre', '=', '42', ';']. (2) Clasifica cada token\: 'String' (IDENTIFIER o KEYWORD), 'nombre' (IDENTIFIER), '=' (OPERATOR), '42' (NUMBER_LITERAL), ';' (DELIMITER). (3) NO sabe que 'String' es un tipo ni que '42' es incompatible. El lexer produce tokens sin entender significado. La verificación de tipos ocurre en ANÁLISIS SEMÁNTICO, mucho después del léxico. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%En análisis sintáctico, porque la gramática de Java prohíbe literales numéricos después de '='. #Incorrecto\: FALSO. La gramática de Java SÍ permite literales después de '='\: • "int x = 42;" es PERFECTAMENTE válido. • "String s = \"hola\";" también. • Sintácticamente, "String nombre = 42;" es CORRECTO (estructura\: declaración + asignación). El problema NO es sintáctico (estructura), es SEMÁNTICO (tipos incompatibles). El parser acepta la estructura; el analizador semántico rechaza la combinación de tipos. Sintaxis = estructura; semántica = significado/tipos. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%En generación de código, porque el compilador no puede generar bytecode para asignar int a String. #Incorrecto\: El error se detecta ANTES de generación de código. Orden de fases\: (1) Léxico → tokens. (2) Sintáctico → AST. (3) Semántico → verifica tipos, símbolos (ERROR AQUÍ). (4) Generación código (NUNCA SE ALCANZA si hay errores semánticos). Los compiladores usan "fail-fast"\: detectan errores lo antes posible. Un error de tipos se detecta en semántica, deteniendo la compilación antes de generar código. Nunca llegas a generación de código con errores semánticos. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
}

::CE 1.4 – Estructura del compilador (Frontend vs Backend)::
El compilador GCC puede compilar C, C++ y Fortran para arquitecturas x86, ARM y RISC-V. ¿Cómo logra esta flexibilidad?
{
=Arquitectura modular\: Frontend (específico del lenguaje) genera IR común; Backend (específico de arquitectura) genera código máquina desde IR. #Correcto\: Estructura del compilador moderno\: (1) FRONTEND (N frontends para N lenguajes)\: • Frontend C\: Parsea C → genera IR (Intermediate Representation). • Frontend C++\: Parsea C++ → genera IR. • Frontend Fortran\: Parsea Fortran → genera IR. Todos producen la MISMA IR (GIMPLE en GCC, LLVM IR en Clang). (2) OPTIMIZADOR (compartido)\: Optimiza IR (loop unrolling, inline, etc.) independiente de lenguaje Y arquitectura. (3) BACKEND (M backends para M arquitecturas)\: • Backend x86\: IR → código x86. • Backend ARM\: IR → código ARM. Resultado\: N×M combinaciones con solo N+M módulos (no N×M compiladores separados). Consulta `EDES-U1.4.-Traductores.md`, sección '1.2. Estructura de un Compilador'.
~%-33.3333%GCC reescribe todo el código fuente a un lenguaje universal antes de compilar para cada arquitectura. #Incorrecto\: PARCIALMENTE correcto pero MAL EXPLICADO. GCC NO reescribe a "lenguaje universal" (código fuente)\: • GCC genera REPRESENTACIÓN INTERMEDIA (IR), que es CÓDIGO de bajo nivel (no código fuente). • IR NO es un lenguaje de programación legible; es una estructura interna del compilador (similar a bytecode pero no ejecutable). • El proceso es\: C/C++/Fortran → IR (interno) → código máquina. NO es\: C → UniversalLanguage.c → código máquina. La IR es un formato interno, no un lenguaje de programación. El concepto es correcto (representación común), pero la descripción como "lenguaje universal" es engañosa. Consulta `EDES-U1.4.-Traductores.md`, sección '1.2. Estructura de un Compilador'.
~%-33.3333%Cada combinación lenguaje-arquitectura tiene un compilador separado (GCC tiene 9 compiladores diferentes). #Incorrecto\: INEFICIENTE y NO es cómo funciona GCC. Si fuera así\: • 3 lenguajes × 3 arquitecturas = 9 compiladores completos. • Añadir un nuevo lenguaje requeriría escribir 3 compiladores (para cada arquitectura). • Añadir nueva arquitectura requeriría 3 compiladores (para cada lenguaje). Duplicación masiva de código. GCC usa arquitectura modular (frontend-IR-backend)\: • Añadir lenguaje\: 1 nuevo frontend (genera IR). • Añadir arquitectura\: 1 nuevo backend (lee IR). Resultado\: 3+3=6 módulos, NO 9 compiladores. Mucho más eficiente y mantenible. Consulta `EDES-U1.4.-Traductores.md`, sección '1.2. Estructura de un Compilador'.
~%-33.3333%GCC compila todo a bytecode Java, que luego se ejecuta en JVM para cada arquitectura. #Incorrecto\: TOTALMENTE FALSO. GCC NO genera bytecode Java\: • GCC genera código MÁQUINA NATIVO (binarios ELF, ejecutables). • No hay JVM involucrada en GCC. • La IR interna (GIMPLE) NO es bytecode ejecutable; es formato interno del compilador. • Confusión completa entre\: (1) GCC (compilador nativo)\: C++ → código máquina. (2) javac (compilador Java)\: Java → bytecode → JVM. Son herramientas y modelos completamente diferentes. GCC produce ejecutables nativos, no bytecode. Consulta `EDES-U1.4.-Traductores.md`, sección '1.2. Estructura de un Compilador'.
}

::CE 1.4 – AST (Árbol de Sintaxis Abstracta)::
El parser genera un AST para la expresión "resultado = (a + b) * c;". ¿Qué representa el AST?
{
=Una estructura de árbol jerárquica donde la raíz es 'asignación', con 'resultado' a la izquierda y '*' a la derecha, que tiene '+' (con 'a','b') y 'c' como hijos. #Correcto\: Estructura del AST\: ``` Asignación ├─ izq\: resultado └─ der\: Multiplicación ├─ izq\: Suma │ ├─ izq\: a │ └─ der\: b └─ der\: c ``` El AST\: (1) ABSTRAE sintaxis concreta (sin paréntesis, punto y coma en el árbol). (2) REPRESENTA estructura semántica (precedencia de operadores\: suma antes que multiplicación). (3) JERÁRQUICO\: Nodos internos = operadores; hojas = variables/literales. (4) FACILITA\: Análisis semántico (recorrer árbol verificando tipos), generación de código (traversal del árbol). El AST es la representación interna fundamental del programa durante compilación. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%Una lista secuencial de tokens en el orden en que aparecen en el código fuente. #Incorrecto\: Eso es la salida del LEXER, NO del parser. Diferencia\: • LEXER (análisis léxico)\: Produce lista plana de tokens\: ['resultado', '=', '(', 'a', '+', 'b', ')', '*', 'c', ';']. • PARSER (análisis sintáctico)\: Produce árbol jerárquico AST (estructura con relaciones padre-hijo). El AST NO es lista; es ÁRBOL. Captura estructura y precedencia (paréntesis en código → estructura en árbol). La lista de tokens pierde información de estructura; el AST la preserva. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%El código máquina generado para ejecutar la operación en el procesador. #Incorrecto\: El AST es INTERMEDIO, NO código final. Flujo completo\: (1) Código fuente. (2) Tokens (lexer). (3) AST (parser) ← ESTAMOS AQUÍ. (4) AST anotado (análisis semántico). (5) IR (código intermedio). (6) IR optimizado. (7) Código máquina (generación final). El AST está en la fase 3 de ~7 fases. Es una REPRESENTACIÓN abstracta del programa, no código ejecutable. El código máquina viene DESPUÉS, generado A PARTIR del AST. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%Una tabla de símbolos con las variables 'resultado', 'a', 'b', 'c' y sus tipos. #Incorrecto\: Eso es la TABLA DE SÍMBOLOS, NO el AST. Son estructuras diferentes\: • AST\: Representa ESTRUCTURA del código (expresiones, sentencias, control flow). Árbol jerárquico de operaciones. • TABLA DE SÍMBOLOS\: Diccionario de identificadores → información (tipo, scope, offset memoria). Estructura plana (tabla/hashmap). AMBOS se usan en compilación\: • AST\: Para generar código. • Tabla símbolos\: Para verificar tipos, resolver referencias. Pero son estructuras separadas con propósitos diferentes. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
}

::CE 1.4 – Optimización de código::
El compilador ve el código "int x = 5 * 10; int y = x + 0;". ¿Qué optimizaciones puede aplicar?
{
=Constant folding (5*10 → 50) y eliminación de operaciones identidad (x+0 → x), generando simplemente "int x = 50; int y = x;". #Correcto\: Optimizaciones aplicadas\: (1) CONSTANT FOLDING\: Evalúa expresiones constantes en tiempo de compilación\: • "5 * 10" → "50" (sin generar código de multiplicación). (2) IDENTITY ELIMINATION\: Elimina operaciones que no cambian valor\: • "x + 0" → "x" (sumar 0 es identidad). (3) CÓDIGO OPTIMIZADO\: "int x = 50; int y = x;" → Solo 2 asignaciones, sin multiplicación ni suma. (4) BENEFICIO\: Código más pequeño, ejecución más rápida (sin operaciones innecesarias). (5) NIVEL\: Optimizaciones básicas (-O1), casi todos los compiladores las hacen. Optimizaciones más avanzadas\: inlining, loop unrolling, vectorización. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%No puede optimizar porque las variables son declaradas separadamente y no se conocen en tiempo de compilación. #Incorrecto\: FALSO. Las variables SÍ se conocen en tiempo de compilación\: • "int x = 5 * 10;" → El compilador VE que 5 y 10 son LITERALES constantes. • NO dependen de input de usuario, runtime, ni nada externo. • El compilador puede evaluar "5 * 10 = 50" durante compilación. • Aunque 'x' sea variable, su INICIALIZADOR es constante → optimizable. Solo NO podría optimizar si fuera "int a = leerEntrada(); int x = 5 * a;" (depende de runtime). Pero con literales, la optimización es trivial. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%Puede vectorizar las operaciones usando instrucciones SIMD para calcular x e y en paralelo. #Incorrecto\: EXAGERADO. Vectorización SIMD se usa para\: • Operaciones PARALELAS sobre ARRAYS/vectores de datos. • Ejemplo\: "for(i=0;i<1000;i++) a[i]=b[i]+c[i];" → procesar 4-8 elementos simultáneamente. Para 2 variables escalares independientes ("int x = ...; int y = ...;"), SIMD NO aplica\: (1) Solo hay 2 operaciones (no es loop con muchas iteraciones). (2) No hay paralelismo de datos (x e y son independientes, pero solo UNA instancia de cada). Las optimizaciones aplicables son constant folding e identity elimination, NO vectorización SIMD. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%Puede eliminar completamente las variables x e y si no se usan después, guardando memoria. #Incorrecto\: Eso sería DEAD CODE ELIMINATION, pero requiere más contexto. DEPENDE de si x e y se usan después\: • Si x e y NO se usan\: Compilador elimina todo el código (dead code). • Si x e y SÍ se usan\: Compilador optimiza las asignaciones (constant folding, identity elimination) pero MANTIENE las variables. La pregunta no especifica si se usan después. Las optimizaciones CIERTAS son constant folding y identity elimination (aplicables independientemente de uso posterior). Dead code elimination es POSIBLE pero requiere analizar el código completo, no solo estas 2 líneas. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
}


::CE 1.4 – Transpilador Kotlin a JavaScript::
Tu equipo desarrolla una aplicación web y quiere usar Kotlin en lugar de JavaScript en el frontend. ¿Cómo funciona Kotlin/JS en este escenario?
{
=El compilador Kotlin/JS transpila código Kotlin a JavaScript que el navegador puede ejecutar, manteniendo la lógica pero generando sintaxis JS. #Correcto\: Proceso Kotlin/JS\: (1) DESARROLLO\: Escribes código en Kotlin (.kt)\: tipos estáticos, null-safety, clases, funciones de orden superior. (2) TRANSPILACIÓN\: kotlinc-js compila Kotlin → JavaScript (.js)\: • NO es compilación a bytecode. • NO es ejecución en VM. • Es traducción fuente-a-fuente (source-to-source compilation = transpilación). (3) SALIDA\: JavaScript estándar que navegadores ejecutan. (4) VENTAJA\: Desarrollas con features modernas de Kotlin, ejecutas en cualquier navegador. (5) SIMILAR A\: TypeScript→JS, CoffeeScript→JS, Dart→JS. El navegador solo ve JavaScript normal. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%Kotlin/JS compila a bytecode de JVM que un plugin de navegador ejecuta como Java applets. #Incorrecto\: FALSO y ANTICUADO. Kotlin/JS NO usa JVM en navegadores\: • Kotlin/JVM\: Compila a bytecode JVM para backend (servidor). • Kotlin/JS\: Transpila a JavaScript para frontend (navegador). • Los navegadores NO ejecutan bytecode JVM (los Java Applets murieron hace años por seguridad). • NO hay plugin JVM en navegadores modernos. Kotlin/JS genera JavaScript puro que el motor JS del navegador (V8, SpiderMonkey) ejecuta. Es transpilación a JS, NO bytecode JVM. Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%El navegador descarga e instala automáticamente el runtime de Kotlin cuando carga la página. #Incorrecto\: NO hay "runtime de Kotlin" separado en Kotlin/JS\: • El código Kotlin transpilado a JavaScript INCLUYE lo necesario de la biblioteca estándar Kotlin (inline en el .js generado). • El navegador ejecuta JavaScript puro, sin runtime especial. • NO se descarga nada adicional (a menos que uses bibliotecas Kotlin extras, que también se transpilan a JS). • Similar a TypeScript\: no hay "runtime TypeScript" en navegadores; todo se convierte a JS. El JavaScript generado es autocontenido (puede ser grande si incluye mucha std lib Kotlin, pero es JS normal). Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
~%-33.3333%Kotlin/JS genera WebAssembly binario que es más rápido que JavaScript en navegadores. #Incorrecto\: CONFUSIÓN. Kotlin/JS NO genera WebAssembly\: • Kotlin/JS → JavaScript (transpilación fuente-a-fuente). • Kotlin/Native → Puede generar ejecutables nativos, pero NO está diseñado para Web. • Para WebAssembly, usarías\: Rust, C/C++ (Emscripten), AssemblyScript, o experimentalmente Kotlin/Native-WASM (en desarrollo). El Kotlin/JS mainstream genera JavaScript, NO WASM. El rendimiento es el mismo que JavaScript (porque ES JavaScript). Si quieres WASM desde Kotlin, necesitas Kotlin/Native con soporte experimental WASM (no Kotlin/JS). Consulta `EDES-U1.4.-Traductores.md`, sección '1. Compilación'.
}

::CE 1.4 – Diferencia compilador vs intérprete (ejecución)::
Python (CPython) y C++ usan enfoques diferentes. ¿Cuál es la diferencia clave en cómo el código llega a ejecutarse?
{
=C++ compila a código máquina ANTES de ejecutar (fase separada); Python compila a bytecode y lo interpreta/ejecuta en la misma fase (compilación implícita). #Correcto\: Comparación detallada\: • C++\: (1) DESARROLLO\: Escribes .cpp. (2) COMPILACIÓN (separada)\: g++ programa.cpp → programa.exe (código máquina). (3) EJECUCIÓN (separada)\: ./programa.exe (CPU ejecuta directamente). Fases SEPARADAS\: compila una vez, ejecuta muchas veces. • Python\: (1) DESARROLLO\: Escribes .py. (2) COMPILACIÓN+EJECUCIÓN (juntas)\: python programa.py → compila a bytecode (.pyc en memoria/caché) + ejecuta bytecode. Fases FUSIONADAS\: compila + ejecuta cada vez (aunque cachea .pyc). La diferencia es\: C++ = 2 pasos visibles; Python = 1 paso aparente (2 pasos internos pero transparentes). Consulta `EDES-U1.4.-Traductores.md`, secciones '1. Compilación' y '2. Interpretación y lenguajes interpretados'.
~%-33.3333%C++ siempre interpreta el código fuente línea por línea; Python compila a código máquina nativo. #Incorrecto\: TOTALMENTE AL REVÉS\: • C++\: COMPILADO a código máquina nativo (no interpretado). g++ genera binarios que CPU ejecuta directamente. • Python (CPython)\: COMPILADO a bytecode, luego INTERPRETADO por PVM. NO genera código máquina nativo por defecto (aunque PyPy usa JIT). Esta respuesta invierte completamente los modelos de ambos lenguajes. Es el error opuesto a la realidad. Consulta `EDES-U1.4.-Traductores.md`, secciones '1. Compilación' y '2. Interpretación y lenguajes interpretados'.
~%-33.3333%No hay diferencia real; ambos generan bytecode intermedio ejecutado por una máquina virtual. #Incorrecto\: C++ NO genera bytecode\: • C++\: Compila a código MÁQUINA NATIVO (instrucciones x86/ARM). NO hay máquina virtual. El SO carga el ejecutable y la CPU lo ejecuta directamente. • Python\: SÍ genera bytecode (.pyc) ejecutado por PVM (Python Virtual Machine). C++ y Python usan modelos FUNDAMENTALMENTE diferentes\: • C++\: Fuente → Código nativo → Ejecución directa en CPU. • Python\: Fuente → Bytecode → Ejecución en VM. Afirmar "no hay diferencia" es completamente falso. Consulta `EDES-U1.4.-Traductores.md`, secciones '1. Compilación' y '2. Interpretación y lenguajes interpretados'.
~%-33.3333%C++ requiere JIT compilation en runtime; Python compila todo ahead-of-time antes de ejecutar. #Incorrecto\: AL REVÉS (y mal en ambos casos)\: • C++\: Compila AOT (Ahead-Of-Time) a código nativo. NO usa JIT. El ejecutable está listo para ejecutar sin compilación runtime. • Python (CPython)\: Compila JIT-ish a bytecode (en runtime, aunque cachea). NO es AOT (no generas binarios para distribuir). Aunque PyPy SÍ usa JIT para compilar bytecode → nativo. La afirmación invierte los modelos\: C++ es AOT (no JIT); Python es runtime compilation (no AOT tradicional). Consulta `EDES-U1.4.-Traductores.md`, secciones '1. Compilación' y '2. Interpretación y lenguajes interpretados'.
}

::CE 1.4 – Generación de código intermedio (IR)::
En LLVM (compilador moderno), después del análisis semántico se genera LLVM IR. ¿Por qué usar una representación intermedia en lugar de generar código máquina directamente?
{
=IR permite optimizaciones independientes del lenguaje y arquitectura, y facilita soportar múltiples lenguajes y plataformas con menos duplicación de código. #Correcto\: Ventajas de IR (Intermediate Representation)\: (1) INDEPENDENCIA\: • Frontend (Rust, Swift, C++, etc.) → genera misma IR. • Backend (x86, ARM, RISC-V, etc.) → consume misma IR. (2) OPTIMIZACIÓN CENTRALIZADA\: • Optimizaciones (inline, loop unroll, dead code, etc.) se escriben UNA VEZ sobre IR. • Benefician a TODOS los lenguajes y TODAS las plataformas. (3) MODULARIDAD\: • Añadir lenguaje\: 1 frontend nuevo. • Añadir arquitectura\: 1 backend nuevo. (4) REUTILIZACIÓN\: N lenguajes × M arquitecturas con N+M módulos, NO N×M. LLVM IR es el "lenguaje universal" intermedio del compilador. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%IR es más rápida de ejecutar que código máquina porque está optimizada por el compilador. #Incorrecto\: FALSO. IR NO se ejecuta\: • IR es un formato INTERMEDIO usado DENTRO del compilador. • IR NO es ejecutable; es una representación del programa para análisis y optimización. • El proceso es\: Código fuente → IR → Optimizaciones (sobre IR) → Código máquina (ejecutable). • El código máquina generado DESDE IR optimizada es rápido. • La IR en sí NO se ejecuta (a menos que uses un intérprete de IR, que sería lento). IR es para el compilador, no para ejecución. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%IR es el formato de distribución que se envía a los usuarios, quienes lo compilan localmente. #Incorrecto\: GENERALMENTE NO, aunque hay excepciones\: • Distribución típica\: Código fuente (.c/.cpp/.rs) o ejecutables nativos (.exe). • IR (LLVM IR) NO suele distribuirse a usuarios finales. • Excepciones\: (1) WebAssembly (es una IR que navegadores ejecutan, similar conceptualmente). (2) Android apps pueden incluir LLVM IR para compilación en dispositivo. (3) Bitcode de iOS (LLVM IR) para optimización en App Store. Pero en general (desktop, servidor), NO distribuyes IR; distribuyes fuente o binarios. IR es interna al proceso de compilación. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
~%-33.3333%LLVM genera IR para interpretar el programa en una máquina virtual en lugar de compilar. #Incorrecto\: LLVM NO es un intérprete por defecto\: • LLVM es un COMPILADOR\: LLVM IR → código máquina nativo. • Aunque existe "lli" (LLVM interpreter) que PUEDE interpretar LLVM IR, NO es el uso principal. • Uso típico\: clang programa.c → LLVM IR (interno) → optimizaciones → código máquina x86/ARM. • LLVM NO es como la JVM (que ejecuta bytecode en VM). • LLVM genera ejecutables nativos, NO máquina virtual. LLVM IR es una representación intermedia del compilador, no un bytecode para VM. Consulta `EDES-U1.4.-Traductores.md`, sección '1.1. El proceso de compilación'.
}

// EDES-U1.5 - Lenguajes
// Banco de preguntas sobre clasificación y características de lenguajes de programación
// CE 1.e - Lenguajes de programación

::CE 1.e – Elección de lenguaje para sistema embebido::
Debes programar el firmware de un microcontrolador para un dispositivo médico con memoria limitada (32KB RAM). ¿Qué tipo de lenguaje es más apropiado y por qué?
{
=Lenguaje de bajo nivel como C o ensamblador, porque permiten control preciso de memoria, acceso directo a hardware y generan código compacto sin overhead de runtime. #Correcto\: Características de lenguajes de bajo nivel para embebidos\: (1) CONTROL DE MEMORIA\: Gestión manual de memoria (malloc/free), sin garbage collector que consuma RAM impredecible. (2) ACCESO HARDWARE\: Manipulación directa de registros (0x40021000 = valor), puertos, interrupciones. (3) CÓDIGO COMPACTO\: Sin bibliotecas pesadas, sin runtime, ejecutable pequeño. (4) PREDECIBILIDAD\: Timing determinístico (crítico para dispositivos médicos). (5) EFICIENCIA\: Cada byte de RAM y ciclo de CPU cuentan. C domina en embebidos\: 90% del firmware está en C/C++. Ensamblador para partes ultra-críticas. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Python es ideal porque su sintaxis sencilla facilita el desarrollo rápido y reduce errores de programación. #Incorrecto\: Python es INADECUADO para microcontroladores con 32KB RAM\: • Python (CPython) requiere\: Intérprete (~500KB+), bibliotecas estándar, garbage collector, estructuras dinámicas. NO cabe en 32KB. • MicroPython existe para embebidos, pero necesita ~256KB+ de RAM/Flash. Aún así, 32KB es muy limitado. • Python NO permite control fino de hardware (registros, interrupciones, timing preciso). • Para dispositivos médicos (certificación, timing crítico), Python es arriesgado. C/C++ son estándar en embebidos por buenas razones\: eficiencia, control, tamaño. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Java es perfecto porque el bytecode es portable entre diferentes microcontroladores sin recompilar. #Incorrecto\: Java es COMPLETAMENTE INADECUADO para microcontroladores pequeños\: • JVM requiere\: Varios MB de RAM, procesador potente, SO. Imposible en 32KB. • Existe Java ME (Micro Edition) para embebidos, pero necesita >>32KB. • El bytecode NO es portable a microcontroladores sin JVM (y 32KB no permite JVM). • Garbage collector introduce latencias impredecibles (inaceptable en dispositivos médicos). • Sin acceso directo a hardware. Java es para servidores/móviles con recursos. Para embebidos pequeños\: C/ensamblador. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%JavaScript con Node.js es apropiado porque permite programación asíncrona eficiente para manejar sensores. #Incorrecto\: JavaScript/Node.js es TOTALMENTE INAPROPIADO para microcontroladores\: • Node.js requiere\: Motor V8 (JIT compiler), event loop, libuv, bibliotecas → Varios MB de RAM. Imposible en 32KB. • JavaScript NO tiene acceso directo a hardware de microcontrolador (registros, interrupciones). • Garbage collector, tipado dinámico → overhead inaceptable. • La programación asíncrona NO requiere JavaScript; C puede hacer multitarea, interrupciones, RTOS eficientemente. JavaScript es para web/servidor, NO para embebidos con recursos extremadamente limitados. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.2. Según el Nivel de Abstracción' y '3. Características de los Lenguajes de Programación más Comunes'.
}

::CE 1.e – Paradigma para sistema de gestión de biblioteca::
Desarrollas un sistema de biblioteca que gestiona libros, usuarios, préstamos y reservas. ¿Qué paradigma de programación facilita modelar este dominio y por qué?
{
=Paradigma orientado a objetos (OOP), porque permite modelar entidades del mundo real (Libro, Usuario, Préstamo) como clases con atributos y comportamientos encapsulados. #Correcto\: OOP para dominio de biblioteca\: (1) MODELADO NATURAL\: • class Libro\: atributos (título, autor, ISBN), métodos (prestar(), devolver()). • class Usuario\: atributos (nombre, ID), métodos (solicitarPrestamo()). • class Prestamo\: atributos (libro, usuario, fecha), métodos (calcularMulta()). (2) ENCAPSULACIÓN\: Oculta detalles internos, expone interfaz pública. (3) HERENCIA\: UsuarioEstudiante extends Usuario (especialización). (4) POLIMORFISMO\: Diferentes tipos de préstamos con comportamiento específico. (5) REUTILIZACIÓN\: Clases reutilizables, mantenibles. Lenguajes\: Java, C#, Python, C++ son ideales para este tipo de aplicación. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Paradigma funcional puro como Haskell, porque las bibliotecas son sistemas sin estado que solo consultan datos. #Incorrecto\: FALSO. Las bibliotecas SÍ tienen estado mutable\: • Estado\: Libros disponibles/prestados, fechas de préstamo, multas acumuladas. • Operaciones con efectos\: Prestar libro CAMBIA su disponibilidad, devolver MODIFICA estado. • Funcional puro (Haskell)\: Evita mutación, trabaja con transformaciones inmutables. Aunque Haskell PUEDE modelar estado (mónadas, IO), NO es "natural" para este dominio. • OOP es más DIRECTO para modelar entidades con estado mutable (libro prestado ↔ disponible). Funcional puro es mejor para\: procesamiento de datos, transformaciones, cómputo matemático. OOP es mejor para\: modelado de dominios con entidades y estado. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Paradigma lógico como Prolog, porque permite definir reglas de préstamo y el sistema infiere automáticamente las decisiones. #Incorrecto\: Prolog NO es adecuado como paradigma principal aquí\: • Prolog es excelente para\: Inferencia lógica, sistemas expertos, resolución de restricciones, búsqueda. • Biblioteca necesita\: GESTIÓN de estado (CRUD de libros/usuarios), interfaz de usuario, persistencia (base de datos). • Prolog NO es fuerte en\: Interfaces gráficas, acceso a bases de datos relacionales, arquitectura de aplicaciones típicas. • Podrías usar Prolog para un SUBSISTEMA (ej. motor de reglas de préstamo\: "¿puede usuario X prestar libro Y?"). Pero la aplicación completa en Prolog sería complicada. OOP (Java, C#) es más apropiado para la aplicación completa. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Paradigma imperativo con programación estructurada en C, porque es el más eficiente para manejar bases de datos grandes. #Incorrecto\: Aunque C es eficiente, NO es el más ADECUADO para este dominio\: • C es imperativo/procedural\: Funciones + estructuras de datos (struct). Sin clases, herencia, polimorfismo. • Modelar biblioteca en C\: Posible pero ENGORROSO. Necesitas\: structs para Libro/Usuario, arrays/listas enlazadas manuales, gestión manual de memoria. • Eficiencia NO es crítica aquí\: Una biblioteca escolar/universitaria tiene ~10K-100K libros (manejable en cualquier lenguaje moderno). • OOP (Java, C#) ofrece\: Modelado más natural, menos errores, desarrollo más rápido, mantenimiento más fácil. Para aplicaciones de gestión/CRUD, OOP es superior a C procedural (a menos que tengas restricciones extremas de rendimiento). Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
}

::CE 1.e – Clasificación por modo de ejecución::
Un colega pregunta por qué Python se considera "interpretado" si genera archivos .pyc (bytecode). ¿Cómo explicarías la clasificación correcta?
{
=Python compila a bytecode (.pyc) que luego es interpretado por la PVM. Se clasifica como interpretado porque el bytecode no es código nativo y se ejecuta en una máquina virtual. #Correcto\: Clasificación de Python\: (1) PROCESO\: python script.py → Compila a bytecode (.pyc en __pycache__) → PVM interpreta bytecode. (2) BYTECODE NO ES NATIVO\: Instrucciones stack-based para la Python Virtual Machine, NO instrucciones del procesador. (3) INTERPRETADO\: Aunque hay compilación a bytecode (paso intermedio), el bytecode se INTERPRETA (no se ejecuta nativamente). (4) COMPARACIÓN\: • C++\: Compila a código NATIVO → Ejecuta directamente en CPU. COMPILADO. • Java\: Compila a bytecode → JVM interpreta/compila JIT. MÁQUINA VIRTUAL. • Python\: Compila a bytecode → PVM interpreta (sin JIT agresivo en CPython). INTERPRETADO. La clasificación depende del paso FINAL de ejecución. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python es compilado porque genera archivos .pyc, igual que Java genera .class. Ambos son lenguajes compilados. #Incorrecto\: SIMPLIFICACIÓN EXCESIVA. Aunque ambos generan bytecode, la clasificación difiere por detalles\: • Ambos compilan a bytecode (correcto). • Java (JVM)\: Usa JIT agresivo → Compila bytecode a código nativo en runtime → Rendimiento cercano a compilado. Se clasifica como "máquina virtual" o "híbrido". • Python (CPython)\: Interpreta bytecode SIN JIT agresivo (aunque PyPy sí tiene JIT). Se clasifica como "interpretado". • La distinción es sutil y hay debate. Clasificaciones comunes\: • C++\: Compilado (AOT a nativo). • Java\: Máquina virtual / Compilado JIT. • Python\: Interpretado (bytecode interpretado). Python se considera "interpretado" por convención y rendimiento. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python es interpretado puro que lee el archivo .py línea por línea cada vez; los .pyc son solo caché para acelerar. #Incorrecto\: PARCIALMENTE CORRECTO pero IMPRECISO. Python NO interpreta el .py línea por línea\: • Proceso REAL\: (1) Lee .py → Parsea a AST → Compila a bytecode → Cachea .pyc. (2) Ejecuta\: Interpreta BYTECODE (no archivo .py). • Los .pyc NO son "solo caché opcional"; son el FORMATO EJECUTABLE real. La PVM ejecuta bytecode, no código fuente. • Si ya existe .pyc válido, Python NO toca el .py; carga el .pyc directamente. • La interpretación es de BYTECODE, no de código fuente. Python SÍ tiene paso de compilación (fuente→bytecode), aunque transparente. NO es intérprete puro de código fuente (eso sería shell scripts bash leídos línea por línea). Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python debería clasificarse como lenguaje de máquina virtual igual que Java porque ambos usan bytecode. #Incorrecto\: Hay diferencias que justifican clasificaciones distintas\: • SIMILITUD\: Ambos usan bytecode + VM. • DIFERENCIAS CLAVE\: (1) JVM\: JIT agresivo (HotSpot, C2 compiler) → Compila bytecode a código nativo optimizado. (2) CPython\: Interpretación de bytecode SIN JIT (aunque PyPy sí tiene JIT). (3) Rendimiento\: Java (con JIT) → Cercano a C++. Python (CPython) → 10-100x más lento. • Clasificación tradicional\: Java = "Máquina Virtual" (por JIT potente). Python = "Interpretado" (por falta de JIT en implementación estándar). • Técnicamente, AMBOS son "máquina virtual", pero convencionalmente se distinguen por rendimiento/JIT. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
}

::CE 1.e – Lenguaje de alto nivel vs bajo nivel::
Necesitas escribir un driver de dispositivo que manipule registros de hardware. Un compañero sugiere usar Python por su simplicidad. ¿Por qué podría ser problemático?
{
=Python es de alto nivel y abstrae el hardware. No permite acceso directo a direcciones de memoria ni manipulación de registros hardware, necesario para drivers. #Correcto\: Limitaciones de alto nivel para drivers\: (1) ABSTRACCIÓN\: Python esconde detalles de hardware (gestión de memoria automática, sin punteros). (2) SIN ACCESO DIRECTO\: • No puedes hacer "*(volatile uint32_t*)0x40021000 = 0x01;" (escribir en registro). • No hay punteros, no hay acceso a direcciones de memoria arbitrarias. (3) DRIVERS NECESITAN\: Bajo nivel (C/ensamblador) para\: Mapear memoria (mmap), acceder registros, manejar interrupciones, timing preciso. (4) PYTHON PODRÍA\: Usar ctypes/cffi para llamar código C, pero entonces estás escribiendo el driver en C de todas formas. Drivers del kernel Linux\: 99.9% en C, 0.1% ensamblador. Python NO es para drivers. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
~%-33.3333%Python es perfecto para drivers porque su simplicidad reduce errores y el código es más legible. #Incorrecto\: La simplicidad NO compensa la INCAPACIDAD de acceder hardware\: • Python NO puede\: Acceder directamente a registros hardware, manejar interrupciones de bajo nivel, ejecutar con timing determinístico. • Los drivers del kernel se ejecutan en KERNEL SPACE con privilegios máximos. Python (intérprete) ejecuta en USER SPACE. • Aunque "menos errores" es deseable, un driver QUE NO PUEDE ACCEDER AL HARDWARE es inútil. • Para drivers de espacio de usuario (libusb, libftdi), podrías usar Python con wrappers C, pero el trabajo real lo hace código C/C++. La "simplicidad" no supera las limitaciones técnicas fundamentales. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
~%-33.3333%Python puede acceder a hardware usando bibliotecas como GPIO en Raspberry Pi, por lo que es apropiado para drivers. #Incorrecto\: CONFUSIÓN entre scripts de usuario y drivers reales\: • Raspberry Pi GPIO\: Bibliotecas Python (RPi.GPIO, gpiozero) que LLAMAN a código C/drivers del kernel. El trabajo de bajo nivel lo hace C. • Python es la INTERFAZ de usuario, NO el driver real. • Un driver REAL del kernel\: Se carga en kernel space, maneja interrupciones, accede registros. Escrito en C. • Scripts Python GPIO\: User space, llaman a syscalls/APIs del driver C. Para "drivers de usuario" (comunicación con dispositivos USB/I2C/SPI desde espacio de usuario), Python es CONVENIENTE pero NO esencial. El driver real está en C en el kernel. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
~%-33.3333%Python genera código nativo tan eficiente como C cuando se compila con optimizaciones, así que funciona para drivers. #Incorrecto\: TOTALMENTE FALSO. Python (CPython) NO genera código nativo comparable a C\: • CPython\: Compila a bytecode interpretado (mucho más lento que C). • PyPy\: Usa JIT → Más rápido, pero aún no alcanza C optimizado. • Ni CPython ni PyPy generan "código nativo tan eficiente como C". • Incluso si el rendimiento fuera similar, Python NO tiene capacidades de bajo nivel (punteros, acceso memoria, inline assembly) necesarias para drivers. • Herramientas como Cython/Nuitka pueden compilar Python → C, pero entonces estás usando C como paso intermedio. Python puro NO es para drivers de kernel. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.2. Según el Nivel de Abstracción'.
}

::CE 1.e – Multiparadigma (Python)::
Python permite combinar programación imperativa, orientada a objetos y funcional. ¿Qué ventaja ofrece esa flexibilidad según la unidad?
{
=Permite elegir el estilo más adecuado para cada tarea: orientación a objetos para modelar entidades, imperativo para flujos de control y funcional para procesar datos. #Correcto: La unidad destaca que lenguajes como Python permiten aplicar varios paradigmas en un mismo proyecto, dando más herramientas según el problema. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Obliga a escribir el programa completo usando un solo paradigma y limita la creatividad. #Incorrecto: Justo al contrario, el multiparadigma abre opciones en vez de restringirlas. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Hace que el código sea automático más rápido porque mezcla los paradigmas en tiempo de ejecución. #Incorrecto: La velocidad depende de la implementación, no de mezclar paradigmas durante la ejecución. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Demuestra que Python es un lenguaje de bajo nivel pensado para manejar hardware directamente. #Incorrecto: Python es de alto nivel; el multiparadigma no lo convierte en lenguaje de bajo nivel. Consulta `EDES-U1.5.-Lenguajes.md`, secciones '2.3. Según el Paradigma de Programación' y '3. Características de los Lenguajes de Programación más Comunes'.
}

::CE 1.e – Elección de lenguaje para ciencia de datos::
Necesitas procesar datasets de millones de registros, entrenar modelos de machine learning y visualizar resultados. ¿Qué lenguaje es más popular en este dominio y por qué?
{
=Python, porque tiene ecosistema maduro de bibliotecas científicas (NumPy, pandas, scikit-learn, TensorFlow) y sintaxis accesible para científicos sin formación en programación. #Correcto\: Python para ciencia de datos\: (1) BIBLIOTECAS\: • NumPy\: Arrays multidimensionales, operaciones vectorizadas (implementadas en C → rápido). • pandas\: DataFrames, manipulación de datos tabulares. • scikit-learn\: ML clásico (regresión, clasificación, clustering). • TensorFlow/PyTorch\: Deep learning. • Matplotlib/Seaborn\: Visualización. (2) SINTAXIS SIMPLE\: Científicos (estadísticos, biólogos, físicos) pueden aprender rápidamente. (3) JUPYTER NOTEBOOKS\: Entorno interactivo ideal para exploración. (4) COMUNIDAD\: Enorme cantidad de tutoriales, cursos, Stack Overflow. Python domina ciencia de datos (~80% del mercado según encuestas). Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%C++ es mejor porque procesa millones de registros mucho más rápido que cualquier otro lenguaje. #Incorrecto\: C++ es MÁS RÁPIDO pero MENOS APROPIADO para ciencia de datos típica\: • VELOCIDAD\: C++ es más rápido en código puro. • PRODUCTIVIDAD\: Python con NumPy/pandas (que internamente usan C/C++) es CASI TAN RÁPIDO para operaciones vectorizadas, pero MUCHO MÁS RÁPIDO de desarrollar. • ECOSISTEMA\: Python tiene bibliotecas maduras (scikit-learn, TensorFlow). C++ tiene menos opciones (dlib, mlpack, menos documentadas). • CASO DE USO\: C++ se usa para\: Producción de modelos entrenados, sistemas de baja latencia. Python se usa para\: Exploración, entrenamiento, experimentación. La mayoría del tiempo en ciencia de datos es EXPLORACIÓN, donde Python brilla. Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%R es el único lenguaje apropiado porque fue diseñado específicamente para estadística y análisis de datos. #Incorrecto\: R es EXCELENTE pero NO el "único" apropiado\: • R\: Diseñado para estadística, excelentes bibliotecas (ggplot2, dplyr, caret), comunidad académica fuerte. • Python\: Más versátil (web, automatización, scripting, ciencia de datos), bibliotecas potentes (pandas, scikit-learn). • TENDENCIA\: Python ha superado a R en popularidad en ciencia de datos (según Stack Overflow, Kaggle surveys). • ELECCIÓN PRÁCTICA\: (1) R\: Si trabajas principalmente en estadística académica, investigación. (2) Python\: Si quieres combinar ciencia de datos con ingeniería de software, producción. Ambos son válidos; Python es más popular actualmente por versatilidad. Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
~%-33.3333%Java es ideal porque empresas grandes lo usan y tiene mejor rendimiento que Python para procesamiento de datos. #Incorrecto\: Java NO es popular en ciencia de datos aunque tiene ventajas\: • VENTAJAS DE JAVA\: Rendimiento, escalabilidad, integración empresarial (Hadoop, Spark). • DESVENTAJAS PARA CIENCIA DE DATOS\: (1) Verbosidad\: Código más largo que Python/R. (2) Ecosistema limitado\: Pocas bibliotecas de ML comparado con Python (Weka, Deeplearning4j existen pero menos populares). (3) Curva de aprendizaje\: Más difícil para científicos sin background en programación. • USO REAL\: Java se usa en PRODUCCIÓN de sistemas de ML a escala (Spark MLlib), pero EXPLORACIÓN y ENTRENAMIENTO se hace típicamente en Python. Python domina exploración; Java es opción para producción. Consulta `EDES-U1.5.-Lenguajes.md`, sección '3. Características de los Lenguajes de Programación más Comunes'.
}


::CE 1.e – Lenguajes compilados vs interpretados (características)::
Un desarrollador junior pregunta\: "¿Por qué C++ se compila a ejecutables pero Python se distribuye como archivos .py?". ¿Cómo explicarías la diferencia?
{
=C++ es compilado AOT a código nativo específico de plataforma (distribuyes ejecutables). Python es interpretado (compila a bytecode en runtime), distribuyes código fuente que el intérprete ejecuta. #Correcto\: Comparación de distribución\: • C++ COMPILADO AOT\: (1) Desarrollo\: Escribes .cpp. (2) Compilación\: g++ → ejecutable (.exe, .out). (3) Distribución\: Envías ejecutable binario (código máquina). (4) Usuario\: Ejecuta binario directamente (NO necesita compilador). (5) Plataforma-específico\: Windows .exe NO funciona en Linux. • PYTHON INTERPRETADO\: (1) Desarrollo\: Escribes .py. (2) Distribución\: Envías archivos .py (código fuente). (3) Usuario\: Necesita intérprete Python instalado (python script.py). (4) Plataforma-independiente\: Mismo .py funciona en Windows/Linux/macOS (si tienen Python). Trade-off\: C++ = Rendimiento, sin dependencias | Python = Portabilidad, requiere intérprete. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%C++ y Python funcionan igual; ambos generan bytecode que luego se ejecuta en una máquina virtual. #Incorrecto\: FALSO. C++ NO genera bytecode ni usa máquina virtual\: • C++\: Compila a código MÁQUINA NATIVO (instrucciones x86/ARM). Se ejecuta DIRECTAMENTE en el procesador, sin VM. • Python\: Compila a bytecode (instrucciones PVM). Se ejecuta EN la Python Virtual Machine (PVM). • Resultado\: (1) C++\: Rendimiento máximo, específico de plataforma. (2) Python\: Rendimiento menor, portable. La afirmación confunde completamente los modelos de ejecución de ambos lenguajes. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%Python es más seguro distribuir como .py porque el código fuente puede ser auditado; C++ oculta el código en ejecutables. #Incorrecto\: Aunque es cierto que .py es auditable y .exe no, NO es la RAZÓN de la distribución\: • RAZÓN REAL\: Python es INTERPRETADO (necesita código fuente o bytecode para ejecutar). C++ es COMPILADO (genera ejecutables autónomos). • SEGURIDAD/AUDITABILIDAD\: Es un EFECTO SECUNDARIO, no la razón principal. • Para Python, PUEDES distribuir bytecode (.pyc, .pyo) o empaquetado (PyInstaller, .pyz), ocultando código fuente. • Para C++, PUEDES distribuir código fuente (open source). • La diferencia NO es filosófica (auditoría); es TÉCNICA (interpretado vs compilado). El modelo de ejecución determina qué distribuyes. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
~%-33.3333%C++ genera ejecutables porque es más antiguo. Lenguajes modernos como Python usan código fuente porque es mejor. #Incorrecto\: La edad NO determina el modelo de ejecución\: • Lenguajes ANTIGUOS compilados\: Fortran (1957), C (1972), C++ (1985). • Lenguajes ANTIGUOS interpretados\: Lisp (1958), BASIC (1964). • Lenguajes MODERNOS compilados\: Rust (2010), Go (2009). • Lenguajes MODERNOS interpretados\: JavaScript (1995), Python (1991). • La elección es DISEÑO, no edad\: (1) Compilado\: Rendimiento, distribución de binarios. (2) Interpretado\: Portabilidad, desarrollo rápido. Ambos coexisten porque tienen DIFERENTES TRADE-OFFS para diferentes casos de uso, no porque uno sea "mejor" o "más moderno". Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.1. Según el Modo de Ejecución'.
}

::CE 1.e – Paradigma funcional (ventajas)::
Necesitas procesar un stream de datos donde cada elemento se transforma, filtra y agrega. Un colega sugiere usar programación funcional. ¿Qué ventaja ofrece?
{
=Permite encadenar transformaciones inmutables (map, filter, reduce) de forma declarativa, facilitando razonamiento sobre el código y paralelización sin efectos secundarios. #Correcto\: Programación funcional para procesamiento de datos\: (1) COMPOSICIÓN\: data.map(x => x*2).filter(x => x>10).reduce((a,b) => a+b, 0) (declarativo, legible). (2) INMUTABILIDAD\: Cada operación retorna NUEVA colección sin modificar original → Sin efectos secundarios. (3) RAZONAMIENTO\: Más fácil entender qué hace el código (cada función es pura\: misma entrada → misma salida). (4) PARALELIZACIÓN\: Sin estado compartido → Puede ejecutarse en paralelo (map/reduce distribuido\: Hadoop, Spark). (5) TESTABILIDAD\: Funciones puras son fáciles de testear (sin setup complejo). Para procesamiento de datos, streams, transformaciones\: funcional es excelente. Python, JavaScript, Scala, Kotlin soportan estilo funcional. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%La programación funcional es más rápida porque evita usar memoria para variables mutables. #Incorrecto\: FALSO. Funcional NO es necesariamente más rápido\: • INMUTABILIDAD\: Cada transformación crea NUEVA colección → PUEDE usar MÁS memoria que mutación in-place. • Ejemplo\: (1) Imperativo\: for(i=0;i<n;i++) arr[i] *= 2; (modifica array existente). (2) Funcional\: newArr = arr.map(x => x*2); (crea nuevo array). Funcional usa MÁS memoria (2 arrays temporalmente). • OPTIMIZACIÓN\: Compiladores modernos pueden optimizar código funcional (fusion, eliminación de estructuras intermedias), pero NO es automáticamente más rápido. • Ventaja NO es velocidad; es CLARIDAD, PARALELIZACIÓN, MENOS BUGS. Para rendimiento puro, código imperativo optimizado puede ser más rápido. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Solo Haskell soporta programación funcional. Lenguajes como JavaScript y Python no pueden hacer transformaciones funcionales. #Incorrecto\: TOTALMENTE FALSO. Muchos lenguajes multiparadigma soportan funcional\: • JavaScript\: array.map(), filter(), reduce(), arrow functions, first-class functions. • Python\: lambda, map(), filter(), reduce(), list comprehensions, functools. • Kotlin\: map, filter, fold, lambdas, immutable collections. • Scala\: Fuertemente funcional, híbrido con OOP. • Java (moderno)\: Streams API (stream().map().filter().reduce()). • Haskell\: Funcional PURO (obliga inmutabilidad). Otros permiten estilo funcional pero no lo obligan. La programación funcional es un ESTILO que muchos lenguajes soportan, NO exclusivo de Haskell. Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
~%-33.3333%Programación funcional significa usar funciones en lugar de clases, por lo que es lo opuesto a orientación a objetos. #Incorrecto\: SIMPLIFICACIÓN INCORRECTA. Funcional NO es solo "usar funciones"\: • CARACTERÍSTICAS FUNCIONAL\: (1) Funciones como ciudadanos de primera clase (pasar funciones como argumentos). (2) Inmutabilidad (no modificar estado). (3) Funciones puras (sin efectos secundarios). (4) Composición de funciones. • NO es "opuesto" a OOP\: (1) PUEDES combinar ambos (Scala, Kotlin\: OOP + Funcional). (2) Ejemplo\: class Collection { map(fn) {...} filter(fn) {...} } → Métodos funcionales en clase OOP. • JavaScript, Python, Kotlin\: Multiparadigma (OOP + Funcional). No son opuestos; son complementarios. Funcional es sobre INMUTABILIDAD y FUNCIONES PURAS, no solo "usar funciones". Consulta `EDES-U1.5.-Lenguajes.md`, sección '2.3. Según el Paradigma de Programación'.
}

::CE 1.e – Tendencias TIOBE (interpretación)::
Según el índice TIOBE de 2024, Python, C, Java y C++ están en el top 5. ¿Qué indica esto sobre las preferencias de la industria?
{
=Coexisten lenguajes compilados (C, C++, Java con JIT) e interpretados (Python), mostrando que la elección depende del dominio\: sistemas (C/C++), empresas (Java), ciencia de datos (Python). #Correcto\: Interpretación de TIOBE top 5\: (1) DIVERSIDAD\: NO hay "un lenguaje ganador"; diferentes dominios usan diferentes lenguajes. (2) DOMINIOS\: • Python\: Ciencia de datos, ML, automatización, scripting, educación. • C\: Sistemas embebidos, kernels, drivers, programación de bajo nivel. • Java\: Desarrollo empresarial, Android, backend a gran escala. • C++\: Videojuegos, motores gráficos, sistemas de alto rendimiento. (3) TENDENCIA\: Python ha crecido enormemente (boom de ML/Data Science). C/C++ se mantienen (sistemas críticos). Java estable (empresas grandes). (4) CONCLUSIÓN\: El "mejor lenguaje" depende del contexto. La industria usa MÚLTIPLES lenguajes especializados. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Python está desplazando a todos los demás lenguajes y pronto será el único usado en la industria. #Incorrecto\: EXAGERADO. Python crece pero NO desplazará a todos\: • Python es EXCELENTE para\: Scripting, ciencia de datos, ML, automatización, web (Django/Flask). • Python es INADECUADO para\: (1) Sistemas embebidos (demasiado pesado). (2) Kernels de SO (necesita bajo nivel). (3) Videojuegos AAA (rendimiento crítico). (4) Drivers de dispositivos (acceso hardware). • C/C++ SEGUIRÁN siendo esenciales para\: Sistemas operativos, firmware, motores de juegos, compiladores. • REALIDAD\: Especialización. Python domina ciencia de datos; C domina sistemas; Java domina empresas. NO habrá "un lenguaje único"; cada dominio tiene necesidades diferentes. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%TIOBE muestra que lenguajes compilados (C, C++, Java) son más populares porque son más rápidos. #Incorrecto\: INTERPRETACIÓN INCORRECTA. El top 5 incluye INTERPRETADO (Python)\: • Top 5 (2024)\: Python (#1), C (#2), C++ (#3), Java (#4), C# (#5) (orden aproximado varía). • Python (INTERPRETADO) está #1, superando a C/C++ compilados. • RAZÓN de popularidad NO es solo velocidad\: (1) Python\: Popular por FACILIDAD, ECOSISTEMA (bibliotecas ML), COMUNIDAD. (2) C/C++\: Populares por RENDIMIENTO, CONTROL, LEGACY (código existente). (3) Java\: Popular por ECOSISTEMA EMPRESARIAL, PORTABILIDAD (JVM). La popularidad depende de\: Ecosistema, comunidad, casos de uso, facilidad de aprendizaje, NO solo velocidad. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%TIOBE solo mide búsquedas en Google, no uso real, por lo que no refleja la industria real. #Incorrecto\: PARCIALMENTE CIERTO pero sigue siendo INDICADOR útil\: • METODOLOGÍA TIOBE\: Cuenta búsquedas en ~25 motores (Google, Bing, Yahoo, Wikipedia, YouTube, etc.) con queries específicas ("+ programming"). • LIMITACIÓN\: Mide INTERÉS/BÚSQUEDAS, no LÍNEAS DE CÓDIGO escritas en producción. • SESGO\: Lenguajes problemáticos o difíciles pueden tener más búsquedas (no necesariamente más uso). • ALTERNATIVAS\: Stack Overflow Survey, GitHub Octoverse, RedMonk (miden código real, preguntas, repos). • UTILIDAD\: TIOBE es UN INDICADOR entre varios. Correlaciona razonablemente con uso real (Python alto en TIOBE Y en Stack Overflow Y en GitHub). Aunque imperfecto, sigue siendo útil para ver TENDENCIAS (Python subiendo, Perl bajando). Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
}

::CE 1.e – Evolución de lenguajes (Kotlin vs Java)::
Kotlin es un lenguaje moderno que compila a bytecode JVM, compatible con Java. ¿Por qué crear un nuevo lenguaje en lugar de evolucionar Java?
{
=Kotlin introduce features modernos (null-safety, coroutines, sintaxis concisa) sin romper compatibilidad con código Java existente, permitiendo adopción gradual en proyectos legacy. #Correcto\: Razones para Kotlin\: (1) LIMITACIONES JAVA\: Verbosidad, sin null-safety nativo, checked exceptions problemáticas, sintaxis antigua. (2) FEATURES KOTLIN\: • Null-safety\: val x\: String = null → Error compilación. En Java\: NullPointerException en runtime. • Concisión\: data class User(val name\: String) vs Java\: 20+ líneas (getters, setters, equals, hashCode). • Coroutines\: Concurrencia simplificada vs Java threads/callbacks. • Funciones de extensión, lambdas mejoradas, smart casts. (3) COMPATIBILIDAD\: Kotlin y Java coexisten en el MISMO proyecto (ambos → bytecode JVM). Puedes migrar gradualmente. (4) ANDROID\: Google adoptó Kotlin como lenguaje preferido (2019). Kotlin es "Java mejorado" sin romper el ecosistema. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Kotlin es más rápido en ejecución que Java porque es un lenguaje moderno con mejor compilador. #Incorrecto\: FALSO. Kotlin y Java tienen rendimiento SIMILAR\: • Ambos compilan a bytecode JVM. • Ambos se ejecutan en la MISMA JVM (HotSpot, OpenJ9, etc.). • El bytecode generado es muy similar (a veces idéntico para código equivalente). • Algunas features de Kotlin (inline functions, reified generics) PUEDEN ser más eficientes. • Algunas features (lambdas, DSLs) PUEDEN tener overhead mínimo. • EN GENERAL\: Rendimiento es ~99% similar. Diferencia es PRODUCTIVIDAD y SEGURIDAD (null-safety, less boilerplate), NO velocidad. Benchmarks muestran diferencias <5% entre Kotlin y Java equivalente. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Kotlin reemplazará completamente a Java en pocos años porque Java es obsoleto y en desuso. #Incorrecto\: EXAGERADO. Java NO desaparecerá pronto\: • BASE DE CÓDIGO\: Billones de líneas de código Java existente en empresas (legacy). • EVOLUCIÓN JAVA\: Java sigue evolucionando (Java 17 LTS, Java 21 LTS\: records, pattern matching, virtual threads). • ADOPCIÓN KOTLIN\: Crece (especialmente Android), pero Java sigue dominando\: (1) Empresas grandes (bancos, seguros) con código Java legacy. (2) Frameworks (Spring, Hibernate) siguen siendo Java-first (aunque soportan Kotlin). • COEXISTENCIA\: Kotlin y Java coexisten bien (puedes mezclar en el mismo proyecto). Kotlin es una ALTERNATIVA, no un REEMPLAZO completo. Java seguirá siendo relevante durante décadas por código legacy y adopción empresarial. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
~%-33.3333%Kotlin usa un runtime diferente a Java, por lo que no son realmente compatibles en la práctica. #Incorrecto\: FALSO. Kotlin usa el MISMO runtime que Java (JVM)\: • Kotlin compila a bytecode JVM (mismo que Java). • Ejecuta en la MISMA JVM (OpenJDK, Oracle JDK, etc.). • Kotlin stdlib (biblioteca estándar) es una JAR adicional (pequeña, ~1.5MB). • INTEROPERABILIDAD\: (1) Código Java puede llamar código Kotlin sin modificaciones. (2) Código Kotlin puede usar bibliotecas Java directamente. (3) Puedes mezclar .java y .kt en el mismo proyecto/módulo. • La compatibilidad es EXCELENTE (es uno de los diseños clave de Kotlin). NO hay "runtime diferente"; comparten la JVM. Kotlin añade su stdlib, pero NO reemplaza la JVM. Consulta `EDES-U1.5.-Lenguajes.md`, sección '5. Tendencia en lenguajes de programación'.
}

// EDES-U1.6 - FuncionalidadesHerramientas
// Banco de preguntas sobre herramientas de desarrollo de software
// CE 1.f - Funcionalidades de herramientas usadas en desarrollo

::CE 1.f – Compilador GCC en proyecto C++::
Estás desarrollando un proyecto en C++ y necesitas compilar múltiples archivos .cpp a ejecutable. ¿Qué herramienta usas y qué comando básico ejecutarías?
{
=GCC (GNU Compiler Collection). Comando\: g++ archivo1.cpp archivo2.cpp -o programa para compilar y enlazar en un solo paso, generando el ejecutable 'programa'. #Correcto\: Uso de GCC/g++ para C++\: (1) HERRAMIENTA\: g++ (parte de GCC, específica para C++). (2) PROCESO\: • Compilación simple\: g++ main.cpp -o programa (genera ejecutable). • Compilación separada\: g++ -c main.cpp → main.o; g++ -c util.cpp → util.o; g++ main.o util.o -o programa. (3) FLAGS ÚTILES\: -Wall (warnings), -O2 (optimización), -g (debug info), -std=c++17 (estándar). (4) ALTERNATIVAS\: Clang (clang++), MSVC (cl.exe en Windows). GCC es el compilador C/C++ más usado en Linux/Unix, open source, potente y con excelente optimización. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
~%-33.3333%Usar Python interpreter (python) porque puede ejecutar código C++ directamente sin compilar. #Incorrecto\: TOTALMENTE FALSO. Python NO ejecuta C++ directamente\: • Python es un INTÉRPRETE para código PYTHON (.py), NO C++ (.cpp). • C++ es un lenguaje COMPILADO que requiere compilador (g++, clang++, MSVC). • NO puedes hacer "python programa.cpp". Dará error de sintaxis (Python y C++ son lenguajes diferentes). • Para usar C++ desde Python\: Necesitas (1) Compilar C++ a biblioteca (.so/.dll) con g++. (2) Usar ctypes/cffi/pybind11 para llamar desde Python. Pero el C++ DEBE compilarse primero. Python no compila ni ejecuta C++ directamente. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
~%-33.3333%javac es el compilador apropiado porque puede compilar tanto Java como C++ a bytecode. #Incorrecto\: CONFUSIÓN DE LENGUAJES. javac NO compila C++\: • javac\: Compilador de JAVA (.java → .class bytecode). Solo para Java. • g++/clang++\: Compiladores de C++ (.cpp → ejecutable nativo). Solo para C/C++. • Son lenguajes DIFERENTES con compiladores DIFERENTES\: (1) Java → javac → bytecode .class. (2) C++ → g++ → ejecutable nativo .exe/.out. • javac NO entiende sintaxis C++ (clases, templates, punteros). Si intentas "javac archivo.cpp" → error. Necesitas g++ o clang++ para C++, NO javac. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
~%-33.3333%Node.js (node) porque puede compilar y ejecutar código C++ moderno en servidores. #Incorrecto\: Node.js NO compila C++. Node.js es un RUNTIME para JAVASCRIPT\: • Node.js\: Ejecuta JavaScript del lado servidor (motor V8). • NO compila C++. Si intentas "node programa.cpp" → error (espera .js). • RELACIÓN con C++\: (1) Node.js está ESCRITO en C++ (el motor V8). (2) Puedes escribir ADDONS de Node.js en C++ (usando node-gyp para compilar .cpp → .node). Pero eso requiere COMPILAR el C++ con g++/clang++ primero. • Para C++, necesitas g++/clang++, NO Node.js. Node.js ejecuta JS, no compila C++. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
}

::CE 1.f – Intérprete Python en desarrollo::
Estás escribiendo un script de automatización en Python. ¿Cómo ejecutas el script y qué ventaja tiene este flujo de trabajo?
{
=Ejecutas con 'python script.py'. Ventaja\: No necesitas compilar explícitamente; el intérprete compila a bytecode y ejecuta en un solo paso, permitiendo iteraciones rápidas. #Correcto\: Flujo de trabajo con Python\: (1) DESARROLLO\: Escribes script.py en editor. (2) EJECUCIÓN\: python script.py (o python3 script.py en sistemas con ambas versiones). (3) PROCESO INTERNO\: • Python compila script.py → bytecode (en memoria o __pycache__/script.pyc). • Ejecuta bytecode en PVM. (4) VENTAJA\: Ciclo rápido edit-run (sin paso de compilación visible). Ideal para\: scripting, automatización, prototipado rápido. (5) COMPARACIÓN CON C++\: • C++\: Editar → Compilar (esperar) → Ejecutar. • Python\: Editar → Ejecutar (compilación transparente). Para scripts/automatización, Python es mucho más ágil. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
~%-33.3333%Debes compilar explícitamente con 'gcc script.py' antes de poder ejecutar el script. #Incorrecto\: FALSO. Python NO se compila con gcc\: • gcc\: Compilador de C/C++, NO Python. • Python\: Lenguaje interpretado. NO necesitas compilar explícitamente. • Si intentas "gcc script.py" → error (gcc espera código C/C++, no Python). • Proceso correcto\: python script.py (el intérprete hace compilación interna a bytecode automáticamente). • NOTA\: Existen herramientas para compilar Python a ejecutables (PyInstaller, Nuitka, Cython), pero NO es el flujo estándar. El uso típico es interpretación directa con python comando. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
~%-33.3333%Primero generas bytecode con 'pyc script.py', luego ejecutas con 'python script.pyc'. #Incorrecto\: NO existe comando "pyc" para compilar. El proceso es AUTOMÁTICO\: • Python compila a bytecode (.pyc) AUTOMÁTICAMENTE cuando ejecutas "python script.py". • Los .pyc se guardan en __pycache__/ como caché (para acelerar ejecuciones futuras). • NO necesitas compilar manualmente. • Aunque PUEDES compilar manualmente con py_compile module (python -m py_compile script.py), NO es el flujo normal. • Ejecución\: Siempre es "python script.py" (usa .pyc si existe y está actualizado, sino recompila). • Puedes ejecutar "python script.pyc" pero es innecesario (ejecutas script.py y Python usa .pyc automáticamente). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
~%-33.3333%Ejecutas con 'javac script.py' porque Python usa la JVM para ejecutar scripts. #Incorrecto\: CONFUSIÓN TOTAL. Python NO usa JVM\: • javac\: Compilador de JAVA → bytecode JVM. NO compila Python. • Python\: Usa PVM (Python Virtual Machine), NO JVM (Java Virtual Machine). • Son VMs DIFERENTES\: (1) JVM\: Ejecuta bytecode Java (.class). (2) PVM\: Ejecuta bytecode Python (.pyc). • Jython existe (implementación de Python en Java que usa JVM), pero NO es estándar. CPython (implementación estándar) usa PVM. • Comando correcto\: python script.py, NO javac. Python y Java son lenguajes y ecosistemas completamente separados. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
}

::CE 1.f – Depurador GDB para C::
Tu programa en C crashea con "Segmentation fault". ¿Qué herramienta usas para encontrar la línea exacta del error?
{
=GDB (GNU Debugger). Compilas con -g (gcc -g programa.c -o programa), ejecutas en GDB (gdb ./programa), corres (run), y cuando crashea GDB muestra la línea exacta del fallo. #Correcto\: Uso de GDB\: (1) COMPILACIÓN CON DEBUG INFO\: gcc -g programa.c -o programa (-g incluye símbolos de depuración). (2) INICIAR GDB\: gdb ./programa. (3) COMANDOS BÁSICOS\: • run\: Ejecuta el programa. • backtrace (bt)\: Muestra stack trace (dónde crasheó). • list\: Muestra código fuente alrededor del crash. • print variable\: Inspecciona valores de variables. • break linea\: Breakpoint en línea específica. • step/next\: Ejecución paso a paso. (4) EJEMPLO\: Programa crashea → bt muestra "Segfault at programa.c\:42" → Investigas línea 42. GDB es LA herramienta de depuración para C/C++ en Linux/Unix. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%printf debugging es mejor\: añades printf por todo el código hasta encontrar dónde falla. #Incorrecto\: Printf debugging FUNCIONA pero es INEFICIENTE comparado con GDB\: • Printf debugging\: (1) Añades printf("checkpoint 1\\n"); por todo el código. (2) Recompilas. (3) Ejecutas. (4) Ves hasta dónde llega. (5) Repites (añadir más prints, recompilar). LENTO. • GDB\: (1) Ejecutas en GDB una vez. (2) Cuando crashea, ves INMEDIATAMENTE línea exacta, stack trace, valores de variables. SIN recompilar. • VENTAJAS GDB\: Breakpoints, inspección de memoria, stack traces, modificación de variables en runtime. • Printf es útil para debug rápido, pero GDB es MUCHO más potente para crashes, bugs complejos, análisis profundo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%SonarQube encuentra automáticamente todos los bugs y te dice exactamente dónde está el segfault. #Incorrecto\: SonarQube es ANÁLISIS ESTÁTICO, NO debugger dinámico\: • SonarQube\: Analiza código FUENTE en busca de code smells, vulnerabilidades potenciales, malas prácticas. NO ejecuta el programa. • LIMITACIÓN\: Análisis estático NO puede detectar todos los segfaults (especialmente los que dependen de input runtime, punteros dinámicos, race conditions). • Para SEGFAULT REAL (que ocurre en ejecución)\: Necesitas DEBUGGER como GDB que ejecuta el programa y captura el crash. • SonarQube es complementario\: Puede detectar NULL dereferences potenciales, buffer overflows, etc. en código. Pero para investigar un crash REAL, GDB es necesario. Son herramientas diferentes\: SonarQube = prevención; GDB = diagnóstico. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%No existe herramienta para esto. Debes revisar el código manualmente línea por línea hasta encontrar el error. #Incorrecto\: ABSOLUTAMENTE FALSO. Los debuggers existen desde los años 70\: • GDB (GNU Debugger)\: Debugger estándar para C/C++ en Linux/Unix. • LLDB\: Debugger moderno (parte de LLVM), alternativa a GDB. • Visual Studio Debugger\: Debugger gráfico para Windows. • Valgrind\: Detecta memory leaks, invalid accesses. • AddressSanitizer (ASan)\: Detecta memory errors en compilación. • Revisar código "línea por línea manualmente" sería IMPOSIBLE en programas de miles/millones de líneas. Los debuggers son herramientas ESENCIALES que todo programador C/C++ debe conocer. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
}

::CE 1.f – Control de versiones con Git::
Tu equipo de 5 desarrolladores trabaja en el mismo proyecto. Necesitan colaborar sin sobrescribir cambios de otros. ¿Qué herramienta y workflow usan?
{
=Git como sistema de control de versiones. Workflow\: Cada uno trabaja en su rama (branch), hace commits locales, pushea a repositorio remoto (GitHub/GitLab), y hace merge/pull requests para integrar cambios. #Correcto\: Uso de Git en equipo\: (1) SETUP\: Repositorio central en GitHub/GitLab/Bitbucket. (2) CLONE\: Cada dev hace git clone del repo. (3) BRANCHES\: git checkout -b feature-login (cada feature en rama separada). (4) DESARROLLO\: Editar código → git add → git commit -m "mensaje". (5) PUSH\: git push origin feature-login (subir al remoto). (6) PULL REQUEST\: Crear PR en GitHub para code review. (7) MERGE\: Tras aprobación, merge a main/master. (8) PULL\: Otros devs hacen git pull para obtener cambios. Git permite\: Trabajo paralelo, historial completo, rollback, branching, merging. Estándar de la industria. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
~%-33.3333%Cada desarrollador trabaja en una copia del proyecto en Dropbox/Google Drive y sincronizan archivos automáticamente. #Incorrecto\: Dropbox/Drive NO son apropiados para código colaborativo\: • PROBLEMAS\: (1) Conflictos de sincronización (dos personas editan mismo archivo → versiones conflictivas). (2) Sin historial estructurado (difícil ver quién cambió qué y cuándo). (3) Sin merge inteligente (Git fusiona cambios; Dropbox crea copias conflictivas). (4) Sin branches (no puedes trabajar en features separadas y fusionar después). (5) Sincronización automática puede romper código (alguien sube código roto → todos lo obtienen inmediatamente). • Git ofrece\: Commits atómicos, branches, merge inteligente, code review, rollback. NUNCA uses Dropbox/Drive para código en equipo; usa Git. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
~%-33.3333%Usan FTP para subir archivos al servidor central. Cada uno espera su turno para evitar conflictos. #Incorrecto\: FTP es PRIMITIVO y PELIGROSO para desarrollo colaborativo\: • PROBLEMAS FTP\: (1) Sin control de versiones (si sobrescribes archivo, versión anterior se pierde). (2) Sin historial (no sabes qué cambió ni quién lo cambió). (3) "Esperar turno" es INEFICIENTE (solo 1 persona trabaja a la vez en un archivo). (4) Sin merge (si dos personas cambian el mismo archivo, el segundo sobrescribe al primero). (5) Sin rollback (si alguien rompe algo, difícil volver atrás). • Git permite\: Trabajo PARALELO (cada uno en su rama), merge automático de cambios no conflictivos, historial completo. FTP era usado en los 90s; Git es el estándar moderno. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
~%-33.3333%No necesitan herramientas. Comparten código por email y cada uno integra manualmente los cambios de otros. #Incorrecto\: Email es el PEOR método posible para colaboración de código\: • PROBLEMAS\: (1) Caos total (emails con archivos adjuntos desactualizados). (2) Integración manual propensa a errores (copiar-pegar código de emails). (3) Sin historial estructurado (buscar en emails viejos para ver cambios). (4) Conflictos imposibles de resolver (dos personas cambian lo mismo → ¿cómo fusionas?). (5) Escalabilidad nula (con 5 devs ya es caos; con 50 es imposible). • Proyectos open source con MILES de colaboradores usan Git exitosamente. • Email para código es de los años 80. Git es el estándar desde 2005. NO uses email para código en equipo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
}

::CE 1.f – Framework Django para web::
Necesitas desarrollar rápidamente una aplicación web con autenticación de usuarios, panel de administración y base de datos. ¿Qué tipo de herramienta acelera este desarrollo?
{
=Un framework web como Django (Python) que proporciona\: ORM para base de datos, sistema de autenticación integrado, panel admin automático, routing, templates, reduciendo código boilerplate. #Correcto\: Django como framework web completo\: (1) FEATURES INCLUIDAS\: • ORM (Object-Relational Mapping)\: Define modelos en Python, Django genera SQL automáticamente. • Autenticación\: Sistema de usuarios, login, permisos, sesiones (incluido). • Admin panel\: Interfaz CRUD automática para modelos (generada automáticamente). • Routing\: URLs → vistas. • Templates\: Sistema de plantillas HTML. • Seguridad\: CSRF protection, SQL injection prevention. (2) VENTAJA\: No escribes desde cero; usas componentes probados. (3) ALTERNATIVAS\: Flask (Python, más minimalista), Express (Node.js), Spring (Java), Laravel (PHP), ASP.NET (C#). Los frameworks aceleran desarrollo 5-10x vs escribir todo desde cero. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%Debes programar todo desde cero en C porque es el único lenguaje que soporta desarrollo web. #Incorrecto\: TOTALMENTE FALSO. C NO es apropiado ni común para desarrollo web\: • C es de bajo nivel\: Necesitarías escribir TODO manualmente\: parsing HTTP, manejo de sockets, templates, SQL, sesiones. EXTREMADAMENTE laborioso. • Lenguajes/frameworks web comunes\: Python (Django, Flask), JavaScript (Express, React), Java (Spring), PHP (Laravel), Ruby (Rails), C# (ASP.NET). • C se usa para\: Servidores web de alto rendimiento (nginx, Apache están en C), pero NO aplicaciones web típicas. • Para aplicación web con CRUD, autenticación, admin\: Django/Flask (Python) o similar es 100x más rápido de desarrollar que C. C es inadecuado para este caso de uso. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%GCC es el framework apropiado porque puede compilar código web a ejecutables eficientes. #Incorrecto\: CONFUSIÓN TOTAL. GCC NO es un framework web\: • GCC\: COMPILADOR de C/C++. NO es framework. • Framework web\: Biblioteca/conjunto de herramientas para desarrollo web (routing, templates, DB, etc.). • GCC NO tiene features web\: NO maneja HTTP, templates, bases de datos, autenticación. • Aunque PUDIERAS escribir aplicación web en C y compilarla con GCC, NO tendrías framework (tendrías que escribir todo manualmente). • Para web, necesitas framework como Django, NOT compilador. GCC es herramienta de bajo nivel para C/C++, totalmente diferente a framework web. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%Git es el framework ideal porque versiona automáticamente la base de datos y el código. #Incorrecto\: Git NO es un framework web; es control de VERSIONES\: • Git\: Versiona CÓDIGO fuente (archivos .py, .js, .html, etc.). SÍ es esencial para desarrollo. • Git NO es framework web\: NO proporciona routing, templates, ORM, autenticación. • Bases de datos\: Git NO versiona bases de datos directamente. Versionas MIGRACIONES (archivos que definen cambios de esquema), NO datos. • Para desarrollo web necesitas\: (1) Framework web (Django) para funcionalidad. (2) Git para versionar código. Son complementarios, NO alternativos. Git versiona el código; Django proporciona features web. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
}

::CE 1.f – Documentación con Javadoc::
Estás escribiendo una biblioteca Java que otros desarrolladores usarán. Necesitas generar documentación HTML de las clases y métodos públicos. ¿Qué herramienta usas?
{
=Javadoc. Escribes comentarios especiales /** ... */ en el código con tags @param, @return, @throws. Ejecutas javadoc para generar HTML automáticamente con la API documentada. #Correcto\: Uso de Javadoc\: (1) COMENTARIOS EN CÓDIGO\: ```java /** * Calcula el factorial de un número. * @param n El número (debe ser >= 0) * @return El factorial de n * @throws IllegalArgumentException si n < 0 */ public int factorial(int n) {...} ``` (2) GENERACIÓN\: javadoc -d docs src/*.java (genera HTML en directorio docs/). (3) RESULTADO\: Sitio web navegable con todas las clases, métodos, parámetros documentados. (4) VENTAJA\: Documentación SINCRONIZADA con código (está en el mismo archivo). (5) ESTÁNDAR\: Toda la API estándar de Java está documentada con Javadoc. Similar\: Doxygen (C++), JSDoc (JavaScript), Sphinx (Python). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
~%-33.3333%Git genera automáticamente documentación HTML basándose en los commits del proyecto. #Incorrecto\: Git NO genera documentación de API\: • Git\: Control de versiones (historial de cambios, commits, branches). NO documenta API. • Los commits describen QUÉ cambió, NO documentan cómo USAR la API. • Documentación de API necesita\: Descripción de clases, métodos, parámetros, valores de retorno, ejemplos. • Javadoc lee COMENTARIOS del código fuente y genera docs. Git lee HISTORIAL de commits (propósito diferente). • Para documentación de API\: Javadoc, Doxygen, JSDoc. Para historial de cambios\: Git log, CHANGELOG generado de commits. Son herramientas diferentes con propósitos diferentes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
~%-33.3333%SonarQube es la herramienta estándar para generar documentación HTML de proyectos Java. #Incorrecto\: SonarQube NO genera documentación de API\: • SonarQube\: Análisis de CALIDAD de código (bugs, code smells, vulnerabilidades, cobertura de tests). • SonarQube genera\: Reportes de calidad, métricas, problemas encontrados. NO documentación de API. • Para documentación de API pública\: Javadoc (genera docs de cómo USAR el código). • Para análisis de calidad\: SonarQube (genera reportes de CALIDAD del código). • Son complementarias\: Javadoc para usuarios de tu biblioteca; SonarQube para mantenedores (evaluar calidad interna). Javadoc documenta QUÉ hace el código; SonarQube evalúa QUÉ TAN BIEN está escrito. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
~%-33.3333%JUnit genera automáticamente documentación basándose en los tests unitarios del proyecto. #Incorrecto\: JUnit NO genera documentación de API\: • JUnit\: Framework de TESTING (escribir y ejecutar tests unitarios). NO genera docs. • Tests unitarios\: Verifican que el código FUNCIONE correctamente. NO documentan la API pública. • Aunque tests PUEDEN servir como "documentación por ejemplo" (ver cómo se usa el código), NO generan HTML navegable. • Para documentación HTML de API\: Javadoc (lee comentarios /** */ y genera HTML). • Para tests\: JUnit (ejecuta tests, reporta pass/fail). Son propósitos diferentes\: Javadoc documenta; JUnit verifica. Ambos son importantes pero no intercambiables. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
}

::CE 1.f – Análisis de calidad con SonarQube::
Tu proyecto Java tiene 50,000 líneas de código. El líder técnico quiere un reporte de code smells, duplicación de código, cobertura de tests y vulnerabilidades. ¿Qué herramienta usas?
{
=SonarQube. Configuras el proyecto, ejecutas análisis (mvn sonar\:sonar o similar), y SonarQube genera dashboard web con métricas de calidad\: bugs, code smells, duplicación, cobertura, vulnerabilidades. #Correcto\: Uso de SonarQube\: (1) SETUP\: SonarQube server (local o cloud), proyecto configurado. (2) ANÁLISIS\: mvn sonar\:sonar (Maven) o gradle sonar (Gradle) → Analiza código y sube resultados. (3) DASHBOARD\: Web UI muestra\: • Bugs\: Errores probables. • Code smells\: Código que funciona pero es mejorable (complejidad, duplicación). • Vulnerabilidades\: Problemas de seguridad (SQL injection, XSS, etc.). • Cobertura\: % de código cubierto por tests. • Duplicación\: Bloques de código repetidos. (4) VENTAJA\: Visión centralizada de calidad, tracking de deuda técnica. SonarQube es estándar en empresas para análisis estático continuo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%GDB puede analizar el código fuente y generar reportes de calidad automáticamente. #Incorrecto\: GDB es DEBUGGER, NO analizador de calidad\: • GDB\: Depura programas EN EJECUCIÓN (breakpoints, inspección de variables, stack traces). • GDB NO analiza calidad de código (no detecta code smells, duplicación, vulnerabilidades). • Para calidad de código\: Análisis ESTÁTICO (sin ejecutar)\: SonarQube, ESLint, Pylint, Clang-Tidy. • Para debugging\: Análisis DINÁMICO (ejecutando)\: GDB, LLDB, Visual Studio Debugger. • Son herramientas complementarias pero DIFERENTES\: GDB encuentra bugs en ejecución; SonarQube encuentra problemas potenciales en código fuente sin ejecutar. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Maven es la herramienta apropiada porque puede detectar todos los code smells durante la compilación. #Incorrecto\: Maven es BUILD TOOL, NO analizador de calidad\: • Maven\: Gestiona dependencias, compila, ejecuta tests, empaqueta (JAR/WAR). • Maven NO analiza calidad de código por sí mismo (puede compilar código con code smells sin quejarse). • Maven INTEGRA con SonarQube\: Usas plugin maven-sonar-plugin para ejecutar análisis, pero el ANÁLISIS lo hace SonarQube. • Comando\: mvn sonar\:sonar → Maven llama a SonarQube, pero SonarQube hace el análisis. • Para calidad\: SonarQube (o CheckStyle, PMD, SpotBugs integrados en Maven). Maven es el orquestador; SonarQube es el analizador. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Git puede generar métricas de calidad basándose en el historial de commits y cambios. #Incorrecto\: Git NO analiza calidad de código\: • Git\: Control de versiones (commits, branches, diffs). NO analiza calidad. • Git puede generar MÉTRICAS DE PROCESO\: Quién commitea más, frecuencia de cambios, áreas de código que cambian frecuentemente. • Git NO detecta\: Code smells, bugs, vulnerabilidades, duplicación (requiere análisis del CONTENIDO del código, no solo cambios). • Para análisis de calidad\: SonarQube (analiza AST, flujo de control, patrones). • Para métricas de proceso\: Git stats (git log --stat, herramientas como GitStats). Son complementarias\: Git track. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.

a cambios; SonarQube evalúa calidad.
}

::CE 1.f – Pruebas de carga con JMeter::
Necesitas verificar que tu API REST soporta 1000 usuarios concurrentes sin degradación de rendimiento. ¿Qué tipo de herramienta usas y qué mide?
{
=Herramienta de pruebas de carga/rendimiento como JMeter. Simula 1000 usuarios concurrentes haciendo requests HTTP y mide\: throughput (requests/seg), latencia (tiempo de respuesta), tasa de error. #Correcto\: Pruebas de carga con JMeter\: (1) SETUP\: Creas plan de pruebas en JMeter con\: • Thread Group\: 1000 threads (usuarios virtuales). • HTTP Request\: GET/POST a tu API. • Assertions\: Verificar respuestas correctas. (2) EJECUCIÓN\: JMeter lanza 1000 threads concurrentes haciendo requests. (3) MÉTRICAS\: • Throughput\: Requests/segundo procesados. • Latencia promedio/p95/p99\: Tiempo de respuesta. • Error rate\: % de requests fallidos. • Gráficos de rendimiento en el tiempo. (4) RESULTADO\: Identificas\: Cuellos de botella, capacidad máxima, puntos de fallo. (5) ALTERNATIVAS\: Gatling, Locust, k6, Artillery. Las pruebas de carga son CRÍTICAS antes de lanzar a producción. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%JUnit es apropiado porque puede ejecutar 1000 tests unitarios simultáneamente simulando usuarios. #Incorrecto\: JUnit es para TESTS UNITARIOS, NO pruebas de carga\: • JUnit\: Verifica lógica de CÓDIGO (métodos individuales, clases). Tests rápidos (<ms), ejecutados en local. • Pruebas de carga\: Verifican SISTEMA completo bajo CARGA real (HTTP, DB, red). Tests lentos (minutos), contra servidor real. • JUnit NO puede\: (1) Simular usuarios HTTP concurrentes (no es cliente HTTP). (2) Medir throughput, latencia de API. (3) Generar carga sostenida por minutos/horas. • Aunque JUnit PUEDE ejecutar tests en paralelo, NO es para pruebas de carga de APIs. • Para tests unitarios\: JUnit. Para pruebas de carga\: JMeter/Gatling. Son tipos de testing completamente diferentes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Git puede simular commits concurrentes de 1000 usuarios para probar el sistema bajo carga. #Incorrecto\: Git NO es herramienta de pruebas de carga\: • Git\: Control de versiones. NO tiene capacidades de simular carga HTTP. • "Commits concurrentes" NO es lo mismo que "usuarios API concurrentes"\: (1) Commits\: Operaciones de VCS (local, no relacionado con API REST). (2) Usuarios API\: HTTP requests a servidor web. • Para probar API REST\: Necesitas herramienta que haga HTTP requests (JMeter, curl en loop, etc.). • Git NO hace HTTP requests a tu API; gestiona código fuente. Confusión total de propósitos. Para carga de API\: JMeter. Git no tiene relación con pruebas de rendimiento de APIs. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%SonarQube puede ejecutar análisis estático que simula 1000 usuarios y mide el rendimiento del código. #Incorrecto\: SonarQube es ANÁLISIS ESTÁTICO, NO pruebas de carga\: • SonarQube\: Analiza código FUENTE sin EJECUTAR (detecta bugs, code smells, vulnerabilidades). • SonarQube NO ejecuta la aplicación; analiza el código estáticamente. • Pruebas de carga\: EJECUTAN la aplicación con carga real (requests HTTP). • SonarQube NO puede\: (1) Hacer HTTP requests. (2) Simular usuarios concurrentes. (3) Medir throughput/latencia de API. • Para análisis de calidad de código\: SonarQube. Para pruebas de carga\: JMeter. Son herramientas totalmente diferentes con propósitos no relacionados. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
}

::CE 1.f – Linter ESLint para JavaScript::
Tu equipo JavaScript tiene problemas con código inconsistente\: algunos usan comillas simples, otros dobles; espacios vs tabs; etc. ¿Qué tipo de herramienta ayuda a mantener estilo consistente?
{
=Un linter como ESLint. Configuras reglas de estilo (.eslintrc), ejecutas eslint en el código, y reporta violaciones\: comillas incorrectas, indentación inconsistente, variables no usadas, etc. #Correcto\: Uso de ESLint\: (1) INSTALACIÓN\: npm install eslint --save-dev. (2) CONFIGURACIÓN\: .eslintrc.json con reglas\: { "rules"\: { "quotes"\: ["error", "single"], "indent"\: ["error", 2] } }. (3) EJECUCIÓN\: eslint src/**/*.js → Lista errores de estilo. (4) AUTOFIX\: eslint --fix → Corrige automáticamente muchos problemas (comillas, indentación). (5) INTEGRACIÓN\: CI/CD falla si hay errores de lint (obliga estilo consistente). (6) VENTAJA\: Código consistente, legible, menos bugs (detecta variables no usadas, comparaciones incorrectas). Linters son esenciales para proyectos en equipo. Similares\: Pylint (Python), RuboCop (Ruby), Clippy (Rust). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%GCC puede analizar JavaScript y reportar problemas de estilo durante la compilación. #Incorrecto\: GCC NO analiza JavaScript\: • GCC\: Compilador de C/C++/Fortran. NO entiende JavaScript. • JavaScript NO se compila con GCC; se ejecuta en navegadores (V8, SpiderMonkey) o Node.js. • Si intentas "gcc archivo.js" → error (GCC espera C/C++). • Para JavaScript\: (1) Linter\: ESLint (análisis estático de estilo/bugs). (2) Runtime\: Node.js, navegadores (ejecución). • GCC no tiene relación con JavaScript. Es confusión total de lenguajes y herramientas. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%JMeter es la herramienta apropiada para verificar consistencia de estilo en código JavaScript. #Incorrecto\: JMeter es para PRUEBAS DE CARGA, NO análisis de código\: • JMeter\: Simula usuarios HTTP, mide rendimiento de APIs/sitios web. • JMeter NO analiza código fuente (no lee archivos .js, no verifica estilo). • JMeter NO sabe nada de sintaxis JavaScript, comillas, indentación. • Para análisis de estilo JavaScript\: ESLint (linter). • Para pruebas de carga\: JMeter. • Son herramientas para propósitos completamente diferentes. JMeter no tiene capacidades de análisis de código. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Git puede detectar automáticamente inconsistencias de estilo en los commits y rechazarlos. #Incorrecto\: Git NO analiza estilo de código por sí mismo\: • Git\: Control de versiones (commits, diffs, branches). NO analiza contenido del código. • Git NO sabe qué son "comillas correctas" o "indentación consistente". • PUEDES integrar ESLint con Git hooks\: (1) Pre-commit hook ejecuta eslint. (2) Si hay errores, el commit se rechaza. Pero el ANÁLISIS lo hace ESLint, NO Git. • Git es el orquestador; ESLint es el analizador. • Para forzar estilo\: ESLint + Git hooks (Husky). Git solo versiona; no analiza estilo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
}

::CE 1.f – Build automation con Maven::
Tienes un proyecto Java con 20 dependencias externas (bibliotecas). Manualmente descargarlas y configurar el classpath es tedioso. ¿Qué herramienta automatiza esto?
{
=Maven. Defines dependencias en pom.xml, Maven las descarga automáticamente de repositorios centrales, gestiona versiones y conflictos, y configura el classpath para compilación y ejecución. #Correcto\: Uso de Maven\: (1) ARCHIVO pom.xml\: ```xml <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>5.3.20</version> </dependency> </dependencies> ``` (2) COMANDO\: mvn compile → Maven\: • Descarga spring-core JAR + sus dependencias transitivas. • Guarda en repositorio local (~/.m2/repository). • Configura classpath automáticamente. (3) BENEFICIOS\: • No descargas JARs manualmente. • Gestión de versiones centralizada. • Resolución de conflictos de dependencias. • Build reproducible (mismo pom.xml → mismo resultado). (4) ALTERNATIVAS\: Gradle (más moderno), Ant+Ivy (antiguo). Maven es estándar en proyectos Java empresariales. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Git es la herramienta apropiada porque puede descargar y versionar todas las bibliotecas del proyecto. #Incorrecto\: Git NO gestiona dependencias de bibliotecas\: • Git\: Versiona CÓDIGO FUENTE del proyecto. NO descarga dependencias externas. • Mal enfoque\: Commitear JARs de bibliotecas al repo Git (repo gigante, difícil actualizar versiones). • Buen enfoque\: Git versiona pom.xml (define dependencias); Maven descarga JARs (NO commiteados a Git). • Git + Maven\: (1) Git versiona código fuente + pom.xml. (2) Maven descarga bibliotecas según pom.xml. (3) .gitignore ignora carpetas de bibliotecas (target/, .m2/). • Para versionado de código\: Git. Para gestión de dependencias\: Maven. Son complementarios, no intercambiables. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%JUnit puede descargar automáticamente todas las bibliotecas necesarias durante la ejecución de tests. #Incorrecto\: JUnit NO gestiona dependencias\: • JUnit\: Framework de TESTING (escribir y ejecutar tests unitarios). • JUnit NO descarga bibliotecas; ASUME que las bibliotecas ya están en el classpath. • Si faltan dependencias → JUnit falla con ClassNotFoundException. • Para TENER las dependencias\: Maven/Gradle descargan bibliotecas. • Para USAR las dependencias en tests\: JUnit ejecuta tests (asumiendo dependencias disponibles). • Maven gestiona dependencias (incluido JUnit mismo); JUnit las usa. JUnit es una dependencia MÁS que Maven gestiona, no un gestor de dependencias. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Javadoc puede generar documentación que incluye automáticamente todas las bibliotecas externas necesarias. #Incorrecto\: Javadoc NO gestiona dependencias\: • Javadoc\: Genera DOCUMENTACIÓN de API (HTML de clases/métodos). • Javadoc NO descarga ni gestiona bibliotecas externas. • Para generar docs de bibliotecas externas\: Javadoc necesita que las bibliotecas YA estén en el classpath (Maven las descarga). • Javadoc DOCUMENTA código que Maven compiló con dependencias que Maven descargó. • Para dependencias\: Maven. Para documentación\: Javadoc. Secuencia\: (1) Maven descarga deps. (2) Maven compila con deps. (3) Javadoc genera docs del código compilado. Javadoc no gestiona dependencias. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
}

::CE 1.f – Depurador Python PDB::
Tu script Python falla con un KeyError en un diccionario. Quieres pausar la ejecución justo antes del error para inspeccionar el diccionario. ¿Qué herramienta usas?
{
=PDB (Python Debugger). Añades 'import pdb; pdb.set_trace()' antes de la línea problemática, ejecutas el script, y PDB pausa permitiendo inspeccionar variables con 'p nombre_variable'. #Correcto\: Uso de PDB\: (1) CÓDIGO\: ```python import pdb data = {"key1"\: "value"} pdb.set_trace() # Breakpoint value = data["key2"] # KeyError ``` (2) EJECUCIÓN\: python script.py → Se pausa en set_trace(). (3) COMANDOS PDB\: • p data → Muestra contenido del diccionario. • p data.keys() → Muestra claves disponibles. • n (next)\: Siguiente línea. • c (continue)\: Continuar hasta próximo breakpoint. • q (quit)\: Salir. (4) Python 3.7+\: breakpoint() (equivalente a pdb.set_trace()). (5) ALTERNATIVAS\: ipdb (PDB mejorado), debuggers de IDEs (PyCharm, VSCode). PDB es built-in, no requiere instalación. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%GDB puede depurar scripts Python directamente sin necesidad de herramientas adicionales. #Incorrecto\: GDB es para C/C++, NO ideal para Python\: • GDB PUEDE depurar el INTÉRPRETE Python (CPython escrito en C), pero es muy bajo nivel. • Con GDB verías\: Punteros C, estructuras internas de CPython, código assembly. NO variables Python directamente. • Para Python\: PDB (alto nivel, variables Python). Para C/C++\: GDB (bajo nivel, variables C). • Existe python-gdb (extensión GDB para Python), pero PDB es mucho más simple para debugging Python típico. • GDB se usa para\: (1) Debugging de extensiones C de Python. (2) Crashes del intérprete Python. Para scripts Python normales\: PDB es apropiado. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%SonarQube puede ejecutar el script y pausarlo automáticamente cuando detecta el KeyError. #Incorrecto\: SonarQube es ANÁLISIS ESTÁTICO, NO debugger dinámico\: • SonarQube\: Analiza código FUENTE sin EJECUTAR. Detecta code smells, bugs potenciales. • SonarQube NO ejecuta el programa; analiza estáticamente. • KeyError es error de RUNTIME (depende de datos en ejecución). SonarQube NO puede predecir todos los KeyErrors (depende de qué datos tenga el diccionario en runtime). • Para DETECTAR bugs antes de ejecutar\: SonarQube (análisis estático). • Para DEPURAR bugs en ejecución\: PDB, debuggers (análisis dinámico). • Son complementarios\: SonarQube previene algunos bugs; PDB diagnostica bugs que ocurren en runtime. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%pip (gestor de paquetes Python) puede instalar un depurador que resuelve automáticamente KeyErrors. #Incorrecto\: pip NO depura; INSTALA paquetes\: • pip\: Gestor de paquetes (pip install numpy, pip install ipdb). • pip NO depura código; instala herramientas que pueden depurar. • Para depurar\: (1) pip install ipdb (instala depurador mejorado). (2) Usas ipdb en código (import ipdb; ipdb.set_trace()). (3) ipdb te permite inspeccionar variables. • No hay "depurador que resuelve automáticamente KeyErrors". Los debuggers AYUDAN a investigar errores; NO los resuelven automáticamente. • pip es instalador; PDB/ipdb son debuggers. pip instala herramientas; no las ejecuta. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
}

::CE 1.f – Frameworks vs bibliotecas::
Un junior pregunta\: "¿Cuál es la diferencia entre usar la biblioteca 'requests' (HTTP client) y el framework 'Django' (web framework) en Python?". ¿Cómo lo explicas?
{
=Biblioteca (requests)\: TÚ llamas a sus funciones cuando necesitas (requests.get(url)). Framework (Django)\: Define la ESTRUCTURA de tu app; TÚ implementas partes específicas (views, models) y el framework llama tu código. #Correcto\: Biblioteca vs Framework\: • BIBLIOTECA (requests)\: (1) TÚ tienes control de flujo. (2) Llamas funciones de biblioteca cuando necesitas\: response = requests.get(url). (3) Biblioteca es herramienta que usas. (4) Ejemplo\: NumPy, pandas, requests. • FRAMEWORK (Django)\: (1) FRAMEWORK tiene control de flujo (Inversion of Control). (2) TÚ defines\: class MyView(View)\: def get(self, request)\: ... (3) FRAMEWORK llama tu código cuando recibe HTTP request. (4) Framework define estructura; tú rellenas huecos. (5) Ejemplo\: Django, Flask, Spring, React. Analogía\: Biblioteca = herramienta que usas; Framework = casa con estructura, tú decoras interior. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%No hay diferencia; tanto bibliotecas como frameworks son lo mismo, solo términos diferentes. #Incorrecto\: HAY diferencia fundamental (Inversión de Control)\: • BIBLIOTECA\: (1) TÚ escribes main(). (2) TÚ llamas biblioteca\: import requests; requests.get(...). (3) Control de flujo está en TU código. • FRAMEWORK\: (1) FRAMEWORK ejecuta tu código. (2) TÚ implementas\: def my_view(request)\: return response. (3) FRAMEWORK llama my_view() cuando llega request HTTP. (4) Control de flujo está en el FRAMEWORK. • Inversión de Control (IoC)\: En framework, el framework LLAMA tu código (no al revés). • En biblioteca, TÚ llamas la biblioteca. • Esta diferencia es fundamental en arquitectura de software. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%Django es una biblioteca más grande que requests; la diferencia es solo de tamaño. #Incorrecto\: La diferencia NO es tamaño; es ARQUITECTURA\: • Tamaño\: Django es más grande (sí), pero NO es eso lo que lo hace framework. • DIFERENCIA CLAVE\: (1) requests\: Biblioteca. TÚ llamas\: requests.get(url) cuando quieres. (2) Django\: Framework. Define estructura (URLs → views → templates). TÚ implementas views; Django las ejecuta. • Podrías tener biblioteca grande (TensorFlow) y framework pequeño (Flask). • Lo que define framework es Inversión de Control, NO tamaño. • Arquitecturalmente\: Biblioteca = componente; Framework = contenedor de tu aplicación. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%requests es para backend; Django es para frontend. Esa es la única diferencia. #Incorrecto\: FALSO. Ambos son para backend\: • requests\: Biblioteca para hacer HTTP requests (CLIENTE HTTP). Usado en backend para llamar APIs externas. • Django\: Framework para crear aplicaciones web (SERVIDOR HTTP). Backend que responde a requests. • AMBOS son backend/servidor. • Frontend sería\: HTML/CSS/JavaScript en navegador (React, Vue, Angular). • Diferencia NO es backend vs frontend; es biblioteca (herramienta específica) vs framework (estructura completa). • Analogía correcta\: requests = martillo (herramienta); Django = casa con planos (framework). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
}

::CE 1.f – Herramientas de refactoring::
Tu proyecto creció de 1,000 a 50,000 líneas. Necesitas renombrar una clase usada en 200 archivos. Hacerlo manualmente es propenso a errores. ¿Qué facilita esto?
{
=IDEs con refactoring automático (IntelliJ IDEA, Eclipse, VSCode) o herramientas de refactoring. Seleccionas la clase, eliges "Rename", el IDE encuentra todos los usos y renombra consistentemente. #Correcto\: Refactoring automático en IDEs\: (1) PROCESO\: • Seleccionas clase a renombrar. • IDE analiza sintaxis, referencias, imports. • Muestra preview de cambios (200 archivos afectados). • Confirmas; IDE renombra en todos los archivos + actualiza imports. (2) SEGURIDAD\: IDE entiende sintaxis (no renombra strings que contengan el nombre, solo código real). (3) OPERACIONES\: Rename, Extract Method, Change Signature, Move Class, etc. (4) VENTAJAS\: • Rápido (segundos vs horas manualmente). • Seguro (no rompe código). • Consistente (no olvidas archivos). (5) HERRAMIENTAS\: IntelliJ (Java/Kotlin), PyCharm (Python), VSCode (múltiples lenguajes). El refactoring automático es CRÍTICO en proyectos grandes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Usar find-and-replace global en editor de texto es suficiente y más rápido que usar IDE. #Incorrecto\: Find-and-replace es PELIGROSO para refactoring\: • PROBLEMAS\: (1) Reemplaza TODO (incluso strings, comentarios, logs\: "Error en clase User" → "Error en clase Cliente"). (2) No actualiza imports automáticamente. (3) No verifica sintaxis (puede generar código roto). (4) Puede renombrar cosas no relacionadas (clase User vs variable user → ambas se renombran). • IDE REFACTORING\: (1) Entiende SINTAXIS (solo renombra declaración + referencias). (2) Actualiza imports/package. (3) Preview de cambios. (4) Rollback si algo falla. • Find-and-replace es OK para cambios simples en pocos archivos. Para refactoring serio\: IDE con refactoring semántico. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Git puede renombrar automáticamente la clase en todos los commits y archivos del historial. #Incorrecto\: Git NO hace refactoring de código\: • Git\: Control de versiones. Rastrea cambios en ARCHIVOS, no contenido de código. • git mv puede renombrar ARCHIVOS (user.py → cliente.py), pero NO renombra clase DENTRO del archivo. • Para renombrar clase User → Cliente DENTRO de 200 archivos\: Necesitas IDE con refactoring o scripts de análisis sintáctico. • Git es para VERSIONADO después del refactoring\: (1) IDE refactoriza código (renombra clase). (2) Git commitea los cambios (git add -A && git commit). • Git no entiende sintaxis de lenguajes; solo rastrea cambios de texto. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%SonarQube tiene funcionalidad de refactoring automático que puede renombrar clases en todo el proyecto. #Incorrecto\: SonarQube NO refactoriza código\: • SonarQube\: ANALIZA calidad (detecta code smells, bugs, vulnerabilidades). NO MODIFICA código. • SonarQube es READ-ONLY\: Lee código, genera reportes. NO escribe código. • Para refactoring\: IDE (IntelliJ, Eclipse, VSCode) que MODIFICA código. • Workflow típico\: (1) SonarQube reporta "clase tiene nombre no descriptivo". (2) TÚ decides renombrar. (3) IDE refactoriza (renombra). (4) Commiteas cambios. • SonarQube identifica problemas; IDE los arregla. Roles diferentes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
}
