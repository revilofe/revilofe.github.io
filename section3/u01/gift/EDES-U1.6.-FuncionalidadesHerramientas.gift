// EDES-U1.6 - FuncionalidadesHerramientas
// Banco de preguntas sobre herramientas de desarrollo de software
// CE 1.f - Funcionalidades de herramientas usadas en desarrollo

::CE 1.f – Compilador GCC en proyecto C++::
Estás desarrollando un proyecto en C++ y necesitas compilar múltiples archivos .cpp a ejecutable. ¿Qué herramienta usas y qué comando básico ejecutarías?
{
=GCC (GNU Compiler Collection). Comando\: g++ archivo1.cpp archivo2.cpp -o programa para compilar y enlazar en un solo paso, generando el ejecutable 'programa'. #Correcto\: Uso de GCC/g++ para C++\: (1) HERRAMIENTA\: g++ (parte de GCC, específica para C++). (2) PROCESO\: • Compilación simple\: g++ main.cpp -o programa (genera ejecutable). • Compilación separada\: g++ -c main.cpp → main.o; g++ -c util.cpp → util.o; g++ main.o util.o -o programa. (3) FLAGS ÚTILES\: -Wall (warnings), -O2 (optimización), -g (debug info), -std=c++17 (estándar). (4) ALTERNATIVAS\: Clang (clang++), MSVC (cl.exe en Windows). GCC es el compilador C/C++ más usado en Linux/Unix, open source, potente y con excelente optimización. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
~%-33.3333%Usar Python interpreter (python) porque puede ejecutar código C++ directamente sin compilar. #Incorrecto\: TOTALMENTE FALSO. Python NO ejecuta C++ directamente\: • Python es un INTÉRPRETE para código PYTHON (.py), NO C++ (.cpp). • C++ es un lenguaje COMPILADO que requiere compilador (g++, clang++, MSVC). • NO puedes hacer "python programa.cpp". Dará error de sintaxis (Python y C++ son lenguajes diferentes). • Para usar C++ desde Python\: Necesitas (1) Compilar C++ a biblioteca (.so/.dll) con g++. (2) Usar ctypes/cffi/pybind11 para llamar desde Python. Pero el C++ DEBE compilarse primero. Python no compila ni ejecuta C++ directamente. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
~%-33.3333%javac es el compilador apropiado porque puede compilar tanto Java como C++ a bytecode. #Incorrecto\: CONFUSIÓN DE LENGUAJES. javac NO compila C++\: • javac\: Compilador de JAVA (.java → .class bytecode). Solo para Java. • g++/clang++\: Compiladores de C++ (.cpp → ejecutable nativo). Solo para C/C++. • Son lenguajes DIFERENTES con compiladores DIFERENTES\: (1) Java → javac → bytecode .class. (2) C++ → g++ → ejecutable nativo .exe/.out. • javac NO entiende sintaxis C++ (clases, templates, punteros). Si intentas "javac archivo.cpp" → error. Necesitas g++ o clang++ para C++, NO javac. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
~%-33.3333%Node.js (node) porque puede compilar y ejecutar código C++ moderno en servidores. #Incorrecto\: Node.js NO compila C++. Node.js es un RUNTIME para JAVASCRIPT\: • Node.js\: Ejecuta JavaScript del lado servidor (motor V8). • NO compila C++. Si intentas "node programa.cpp" → error (espera .js). • RELACIÓN con C++\: (1) Node.js está ESCRITO en C++ (el motor V8). (2) Puedes escribir ADDONS de Node.js en C++ (usando node-gyp para compilar .cpp → .node). Pero eso requiere COMPILAR el C++ con g++/clang++ primero. • Para C++, necesitas g++/clang++, NO Node.js. Node.js ejecuta JS, no compila C++. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.2. Compiladores: Traducción del Código Fuente a Código Máquina'.
}

::CE 1.f – Intérprete Python en desarrollo::
Estás escribiendo un script de automatización en Python. ¿Cómo ejecutas el script y qué ventaja tiene este flujo de trabajo?
{
=Ejecutas con 'python script.py'. Ventaja\: No necesitas compilar explícitamente; el intérprete compila a bytecode y ejecuta en un solo paso, permitiendo iteraciones rápidas. #Correcto\: Flujo de trabajo con Python\: (1) DESARROLLO\: Escribes script.py en editor. (2) EJECUCIÓN\: python script.py (o python3 script.py en sistemas con ambas versiones). (3) PROCESO INTERNO\: • Python compila script.py → bytecode (en memoria o __pycache__/script.pyc). • Ejecuta bytecode en PVM. (4) VENTAJA\: Ciclo rápido edit-run (sin paso de compilación visible). Ideal para\: scripting, automatización, prototipado rápido. (5) COMPARACIÓN CON C++\: • C++\: Editar → Compilar (esperar) → Ejecutar. • Python\: Editar → Ejecutar (compilación transparente). Para scripts/automatización, Python es mucho más ágil. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
~%-33.3333%Debes compilar explícitamente con 'gcc script.py' antes de poder ejecutar el script. #Incorrecto\: FALSO. Python NO se compila con gcc\: • gcc\: Compilador de C/C++, NO Python. • Python\: Lenguaje interpretado. NO necesitas compilar explícitamente. • Si intentas "gcc script.py" → error (gcc espera código C/C++, no Python). • Proceso correcto\: python script.py (el intérprete hace compilación interna a bytecode automáticamente). • NOTA\: Existen herramientas para compilar Python a ejecutables (PyInstaller, Nuitka, Cython), pero NO es el flujo estándar. El uso típico es interpretación directa con python comando. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
~%-33.3333%Primero generas bytecode con 'pyc script.py', luego ejecutas con 'python script.pyc'. #Incorrecto\: NO existe comando "pyc" para compilar. El proceso es AUTOMÁTICO\: • Python compila a bytecode (.pyc) AUTOMÁTICAMENTE cuando ejecutas "python script.py". • Los .pyc se guardan en __pycache__/ como caché (para acelerar ejecuciones futuras). • NO necesitas compilar manualmente. • Aunque PUEDES compilar manualmente con py_compile module (python -m py_compile script.py), NO es el flujo normal. • Ejecución\: Siempre es "python script.py" (usa .pyc si existe y está actualizado, sino recompila). • Puedes ejecutar "python script.pyc" pero es innecesario (ejecutas script.py y Python usa .pyc automáticamente). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
~%-33.3333%Ejecutas con 'javac script.py' porque Python usa la JVM para ejecutar scripts. #Incorrecto\: CONFUSIÓN TOTAL. Python NO usa JVM\: • javac\: Compilador de JAVA → bytecode JVM. NO compila Python. • Python\: Usa PVM (Python Virtual Machine), NO JVM (Java Virtual Machine). • Son VMs DIFERENTES\: (1) JVM\: Ejecuta bytecode Java (.class). (2) PVM\: Ejecuta bytecode Python (.pyc). • Jython existe (implementación de Python en Java que usa JVM), pero NO es estándar. CPython (implementación estándar) usa PVM. • Comando correcto\: python script.py, NO javac. Python y Java son lenguajes y ecosistemas completamente separados. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.3. Intérpretes: Ejecución Directa del Código Fuente'.
}

::CE 1.f – Depurador GDB para C::
Tu programa en C crashea con "Segmentation fault". ¿Qué herramienta usas para encontrar la línea exacta del error?
{
=GDB (GNU Debugger). Compilas con -g (gcc -g programa.c -o programa), ejecutas en GDB (gdb ./programa), corres (run), y cuando crashea GDB muestra la línea exacta del fallo. #Correcto\: Uso de GDB\: (1) COMPILACIÓN CON DEBUG INFO\: gcc -g programa.c -o programa (-g incluye símbolos de depuración). (2) INICIAR GDB\: gdb ./programa. (3) COMANDOS BÁSICOS\: • run\: Ejecuta el programa. • backtrace (bt)\: Muestra stack trace (dónde crasheó). • list\: Muestra código fuente alrededor del crash. • print variable\: Inspecciona valores de variables. • break linea\: Breakpoint en línea específica. • step/next\: Ejecución paso a paso. (4) EJEMPLO\: Programa crashea → bt muestra "Segfault at programa.c\:42" → Investigas línea 42. GDB es LA herramienta de depuración para C/C++ en Linux/Unix. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%printf debugging es mejor\: añades printf por todo el código hasta encontrar dónde falla. #Incorrecto\: Printf debugging FUNCIONA pero es INEFICIENTE comparado con GDB\: • Printf debugging\: (1) Añades printf("checkpoint 1\\n"); por todo el código. (2) Recompilas. (3) Ejecutas. (4) Ves hasta dónde llega. (5) Repites (añadir más prints, recompilar). LENTO. • GDB\: (1) Ejecutas en GDB una vez. (2) Cuando crashea, ves INMEDIATAMENTE línea exacta, stack trace, valores de variables. SIN recompilar. • VENTAJAS GDB\: Breakpoints, inspección de memoria, stack traces, modificación de variables en runtime. • Printf es útil para debug rápido, pero GDB es MUCHO más potente para crashes, bugs complejos, análisis profundo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%SonarQube encuentra automáticamente todos los bugs y te dice exactamente dónde está el segfault. #Incorrecto\: SonarQube es ANÁLISIS ESTÁTICO, NO debugger dinámico\: • SonarQube\: Analiza código FUENTE en busca de code smells, vulnerabilidades potenciales, malas prácticas. NO ejecuta el programa. • LIMITACIÓN\: Análisis estático NO puede detectar todos los segfaults (especialmente los que dependen de input runtime, punteros dinámicos, race conditions). • Para SEGFAULT REAL (que ocurre en ejecución)\: Necesitas DEBUGGER como GDB que ejecuta el programa y captura el crash. • SonarQube es complementario\: Puede detectar NULL dereferences potenciales, buffer overflows, etc. en código. Pero para investigar un crash REAL, GDB es necesario. Son herramientas diferentes\: SonarQube = prevención; GDB = diagnóstico. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%No existe herramienta para esto. Debes revisar el código manualmente línea por línea hasta encontrar el error. #Incorrecto\: ABSOLUTAMENTE FALSO. Los debuggers existen desde los años 70\: • GDB (GNU Debugger)\: Debugger estándar para C/C++ en Linux/Unix. • LLDB\: Debugger moderno (parte de LLVM), alternativa a GDB. • Visual Studio Debugger\: Debugger gráfico para Windows. • Valgrind\: Detecta memory leaks, invalid accesses. • AddressSanitizer (ASan)\: Detecta memory errors en compilación. • Revisar código "línea por línea manualmente" sería IMPOSIBLE en programas de miles/millones de líneas. Los debuggers son herramientas ESENCIALES que todo programador C/C++ debe conocer. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
}

::CE 1.f – Control de versiones con Git::
Tu equipo de 5 desarrolladores trabaja en el mismo proyecto. Necesitan colaborar sin sobrescribir cambios de otros. ¿Qué herramienta y workflow usan?
{
=Git como sistema de control de versiones. Workflow\: Cada uno trabaja en su rama (branch), hace commits locales, pushea a repositorio remoto (GitHub/GitLab), y hace merge/pull requests para integrar cambios. #Correcto\: Uso de Git en equipo\: (1) SETUP\: Repositorio central en GitHub/GitLab/Bitbucket. (2) CLONE\: Cada dev hace git clone del repo. (3) BRANCHES\: git checkout -b feature-login (cada feature en rama separada). (4) DESARROLLO\: Editar código → git add → git commit -m "mensaje". (5) PUSH\: git push origin feature-login (subir al remoto). (6) PULL REQUEST\: Crear PR en GitHub para code review. (7) MERGE\: Tras aprobación, merge a main/master. (8) PULL\: Otros devs hacen git pull para obtener cambios. Git permite\: Trabajo paralelo, historial completo, rollback, branching, merging. Estándar de la industria. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
~%-33.3333%Cada desarrollador trabaja en una copia del proyecto en Dropbox/Google Drive y sincronizan archivos automáticamente. #Incorrecto\: Dropbox/Drive NO son apropiados para código colaborativo\: • PROBLEMAS\: (1) Conflictos de sincronización (dos personas editan mismo archivo → versiones conflictivas). (2) Sin historial estructurado (difícil ver quién cambió qué y cuándo). (3) Sin merge inteligente (Git fusiona cambios; Dropbox crea copias conflictivas). (4) Sin branches (no puedes trabajar en features separadas y fusionar después). (5) Sincronización automática puede romper código (alguien sube código roto → todos lo obtienen inmediatamente). • Git ofrece\: Commits atómicos, branches, merge inteligente, code review, rollback. NUNCA uses Dropbox/Drive para código en equipo; usa Git. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
~%-33.3333%Usan FTP para subir archivos al servidor central. Cada uno espera su turno para evitar conflictos. #Incorrecto\: FTP es PRIMITIVO y PELIGROSO para desarrollo colaborativo\: • PROBLEMAS FTP\: (1) Sin control de versiones (si sobrescribes archivo, versión anterior se pierde). (2) Sin historial (no sabes qué cambió ni quién lo cambió). (3) "Esperar turno" es INEFICIENTE (solo 1 persona trabaja a la vez en un archivo). (4) Sin merge (si dos personas cambian el mismo archivo, el segundo sobrescribe al primero). (5) Sin rollback (si alguien rompe algo, difícil volver atrás). • Git permite\: Trabajo PARALELO (cada uno en su rama), merge automático de cambios no conflictivos, historial completo. FTP era usado en los 90s; Git es el estándar moderno. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
~%-33.3333%No necesitan herramientas. Comparten código por email y cada uno integra manualmente los cambios de otros. #Incorrecto\: Email es el PEOR método posible para colaboración de código\: • PROBLEMAS\: (1) Caos total (emails con archivos adjuntos desactualizados). (2) Integración manual propensa a errores (copiar-pegar código de emails). (3) Sin historial estructurado (buscar en emails viejos para ver cambios). (4) Conflictos imposibles de resolver (dos personas cambian lo mismo → ¿cómo fusionas?). (5) Escalabilidad nula (con 5 devs ya es caos; con 50 es imposible). • Proyectos open source con MILES de colaboradores usan Git exitosamente. • Email para código es de los años 80. Git es el estándar desde 2005. NO uses email para código en equipo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.6. Sistemas de Gestión de Versiones: Control de Cambios en el Código'.
}

::CE 1.f – Framework Django para web::
Necesitas desarrollar rápidamente una aplicación web con autenticación de usuarios, panel de administración y base de datos. ¿Qué tipo de herramienta acelera este desarrollo?
{
=Un framework web como Django (Python) que proporciona\: ORM para base de datos, sistema de autenticación integrado, panel admin automático, routing, templates, reduciendo código boilerplate. #Correcto\: Django como framework web completo\: (1) FEATURES INCLUIDAS\: • ORM (Object-Relational Mapping)\: Define modelos en Python, Django genera SQL automáticamente. • Autenticación\: Sistema de usuarios, login, permisos, sesiones (incluido). • Admin panel\: Interfaz CRUD automática para modelos (generada automáticamente). • Routing\: URLs → vistas. • Templates\: Sistema de plantillas HTML. • Seguridad\: CSRF protection, SQL injection prevention. (2) VENTAJA\: No escribes desde cero; usas componentes probados. (3) ALTERNATIVAS\: Flask (Python, más minimalista), Express (Node.js), Spring (Java), Laravel (PHP), ASP.NET (C#). Los frameworks aceleran desarrollo 5-10x vs escribir todo desde cero. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%Debes programar todo desde cero en C porque es el único lenguaje que soporta desarrollo web. #Incorrecto\: TOTALMENTE FALSO. C NO es apropiado ni común para desarrollo web\: • C es de bajo nivel\: Necesitarías escribir TODO manualmente\: parsing HTTP, manejo de sockets, templates, SQL, sesiones. EXTREMADAMENTE laborioso. • Lenguajes/frameworks web comunes\: Python (Django, Flask), JavaScript (Express, React), Java (Spring), PHP (Laravel), Ruby (Rails), C# (ASP.NET). • C se usa para\: Servidores web de alto rendimiento (nginx, Apache están en C), pero NO aplicaciones web típicas. • Para aplicación web con CRUD, autenticación, admin\: Django/Flask (Python) o similar es 100x más rápido de desarrollar que C. C es inadecuado para este caso de uso. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%GCC es el framework apropiado porque puede compilar código web a ejecutables eficientes. #Incorrecto\: CONFUSIÓN TOTAL. GCC NO es un framework web\: • GCC\: COMPILADOR de C/C++. NO es framework. • Framework web\: Biblioteca/conjunto de herramientas para desarrollo web (routing, templates, DB, etc.). • GCC NO tiene features web\: NO maneja HTTP, templates, bases de datos, autenticación. • Aunque PUDIERAS escribir aplicación web en C y compilarla con GCC, NO tendrías framework (tendrías que escribir todo manualmente). • Para web, necesitas framework como Django, NOT compilador. GCC es herramienta de bajo nivel para C/C++, totalmente diferente a framework web. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%Git es el framework ideal porque versiona automáticamente la base de datos y el código. #Incorrecto\: Git NO es un framework web; es control de VERSIONES\: • Git\: Versiona CÓDIGO fuente (archivos .py, .js, .html, etc.). SÍ es esencial para desarrollo. • Git NO es framework web\: NO proporciona routing, templates, ORM, autenticación. • Bases de datos\: Git NO versiona bases de datos directamente. Versionas MIGRACIONES (archivos que definen cambios de esquema), NO datos. • Para desarrollo web necesitas\: (1) Framework web (Django) para funcionalidad. (2) Git para versionar código. Son complementarios, NO alternativos. Git versiona el código; Django proporciona features web. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
}

::CE 1.f – Documentación con Javadoc::
Estás escribiendo una biblioteca Java que otros desarrolladores usarán. Necesitas generar documentación HTML de las clases y métodos públicos. ¿Qué herramienta usas?
{
=Javadoc. Escribes comentarios especiales /** ... */ en el código con tags @param, @return, @throws. Ejecutas javadoc para generar HTML automáticamente con la API documentada. #Correcto\: Uso de Javadoc\: (1) COMENTARIOS EN CÓDIGO\: ```java /** * Calcula el factorial de un número. * @param n El número (debe ser >= 0) * @return El factorial de n * @throws IllegalArgumentException si n < 0 */ public int factorial(int n) {...} ``` (2) GENERACIÓN\: javadoc -d docs src/*.java (genera HTML en directorio docs/). (3) RESULTADO\: Sitio web navegable con todas las clases, métodos, parámetros documentados. (4) VENTAJA\: Documentación SINCRONIZADA con código (está en el mismo archivo). (5) ESTÁNDAR\: Toda la API estándar de Java está documentada con Javadoc. Similar\: Doxygen (C++), JSDoc (JavaScript), Sphinx (Python). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
~%-33.3333%Git genera automáticamente documentación HTML basándose en los commits del proyecto. #Incorrecto\: Git NO genera documentación de API\: • Git\: Control de versiones (historial de cambios, commits, branches). NO documenta API. • Los commits describen QUÉ cambió, NO documentan cómo USAR la API. • Documentación de API necesita\: Descripción de clases, métodos, parámetros, valores de retorno, ejemplos. • Javadoc lee COMENTARIOS del código fuente y genera docs. Git lee HISTORIAL de commits (propósito diferente). • Para documentación de API\: Javadoc, Doxygen, JSDoc. Para historial de cambios\: Git log, CHANGELOG generado de commits. Son herramientas diferentes con propósitos diferentes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
~%-33.3333%SonarQube es la herramienta estándar para generar documentación HTML de proyectos Java. #Incorrecto\: SonarQube NO genera documentación de API\: • SonarQube\: Análisis de CALIDAD de código (bugs, code smells, vulnerabilidades, cobertura de tests). • SonarQube genera\: Reportes de calidad, métricas, problemas encontrados. NO documentación de API. • Para documentación de API pública\: Javadoc (genera docs de cómo USAR el código). • Para análisis de calidad\: SonarQube (genera reportes de CALIDAD del código). • Son complementarias\: Javadoc para usuarios de tu biblioteca; SonarQube para mantenedores (evaluar calidad interna). Javadoc documenta QUÉ hace el código; SonarQube evalúa QUÉ TAN BIEN está escrito. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
~%-33.3333%JUnit genera automáticamente documentación basándose en los tests unitarios del proyecto. #Incorrecto\: JUnit NO genera documentación de API\: • JUnit\: Framework de TESTING (escribir y ejecutar tests unitarios). NO genera docs. • Tests unitarios\: Verifican que el código FUNCIONE correctamente. NO documentan la API pública. • Aunque tests PUEDEN servir como "documentación por ejemplo" (ver cómo se usa el código), NO generan HTML navegable. • Para documentación HTML de API\: Javadoc (lee comentarios /** */ y genera HTML). • Para tests\: JUnit (ejecuta tests, reporta pass/fail). Son propósitos diferentes\: Javadoc documenta; JUnit verifica. Ambos son importantes pero no intercambiables. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.4. Herramientas de Documentación: Generación de Documentos a Partir del Código'.
}

::CE 1.f – Análisis de calidad con SonarQube::
Tu proyecto Java tiene 50,000 líneas de código. El líder técnico quiere un reporte de code smells, duplicación de código, cobertura de tests y vulnerabilidades. ¿Qué herramienta usas?
{
=SonarQube. Configuras el proyecto, ejecutas análisis (mvn sonar\:sonar o similar), y SonarQube genera dashboard web con métricas de calidad\: bugs, code smells, duplicación, cobertura, vulnerabilidades. #Correcto\: Uso de SonarQube\: (1) SETUP\: SonarQube server (local o cloud), proyecto configurado. (2) ANÁLISIS\: mvn sonar\:sonar (Maven) o gradle sonar (Gradle) → Analiza código y sube resultados. (3) DASHBOARD\: Web UI muestra\: • Bugs\: Errores probables. • Code smells\: Código que funciona pero es mejorable (complejidad, duplicación). • Vulnerabilidades\: Problemas de seguridad (SQL injection, XSS, etc.). • Cobertura\: % de código cubierto por tests. • Duplicación\: Bloques de código repetidos. (4) VENTAJA\: Visión centralizada de calidad, tracking de deuda técnica. SonarQube es estándar en empresas para análisis estático continuo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%GDB puede analizar el código fuente y generar reportes de calidad automáticamente. #Incorrecto\: GDB es DEBUGGER, NO analizador de calidad\: • GDB\: Depura programas EN EJECUCIÓN (breakpoints, inspección de variables, stack traces). • GDB NO analiza calidad de código (no detecta code smells, duplicación, vulnerabilidades). • Para calidad de código\: Análisis ESTÁTICO (sin ejecutar)\: SonarQube, ESLint, Pylint, Clang-Tidy. • Para debugging\: Análisis DINÁMICO (ejecutando)\: GDB, LLDB, Visual Studio Debugger. • Son herramientas complementarias pero DIFERENTES\: GDB encuentra bugs en ejecución; SonarQube encuentra problemas potenciales en código fuente sin ejecutar. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Maven es la herramienta apropiada porque puede detectar todos los code smells durante la compilación. #Incorrecto\: Maven es BUILD TOOL, NO analizador de calidad\: • Maven\: Gestiona dependencias, compila, ejecuta tests, empaqueta (JAR/WAR). • Maven NO analiza calidad de código por sí mismo (puede compilar código con code smells sin quejarse). • Maven INTEGRA con SonarQube\: Usas plugin maven-sonar-plugin para ejecutar análisis, pero el ANÁLISIS lo hace SonarQube. • Comando\: mvn sonar\:sonar → Maven llama a SonarQube, pero SonarQube hace el análisis. • Para calidad\: SonarQube (o CheckStyle, PMD, SpotBugs integrados en Maven). Maven es el orquestador; SonarQube es el analizador. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Git puede generar métricas de calidad basándose en el historial de commits y cambios. #Incorrecto\: Git NO analiza calidad de código\: • Git\: Control de versiones (commits, branches, diffs). NO analiza calidad. • Git puede generar MÉTRICAS DE PROCESO\: Quién commitea más, frecuencia de cambios, áreas de código que cambian frecuentemente. • Git NO detecta\: Code smells, bugs, vulnerabilidades, duplicación (requiere análisis del CONTENIDO del código, no solo cambios). • Para análisis de calidad\: SonarQube (analiza AST, flujo de control, patrones). • Para métricas de proceso\: Git stats (git log --stat, herramientas como GitStats). Son complementarias\: Git track. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.

a cambios; SonarQube evalúa calidad.
}

::CE 1.f – Pruebas de carga con JMeter::
Necesitas verificar que tu API REST soporta 1000 usuarios concurrentes sin degradación de rendimiento. ¿Qué tipo de herramienta usas y qué mide?
{
=Herramienta de pruebas de carga/rendimiento como JMeter. Simula 1000 usuarios concurrentes haciendo requests HTTP y mide\: throughput (requests/seg), latencia (tiempo de respuesta), tasa de error. #Correcto\: Pruebas de carga con JMeter\: (1) SETUP\: Creas plan de pruebas en JMeter con\: • Thread Group\: 1000 threads (usuarios virtuales). • HTTP Request\: GET/POST a tu API. • Assertions\: Verificar respuestas correctas. (2) EJECUCIÓN\: JMeter lanza 1000 threads concurrentes haciendo requests. (3) MÉTRICAS\: • Throughput\: Requests/segundo procesados. • Latencia promedio/p95/p99\: Tiempo de respuesta. • Error rate\: % de requests fallidos. • Gráficos de rendimiento en el tiempo. (4) RESULTADO\: Identificas\: Cuellos de botella, capacidad máxima, puntos de fallo. (5) ALTERNATIVAS\: Gatling, Locust, k6, Artillery. Las pruebas de carga son CRÍTICAS antes de lanzar a producción. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%JUnit es apropiado porque puede ejecutar 1000 tests unitarios simultáneamente simulando usuarios. #Incorrecto\: JUnit es para TESTS UNITARIOS, NO pruebas de carga\: • JUnit\: Verifica lógica de CÓDIGO (métodos individuales, clases). Tests rápidos (<ms), ejecutados en local. • Pruebas de carga\: Verifican SISTEMA completo bajo CARGA real (HTTP, DB, red). Tests lentos (minutos), contra servidor real. • JUnit NO puede\: (1) Simular usuarios HTTP concurrentes (no es cliente HTTP). (2) Medir throughput, latencia de API. (3) Generar carga sostenida por minutos/horas. • Aunque JUnit PUEDE ejecutar tests en paralelo, NO es para pruebas de carga de APIs. • Para tests unitarios\: JUnit. Para pruebas de carga\: JMeter/Gatling. Son tipos de testing completamente diferentes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Git puede simular commits concurrentes de 1000 usuarios para probar el sistema bajo carga. #Incorrecto\: Git NO es herramienta de pruebas de carga\: • Git\: Control de versiones. NO tiene capacidades de simular carga HTTP. • "Commits concurrentes" NO es lo mismo que "usuarios API concurrentes"\: (1) Commits\: Operaciones de VCS (local, no relacionado con API REST). (2) Usuarios API\: HTTP requests a servidor web. • Para probar API REST\: Necesitas herramienta que haga HTTP requests (JMeter, curl en loop, etc.). • Git NO hace HTTP requests a tu API; gestiona código fuente. Confusión total de propósitos. Para carga de API\: JMeter. Git no tiene relación con pruebas de rendimiento de APIs. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%SonarQube puede ejecutar análisis estático que simula 1000 usuarios y mide el rendimiento del código. #Incorrecto\: SonarQube es ANÁLISIS ESTÁTICO, NO pruebas de carga\: • SonarQube\: Analiza código FUENTE sin EJECUTAR (detecta bugs, code smells, vulnerabilidades). • SonarQube NO ejecuta la aplicación; analiza el código estáticamente. • Pruebas de carga\: EJECUTAN la aplicación con carga real (requests HTTP). • SonarQube NO puede\: (1) Hacer HTTP requests. (2) Simular usuarios concurrentes. (3) Medir throughput/latencia de API. • Para análisis de calidad de código\: SonarQube. Para pruebas de carga\: JMeter. Son herramientas totalmente diferentes con propósitos no relacionados. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
}

::CE 1.f – Linter ESLint para JavaScript::
Tu equipo JavaScript tiene problemas con código inconsistente\: algunos usan comillas simples, otros dobles; espacios vs tabs; etc. ¿Qué tipo de herramienta ayuda a mantener estilo consistente?
{
=Un linter como ESLint. Configuras reglas de estilo (.eslintrc), ejecutas eslint en el código, y reporta violaciones\: comillas incorrectas, indentación inconsistente, variables no usadas, etc. #Correcto\: Uso de ESLint\: (1) INSTALACIÓN\: npm install eslint --save-dev. (2) CONFIGURACIÓN\: .eslintrc.json con reglas\: { "rules"\: { "quotes"\: ["error", "single"], "indent"\: ["error", 2] } }. (3) EJECUCIÓN\: eslint src/**/*.js → Lista errores de estilo. (4) AUTOFIX\: eslint --fix → Corrige automáticamente muchos problemas (comillas, indentación). (5) INTEGRACIÓN\: CI/CD falla si hay errores de lint (obliga estilo consistente). (6) VENTAJA\: Código consistente, legible, menos bugs (detecta variables no usadas, comparaciones incorrectas). Linters son esenciales para proyectos en equipo. Similares\: Pylint (Python), RuboCop (Ruby), Clippy (Rust). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%GCC puede analizar JavaScript y reportar problemas de estilo durante la compilación. #Incorrecto\: GCC NO analiza JavaScript\: • GCC\: Compilador de C/C++/Fortran. NO entiende JavaScript. • JavaScript NO se compila con GCC; se ejecuta en navegadores (V8, SpiderMonkey) o Node.js. • Si intentas "gcc archivo.js" → error (GCC espera C/C++). • Para JavaScript\: (1) Linter\: ESLint (análisis estático de estilo/bugs). (2) Runtime\: Node.js, navegadores (ejecución). • GCC no tiene relación con JavaScript. Es confusión total de lenguajes y herramientas. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%JMeter es la herramienta apropiada para verificar consistencia de estilo en código JavaScript. #Incorrecto\: JMeter es para PRUEBAS DE CARGA, NO análisis de código\: • JMeter\: Simula usuarios HTTP, mide rendimiento de APIs/sitios web. • JMeter NO analiza código fuente (no lee archivos .js, no verifica estilo). • JMeter NO sabe nada de sintaxis JavaScript, comillas, indentación. • Para análisis de estilo JavaScript\: ESLint (linter). • Para pruebas de carga\: JMeter. • Son herramientas para propósitos completamente diferentes. JMeter no tiene capacidades de análisis de código. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
~%-33.3333%Git puede detectar automáticamente inconsistencias de estilo en los commits y rechazarlos. #Incorrecto\: Git NO analiza estilo de código por sí mismo\: • Git\: Control de versiones (commits, diffs, branches). NO analiza contenido del código. • Git NO sabe qué son "comillas correctas" o "indentación consistente". • PUEDES integrar ESLint con Git hooks\: (1) Pre-commit hook ejecuta eslint. (2) Si hay errores, el commit se rechaza. Pero el ANÁLISIS lo hace ESLint, NO Git. • Git es el orquestador; ESLint es el analizador. • Para forzar estilo\: ESLint + Git hooks (Husky). Git solo versiona; no analiza estilo. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.8. Herramientas para Pruebas y Calidad de Código'.
}

::CE 1.f – Build automation con Maven::
Tienes un proyecto Java con 20 dependencias externas (bibliotecas). Manualmente descargarlas y configurar el classpath es tedioso. ¿Qué herramienta automatiza esto?
{
=Maven. Defines dependencias en pom.xml, Maven las descarga automáticamente de repositorios centrales, gestiona versiones y conflictos, y configura el classpath para compilación y ejecución. #Correcto\: Uso de Maven\: (1) ARCHIVO pom.xml\: ```xml <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>5.3.20</version> </dependency> </dependencies> ``` (2) COMANDO\: mvn compile → Maven\: • Descarga spring-core JAR + sus dependencias transitivas. • Guarda en repositorio local (~/.m2/repository). • Configura classpath automáticamente. (3) BENEFICIOS\: • No descargas JARs manualmente. • Gestión de versiones centralizada. • Resolución de conflictos de dependencias. • Build reproducible (mismo pom.xml → mismo resultado). (4) ALTERNATIVAS\: Gradle (más moderno), Ant+Ivy (antiguo). Maven es estándar en proyectos Java empresariales. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Git es la herramienta apropiada porque puede descargar y versionar todas las bibliotecas del proyecto. #Incorrecto\: Git NO gestiona dependencias de bibliotecas\: • Git\: Versiona CÓDIGO FUENTE del proyecto. NO descarga dependencias externas. • Mal enfoque\: Commitear JARs de bibliotecas al repo Git (repo gigante, difícil actualizar versiones). • Buen enfoque\: Git versiona pom.xml (define dependencias); Maven descarga JARs (NO commiteados a Git). • Git + Maven\: (1) Git versiona código fuente + pom.xml. (2) Maven descarga bibliotecas según pom.xml. (3) .gitignore ignora carpetas de bibliotecas (target/, .m2/). • Para versionado de código\: Git. Para gestión de dependencias\: Maven. Son complementarios, no intercambiables. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%JUnit puede descargar automáticamente todas las bibliotecas necesarias durante la ejecución de tests. #Incorrecto\: JUnit NO gestiona dependencias\: • JUnit\: Framework de TESTING (escribir y ejecutar tests unitarios). • JUnit NO descarga bibliotecas; ASUME que las bibliotecas ya están en el classpath. • Si faltan dependencias → JUnit falla con ClassNotFoundException. • Para TENER las dependencias\: Maven/Gradle descargan bibliotecas. • Para USAR las dependencias en tests\: JUnit ejecuta tests (asumiendo dependencias disponibles). • Maven gestiona dependencias (incluido JUnit mismo); JUnit las usa. JUnit es una dependencia MÁS que Maven gestiona, no un gestor de dependencias. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Javadoc puede generar documentación que incluye automáticamente todas las bibliotecas externas necesarias. #Incorrecto\: Javadoc NO gestiona dependencias\: • Javadoc\: Genera DOCUMENTACIÓN de API (HTML de clases/métodos). • Javadoc NO descarga ni gestiona bibliotecas externas. • Para generar docs de bibliotecas externas\: Javadoc necesita que las bibliotecas YA estén en el classpath (Maven las descarga). • Javadoc DOCUMENTA código que Maven compiló con dependencias que Maven descargó. • Para dependencias\: Maven. Para documentación\: Javadoc. Secuencia\: (1) Maven descarga deps. (2) Maven compila con deps. (3) Javadoc genera docs del código compilado. Javadoc no gestiona dependencias. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
}

::CE 1.f – Depurador Python PDB::
Tu script Python falla con un KeyError en un diccionario. Quieres pausar la ejecución justo antes del error para inspeccionar el diccionario. ¿Qué herramienta usas?
{
=PDB (Python Debugger). Añades 'import pdb; pdb.set_trace()' antes de la línea problemática, ejecutas el script, y PDB pausa permitiendo inspeccionar variables con 'p nombre_variable'. #Correcto\: Uso de PDB\: (1) CÓDIGO\: ```python import pdb data = {"key1"\: "value"} pdb.set_trace() # Breakpoint value = data["key2"] # KeyError ``` (2) EJECUCIÓN\: python script.py → Se pausa en set_trace(). (3) COMANDOS PDB\: • p data → Muestra contenido del diccionario. • p data.keys() → Muestra claves disponibles. • n (next)\: Siguiente línea. • c (continue)\: Continuar hasta próximo breakpoint. • q (quit)\: Salir. (4) Python 3.7+\: breakpoint() (equivalente a pdb.set_trace()). (5) ALTERNATIVAS\: ipdb (PDB mejorado), debuggers de IDEs (PyCharm, VSCode). PDB es built-in, no requiere instalación. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%GDB puede depurar scripts Python directamente sin necesidad de herramientas adicionales. #Incorrecto\: GDB es para C/C++, NO ideal para Python\: • GDB PUEDE depurar el INTÉRPRETE Python (CPython escrito en C), pero es muy bajo nivel. • Con GDB verías\: Punteros C, estructuras internas de CPython, código assembly. NO variables Python directamente. • Para Python\: PDB (alto nivel, variables Python). Para C/C++\: GDB (bajo nivel, variables C). • Existe python-gdb (extensión GDB para Python), pero PDB es mucho más simple para debugging Python típico. • GDB se usa para\: (1) Debugging de extensiones C de Python. (2) Crashes del intérprete Python. Para scripts Python normales\: PDB es apropiado. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%SonarQube puede ejecutar el script y pausarlo automáticamente cuando detecta el KeyError. #Incorrecto\: SonarQube es ANÁLISIS ESTÁTICO, NO debugger dinámico\: • SonarQube\: Analiza código FUENTE sin EJECUTAR. Detecta code smells, bugs potenciales. • SonarQube NO ejecuta el programa; analiza estáticamente. • KeyError es error de RUNTIME (depende de datos en ejecución). SonarQube NO puede predecir todos los KeyErrors (depende de qué datos tenga el diccionario en runtime). • Para DETECTAR bugs antes de ejecutar\: SonarQube (análisis estático). • Para DEPURAR bugs en ejecución\: PDB, debuggers (análisis dinámico). • Son complementarios\: SonarQube previene algunos bugs; PDB diagnostica bugs que ocurren en runtime. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
~%-33.3333%pip (gestor de paquetes Python) puede instalar un depurador que resuelve automáticamente KeyErrors. #Incorrecto\: pip NO depura; INSTALA paquetes\: • pip\: Gestor de paquetes (pip install numpy, pip install ipdb). • pip NO depura código; instala herramientas que pueden depurar. • Para depurar\: (1) pip install ipdb (instala depurador mejorado). (2) Usas ipdb en código (import ipdb; ipdb.set_trace()). (3) ipdb te permite inspeccionar variables. • No hay "depurador que resuelve automáticamente KeyErrors". Los debuggers AYUDAN a investigar errores; NO los resuelven automáticamente. • pip es instalador; PDB/ipdb son debuggers. pip instala herramientas; no las ejecuta. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.5. Depuradores: Análisis del Comportamiento del Programa en Tiempo de Ejecución'.
}

::CE 1.f – Frameworks vs bibliotecas::
Un junior pregunta\: "¿Cuál es la diferencia entre usar la biblioteca 'requests' (HTTP client) y el framework 'Django' (web framework) en Python?". ¿Cómo lo explicas?
{
=Biblioteca (requests)\: TÚ llamas a sus funciones cuando necesitas (requests.get(url)). Framework (Django)\: Define la ESTRUCTURA de tu app; TÚ implementas partes específicas (views, models) y el framework llama tu código. #Correcto\: Biblioteca vs Framework\: • BIBLIOTECA (requests)\: (1) TÚ tienes control de flujo. (2) Llamas funciones de biblioteca cuando necesitas\: response = requests.get(url). (3) Biblioteca es herramienta que usas. (4) Ejemplo\: NumPy, pandas, requests. • FRAMEWORK (Django)\: (1) FRAMEWORK tiene control de flujo (Inversion of Control). (2) TÚ defines\: class MyView(View)\: def get(self, request)\: ... (3) FRAMEWORK llama tu código cuando recibe HTTP request. (4) Framework define estructura; tú rellenas huecos. (5) Ejemplo\: Django, Flask, Spring, React. Analogía\: Biblioteca = herramienta que usas; Framework = casa con estructura, tú decoras interior. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%No hay diferencia; tanto bibliotecas como frameworks son lo mismo, solo términos diferentes. #Incorrecto\: HAY diferencia fundamental (Inversión de Control)\: • BIBLIOTECA\: (1) TÚ escribes main(). (2) TÚ llamas biblioteca\: import requests; requests.get(...). (3) Control de flujo está en TU código. • FRAMEWORK\: (1) FRAMEWORK ejecuta tu código. (2) TÚ implementas\: def my_view(request)\: return response. (3) FRAMEWORK llama my_view() cuando llega request HTTP. (4) Control de flujo está en el FRAMEWORK. • Inversión de Control (IoC)\: En framework, el framework LLAMA tu código (no al revés). • En biblioteca, TÚ llamas la biblioteca. • Esta diferencia es fundamental en arquitectura de software. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%Django es una biblioteca más grande que requests; la diferencia es solo de tamaño. #Incorrecto\: La diferencia NO es tamaño; es ARQUITECTURA\: • Tamaño\: Django es más grande (sí), pero NO es eso lo que lo hace framework. • DIFERENCIA CLAVE\: (1) requests\: Biblioteca. TÚ llamas\: requests.get(url) cuando quieres. (2) Django\: Framework. Define estructura (URLs → views → templates). TÚ implementas views; Django las ejecuta. • Podrías tener biblioteca grande (TensorFlow) y framework pequeño (Flask). • Lo que define framework es Inversión de Control, NO tamaño. • Arquitecturalmente\: Biblioteca = componente; Framework = contenedor de tu aplicación. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
~%-33.3333%requests es para backend; Django es para frontend. Esa es la única diferencia. #Incorrecto\: FALSO. Ambos son para backend\: • requests\: Biblioteca para hacer HTTP requests (CLIENTE HTTP). Usado en backend para llamar APIs externas. • Django\: Framework para crear aplicaciones web (SERVIDOR HTTP). Backend que responde a requests. • AMBOS son backend/servidor. • Frontend sería\: HTML/CSS/JavaScript en navegador (React, Vue, Angular). • Diferencia NO es backend vs frontend; es biblioteca (herramienta específica) vs framework (estructura completa). • Analogía correcta\: requests = martillo (herramienta); Django = casa con planos (framework). Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.7. Frameworks: Plantillas y Librerías que Facilitan el Desarrollo'.
}

::CE 1.f – Herramientas de refactoring::
Tu proyecto creció de 1,000 a 50,000 líneas. Necesitas renombrar una clase usada en 200 archivos. Hacerlo manualmente es propenso a errores. ¿Qué facilita esto?
{
=IDEs con refactoring automático (IntelliJ IDEA, Eclipse, VSCode) o herramientas de refactoring. Seleccionas la clase, eliges "Rename", el IDE encuentra todos los usos y renombra consistentemente. #Correcto\: Refactoring automático en IDEs\: (1) PROCESO\: • Seleccionas clase a renombrar. • IDE analiza sintaxis, referencias, imports. • Muestra preview de cambios (200 archivos afectados). • Confirmas; IDE renombra en todos los archivos + actualiza imports. (2) SEGURIDAD\: IDE entiende sintaxis (no renombra strings que contengan el nombre, solo código real). (3) OPERACIONES\: Rename, Extract Method, Change Signature, Move Class, etc. (4) VENTAJAS\: • Rápido (segundos vs horas manualmente). • Seguro (no rompe código). • Consistente (no olvidas archivos). (5) HERRAMIENTAS\: IntelliJ (Java/Kotlin), PyCharm (Python), VSCode (múltiples lenguajes). El refactoring automático es CRÍTICO en proyectos grandes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Usar find-and-replace global en editor de texto es suficiente y más rápido que usar IDE. #Incorrecto\: Find-and-replace es PELIGROSO para refactoring\: • PROBLEMAS\: (1) Reemplaza TODO (incluso strings, comentarios, logs\: "Error en clase User" → "Error en clase Cliente"). (2) No actualiza imports automáticamente. (3) No verifica sintaxis (puede generar código roto). (4) Puede renombrar cosas no relacionadas (clase User vs variable user → ambas se renombran). • IDE REFACTORING\: (1) Entiende SINTAXIS (solo renombra declaración + referencias). (2) Actualiza imports/package. (3) Preview de cambios. (4) Rollback si algo falla. • Find-and-replace es OK para cambios simples en pocos archivos. Para refactoring serio\: IDE con refactoring semántico. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%Git puede renombrar automáticamente la clase en todos los commits y archivos del historial. #Incorrecto\: Git NO hace refactoring de código\: • Git\: Control de versiones. Rastrea cambios en ARCHIVOS, no contenido de código. • git mv puede renombrar ARCHIVOS (user.py → cliente.py), pero NO renombra clase DENTRO del archivo. • Para renombrar clase User → Cliente DENTRO de 200 archivos\: Necesitas IDE con refactoring o scripts de análisis sintáctico. • Git es para VERSIONADO después del refactoring\: (1) IDE refactoriza código (renombra clase). (2) Git commitea los cambios (git add -A && git commit). • Git no entiende sintaxis de lenguajes; solo rastrea cambios de texto. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
~%-33.3333%SonarQube tiene funcionalidad de refactoring automático que puede renombrar clases en todo el proyecto. #Incorrecto\: SonarQube NO refactoriza código\: • SonarQube\: ANALIZA calidad (detecta code smells, bugs, vulnerabilidades). NO MODIFICA código. • SonarQube es READ-ONLY\: Lee código, genera reportes. NO escribe código. • Para refactoring\: IDE (IntelliJ, Eclipse, VSCode) que MODIFICA código. • Workflow típico\: (1) SonarQube reporta "clase tiene nombre no descriptivo". (2) TÚ decides renombrar. (3) IDE refactoriza (renombra). (4) Commiteas cambios. • SonarQube identifica problemas; IDE los arregla. Roles diferentes. Consulta `EDES-U1.6.-FuncionalidadesHerramientas.md`, sección '2.9. Otras herramientas'.
}

