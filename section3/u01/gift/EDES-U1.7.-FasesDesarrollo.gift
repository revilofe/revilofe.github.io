// EDES-U1.7 - FasesDesarrollo
// Banco de preguntas sobre fases del desarrollo de software y metodologías
// Fases de desarrollo y metodologías ágiles

::Fases – Análisis de requisitos en aplicación móvil::
Tu cliente quiere una app móvil de delivery pero solo dice "necesito que los usuarios pidan comida". En la fase de análisis, ¿qué debes hacer ANTES de diseñar?
{
=Especificar requisitos funcionales detallados (registro de usuarios, catálogo de restaurantes, carrito, pago, seguimiento de pedido) y no funcionales (tiempo de respuesta, seguridad de pagos, plataformas). #Correcto\: Análisis de requisitos exhaustivo\: (1) REQUISITOS FUNCIONALES\: • Registro/login de usuarios (email, redes sociales). • Catálogo de restaurantes y menús. • Carrito de compra. • Pasarela de pago (tarjeta, PayPal). • Seguimiento de pedido en tiempo real. • Calificaciones y reseñas. (2) REQUISITOS NO FUNCIONALES\: • Plataformas (iOS, Android). • Rendimiento (cargar menú <2 seg). • Seguridad (PCI-DSS para pagos). • Escalabilidad (soportar 10K usuarios concurrentes). (3) RESULTADO\: Documento ERS (Especificación de Requisitos de Software) detallado. SIN análisis adecuado, diseñarás la app incorrecta. El 60% de fallos de proyectos se debe a requisitos mal capturados. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.2. Análisis (Etapa de Análisis)'.
~%-33.3333%Empezar a programar inmediatamente la app en Java porque es más rápido que escribir documentos. #Incorrecto\: Programar sin análisis es RECETA para el FRACASO\: • SIN ANÁLISIS\: (1) No sabes QUÉ funcionalidades exactamente (¿solo comida o también supermercado?). (2) No sabes plataforma (¿iOS, Android, ambos?). (3) No sabes restricciones (presupuesto, tiempo, tecnología). (4) Programas basándote en SUPOSICIONES. (5) Cliente ve el resultado\: "No, yo quería otra cosa" → REHACER TODO. • CON ANÁLISIS\: (1) Captura requisitos completos. (2) Cliente valida ANTES de programar. (3) Programas LO CORRECTO desde el inicio. • Estudios muestran\: Arreglar bug de requisitos en producción cuesta 100x más que detectarlo en análisis. NUNCA saltes análisis. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.2. Análisis (Etapa de Análisis)'.
~%-33.3333%Contratar diseñadores gráficos para crear mockups bonitos de la interfaz de usuario. #Incorrecto\: Mockups ANTES de análisis es prematuro\: • Mockups/diseño de UI es parte de la fase de DISEÑO, NO análisis. • PROBLEMA\: Si diseñas UI sin saber requisitos completos\: (1) Diseñas pantallas de funcionalidades que el cliente no quiere. (2) Olvidas funcionalidades que el cliente SÍ quiere. (3) Mockups bonitos pero inútiles. • ORDEN CORRECTO\: (1) ANÁLISIS\: Qué funcionalidades (registro, catálogo, pago, etc.). (2) DISEÑO\: Cómo implementarlas (arquitectura, UI, base de datos). (3) Mockups son OUTPUT del diseño, INPUT del análisis. • Primero saber QUÉ construir (análisis), luego CÓMO se verá (diseño). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.2. Análisis (Etapa de Análisis)'.
~%-33.3333%Comprar servidores y configurar bases de datos para tener la infraestructura lista. #Incorrecto\: Infraestructura es PREMATURA sin análisis\: • SIN requisitos, no sabes\: (1) Cuántos usuarios esperas (¿necesitas 1 servidor o 100?). (2) Qué base de datos (SQL vs NoSQL depende de requisitos). (3) Si necesitas servidores propios o cloud (depende de presupuesto/requisitos). (4) Qué tecnologías (Node.js vs Java vs Python depende de equipo y requisitos). • Comprar infraestructura prematuramente\: (1) Gastas dinero innecesario. (2) Puede ser tecnología incorrecta. • ORDEN\: (1) Análisis (requisitos). (2) Diseño (arquitectura, tecnología). (3) ENTONCES decidir infraestructura. Infraestructura sin análisis es como comprar muebles antes de saber si la casa es apartamento o mansión. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.2. Análisis (Etapa de Análisis)'.
}

::Fases – Diseño de arquitectura para e-commerce::
Terminaste el análisis de una tienda online (requisitos claros\: catálogo, carrito, pago, inventario). En la fase de diseño, ¿qué defines?
{
=Arquitectura del sistema (frontend, backend, base de datos), tecnologías (React, Node.js, PostgreSQL), diseño de base de datos (tablas\: usuarios, productos, pedidos), y diseño de interfaces. #Correcto\: Fase de diseño completa\: (1) ARQUITECTURA\: • Frontend\: SPA con React (web) + React Native (móvil). • Backend\: API REST con Node.js/Express. • Base de datos\: PostgreSQL (relacional para transacciones). • Caché\: Redis (catálogo, sesiones). (2) DISEÑO DE BD\: • Tablas\: users, products, categories, orders, order_items, payments. • Relaciones\: orders → users (FK), order_items → products (FK). (3) DISEÑO DE INTERFACES\: • Mockups de pantallas (home, producto, carrito, checkout). (4) DISEÑO DE APIs\: • GET /api/products, POST /api/orders, etc. (5) RESULTADO\: Documento de Arquitectura + Especificación de Módulos. El diseño es el "cómo" implementar el "qué" del análisis. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.3. Diseño'.
~%-33.3333%En diseño solo creas mockups bonitos de la interfaz de usuario sin tocar arquitectura técnica. #Incorrecto\: Diseño es MUCHO MÁS que UI mockups\: • UI mockups son UNA PARTE del diseño, NO todo. • DISEÑO INCLUYE\: (1) Arquitectura de software (capas, componentes, servicios). (2) Diseño de base de datos (esquema, relaciones, índices). (3) Diseño de APIs (endpoints, formatos). (4) Selección de tecnologías (lenguajes, frameworks, infraestructura). (5) Diseño de interfaces de usuario. • Diseño SOLO de UI ignora\: Cómo se estructuran los datos, cómo se comunican componentes, cómo escala el sistema. • Diseño completo cubre TODA la arquitectura técnica, no solo la capa visual. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.3. Diseño'.
~%-33.3333%En diseño empiezas a programar el código fuente de las funcionalidades principales. #Incorrecto\: Programar es la fase de CODIFICACIÓN, NO diseño\: • DISEÑO\: Planeas CÓMO vas a construir (diagramas, especificaciones, arquitectura). NO escribes código. • CODIFICACIÓN\: Implementas el diseño escribiendo código. • Saltar de análisis directo a código (sin diseño)\: (1) Arquitectura caótica (no planificada). (2) Difícil de mantener/escalar. (3) Decisiones técnicas ad-hoc (inconsistentes). • ORDEN\: Análisis (qué) → Diseño (cómo, en papel/diagramas) → Codificación (escribir código). • Diseño es el "blueprint" (plano); codificación es la construcción. No confundir planificación con implementación. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.3. Diseño'.
~%-33.3333%Diseño significa elegir el color de botones y fuentes del sitio web. #Incorrecto\: Eso es DISEÑO GRÁFICO, NO diseño de software\: • Diseño de software (ingeniería)\: Arquitectura técnica, estructura de datos, componentes, APIs. • Diseño gráfico (visual)\: Colores, tipografía, iconos, estética. • AMBOS son importantes pero DIFERENTES\: (1) Ingeniero de software\: Diseña arquitectura (3 capas, microservicios, base de datos). (2) Diseñador gráfico/UX\: Diseña apariencia (colores, fuentes, wireframes). • En fase de diseño de INGENIERÍA\: Te preocupas por arquitectura técnica PRIMERO. • Diseño gráfico puede ser paralelo o posterior. • En EDES (Entornos de Desarrollo), "diseño" se refiere a diseño de SOFTWARE/ARQUITECTURA, no gráfico. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.3. Diseño'.
}

::Fases – Codificación con buenas prácticas::
Estás en la fase de codificación de un módulo de autenticación. ¿Qué características debe tener el código para ser de calidad?
{
=Modular (separar lógica en funciones/clases), correcto (implementa requisitos), legible (nombres descriptivos, comentarios), eficiente (no desperdiciar recursos), y con manejo de errores apropiado. #Correcto\: Código de calidad\: (1) MODULARIDAD\: Divide en funciones pequeñas (login(), validatePassword(), generateToken()). (2) CORRECCIÓN\: Funciona según requisitos (autentica correctamente, rechaza credenciales inválidas). (3) LEGIBILIDAD\: • Nombres descriptivos (getUserByEmail, no gube). • Comentarios donde necesario. • Indentación consistente. (4) EFICIENCIA\: No hace consultas innecesarias a DB, usa índices, cachea resultados. (5) MANEJO DE ERRORES\: try-catch, validación de input, mensajes de error claros. (6) SEGURIDAD\: Passwords hasheados (bcrypt), prevención de SQL injection. (7) TESTEABLE\: Funciones puras, dependencias inyectables. Código de calidad reduce bugs, facilita mantenimiento, permite trabajo en equipo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.4. Codificación (Implementación)'.
~%-33.3333%El código solo debe funcionar correctamente; legibilidad y modularidad no importan. #Incorrecto\: FALSO. Código que "solo funciona" es DEUDA TÉCNICA\: • PROBLEMAS de código no modular/legible\: (1) Difícil de mantener (nadie entiende cómo funciona). (2) Difícil de extender (añadir features rompe todo). (3) Imposible de depurar (bugs ocultos en código espagueti). (4) Nadie más puede trabajar en él (dependencia de una persona). • Software vive 10+ años\: (1) 80% del tiempo es MANTENIMIENTO (no desarrollo inicial). (2) Legibilidad/modularidad reducen costo de mantenimiento dramáticamente. • "Funciona" HOY; ¿funcionará después de 50 cambios sin modularidad? NO. • Código legible/modular es inversión a largo plazo. "Solo funciona" es deuda que pagas con intereses después. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.4. Codificación (Implementación)'.
~%-33.3333%Usar nombres de variables de una letra (a, b, x) porque hace el código más corto y eficiente. #Incorrecto\: Nombres de una letra son ILEGIBLES y NO mejoran eficiencia\: • EFICIENCIA\: El compilador/intérprete NO se hace más rápido con nombres cortos. • int u vs int userId → MISMO rendimiento. Los nombres son para HUMANOS, no para la máquina. • LEGIBILIDAD\: Comparación\: • MALO\: int u = db.get(e); if(u.p == h) { t = gen(); } • BUENO\: int userId = database.getUserById(email); if(user.password == hash) { token = generateToken(); } • El segundo es OBVIO; el primero requiere adivinar qué significa cada letra. • Nombres de una letra SOLO aceptables en\: (1) Loops triviales (for(int i=0; ...). (2) Fórmulas matemáticas (a²+b²=c²). • Para variables de negocio\: SIEMPRE nombres descriptivos. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.4. Codificación (Implementación)'.
~%-33.3333%Copiar código de Stack Overflow sin entenderlo porque así se programa más rápido. #Incorrecto\: Copiar sin entender es EXTREMADAMENTE PELIGROSO\: • PROBLEMAS\: (1) Código puede tener bugs (Stack Overflow NO es revisado formalmente). (2) Puede tener vulnerabilidades de seguridad (SQL injection, XSS). (3) Puede no encajar en tu arquitectura (depende de bibliotecas que no tienes). (4) Si no entiendes, NO puedes depurar cuando falla. (5) Si no entiendes, NO puedes mantener/modificar. • Stack Overflow es REFERENCIA, NO código producción directo\: (1) Lee respuesta para ENTENDER concepto. (2) Adapta a tu contexto. (3) Prueba, verifica, entiende. • Copiar ciegamente es como cirugía siguiendo YouTube sin estudiar medicina. SIEMPRE entiende código antes de usarlo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.4. Codificación (Implementación)'.
}

::Fases – Pruebas unitarias vs integración::
Tienes un módulo de cálculo de impuestos (función calcularImpuesto(precio, tasa)). ¿Qué tipo de prueba verificaría solo esta función aisladamente?
{
=Prueba unitaria. Llamas calcularImpuesto(100, 0.21) y verificas que retorna 21, sin depender de base de datos, red, o otros módulos. Solo prueba la lógica interna de la función. #Correcto\: Prueba unitaria\: (1) DEFINICIÓN\: Prueba una UNIDAD de código (función, método, clase) AISLADA. (2) EJEMPLO\: ```javascript test('calcula impuesto correctamente', () => { expect(calcularImpuesto(100, 0.21)).toBe(21); expect(calcularImpuesto(50, 0.10)).toBe(5); expect(calcularImpuesto(0, 0.21)).toBe(0); }); ``` (3) CARACTERÍSTICAS\: • Rápida (<ms). • Sin dependencias externas (sin DB, API, archivos). • Determinística (mismo input → mismo output siempre). (4) OBJETIVO\: Verificar lógica de negocio interna. (5) HERRAMIENTAS\: JUnit (Java), pytest (Python), Jest (JavaScript), NUnit (C#). Pruebas unitarias son la BASE de la pirámide de testing. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.5. Pruebas'.
~%-33.3333%Prueba de integración, porque verifica que la función se integra correctamente con el sistema. #Incorrecto\: Si pruebas SOLO la función aislada, es UNITARIA, NO integración\: • PRUEBA UNITARIA\: calcularImpuesto(100, 0.21) → 21 (solo la función, sin dependencias). • PRUEBA DE INTEGRACIÓN\: (1) Guardas producto en DB. (2) Llamas API que calcula impuesto leyendo de DB. (3) Verificas respuesta completa (DB + función + API). • DIFERENCIA CLAVE\: (1) Unitaria\: UNA unidad, AISLADA. (2) Integración\: MÚLTIPLES unidades JUNTAS. • Si pruebas calcularImpuesto() directamente sin DB/API/otros módulos → UNITARIA. • Si pruebas calcularImpuesto() como parte de flujo completo con DB → INTEGRACIÓN. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.5. Pruebas'.
~%-33.3333%Prueba funcional, porque verifica la funcionalidad de calcular impuestos del sistema. #Incorrecto\: "Funcional" puede ser ambiguo, pero típicamente es más AMPLIO que unitaria\: • PRUEBA UNITARIA\: Función aislada (calcularImpuesto). • PRUEBA FUNCIONAL (típica)\: Feature completa desde perspectiva de usuario. Ejemplo\: "Usuario añade producto al carrito, paga, verifica que recibo incluye impuestos correctos". • ALCANCE\: (1) Unitaria\: Micro (una función). (2) Funcional\: Macro (flujo de usuario end-to-end). • Probar SOLO calcularImpuesto(100, 0.21) → 21 es definitivamente UNITARIA (alcance mínimo). • Prueba funcional involucraría UI, backend, DB (alcance mayor). La confusión viene de terminología variable; pero para una función aislada, "unitaria" es el término correcto. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.5. Pruebas'.
~%-33.3333%Prueba de aceptación, porque el cliente acepta que el impuesto se calcula correctamente. #Incorrecto\: Prueba de aceptación es FINAL, con participación del CLIENTE\: • PRUEBA DE ACEPTACIÓN (UAT - User Acceptance Testing)\: (1) Cliente usa el sistema completo. (2) Verifica que cumple sus necesidades de negocio. (3) Casos de uso reales. (4) Entorno de producción o cercano. • PRUEBA UNITARIA\: Desarrollador verifica función individual. • DIFERENCIAS\: (1) Unitaria\: Técnica, automatizada, por desarrolladores. (2) Aceptación\: De negocio, a menudo manual, por cliente/QA. • Probar calcularImpuesto() aisladamente\: Desarrollador verifica lógica → UNITARIA. • Cliente probando sistema completo con casos reales → ACEPTACIÓN. Son fases diferentes de testing. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.5. Pruebas'.
}

::Fases – Mantenimiento correctivo vs perfectivo::
Tu aplicación en producción tiene un bug\: al introducir cantidad negativa en el carrito, el sistema crashea. ¿Qué tipo de mantenimiento aplicas y qué haces?
{
=Mantenimiento correctivo. Corriges el bug añadiendo validación (if(cantidad < 0) throw error), pruebas la corrección, y despliegas el fix. El objetivo es corregir un defecto existente. #Correcto\: Mantenimiento correctivo\: (1) DEFINICIÓN\: Corregir ERRORES/BUGS en software en producción. (2) PROCESO\: • Reproducir bug (cantidad = -5 → crash). • Identificar causa (falta validación). • Corregir código\: ```python if cantidad <= 0\: raise ValueError("Cantidad debe ser positiva") ``` • Pruebas unitarias (verificar fix). • Desplegar (hotfix o próximo release). (3) URGENCIA\: Bugs críticos (crash, seguridad) requieren hotfix inmediato. (4) OBJETIVO\: Restaurar funcionamiento correcto. (5) DIFERENCIA\: Correctivo = arreglar roto; Perfectivo = mejorar lo que funciona; Evolutivo = añadir nuevo; Adaptativo = ajustar a cambios externos. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
~%-33.3333%Mantenimiento perfectivo, porque perfeccionas la validación del sistema. #Incorrecto\: Aunque añades validación, NO es perfectivo porque corriges un BUG\: • CORRECTIVO\: Arregla algo ROTO (crashea → NO debe crashear). • PERFECTIVO\: Mejora algo que YA FUNCIONA (app funciona pero lenta → optimizas). • El sistema crasheando con negativo es DEFECTO, NO "funciona pero mejorable". • Si después del fix añades\: "Mensajes de error más amigables" (funciona pero mejorable) → ESO sería perfectivo. • REGLA\: ¿Está roto? → Correctivo. ¿Funciona pero mejorable? → Perfectivo. Un crash es definitivamente "roto", por tanto correctivo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
~%-33.3333%Mantenimiento evolutivo, porque evolucionas el sistema para manejar nuevos casos de uso. #Incorrecto\: Evolutivo es añadir NUEVA FUNCIONALIDAD, NO arreglar bugs\: • EVOLUTIVO\: Cliente pide "quiero cupones de descuento" (feature nueva). • CORRECTIVO\: App crashea con negativo (bug que debe corregirse). • Validar cantidades negativas NO es "nuevo caso de uso"; es DEFECTO que debió prevenirse desde el inicio. • La funcionalidad existente (añadir al carrito) está ROTA (crashea). Arreglarla es correctivo. • Evolutivo añade CAPACIDADES nuevas; Correctivo arregla capacidades existentes rotas. Crash es definitivamente correctivo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
~%-33.3333%Mantenimiento adaptativo, porque adaptas el sistema a la nueva realidad de que usuarios introducen negativos. #Incorrecto\: Adaptativo es AJUSTAR a cambios EXTERNOS, NO a bugs internos\: • ADAPTATIVO\: (1) Nueva ley de impuestos (cambio externo legal). (2) Nueva versión de base de datos (cambio tecnológico externo). (3) Soporte para nuevo SO (cambio de plataforma). • CORRECTIVO\: Bug interno del software (falta validación). • Usuarios introduciendo cantidades negativas NO es "cambio externo"; es COMPORTAMIENTO INESPERADO que tu software debe MANEJAR (no crashear). • Falta de validación es DEFECTO de diseño/código, no adaptación a cambio externo. Definitivamente correctivo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
}

::Modelo – Cascada con realimentación::
Estás usando modelo en cascada con realimentación. En fase de codificación descubres que un requisito es técnicamente imposible. ¿Qué permite el modelo?
{
=Volver a la fase de análisis, revisar el requisito con el cliente, modificarlo o replantearlo, y luego continuar con diseño y codificación actualizados. #Correcto\: Cascada con realimentación\: (1) SIN REALIMENTACIÓN (cascada puro)\: Análisis → Diseño → Codificación (no vuelves atrás). Si descubres problema en codificación, estás atascado. (2) CON REALIMENTACIÓN\: Puedes volver a fases anteriores\: • Descubres requisito imposible en codificación. • Vuelves a análisis. • Discutes con cliente (¿hay alternativa? ¿replanteamos?). • Actualizas requisitos. • Re-diseñas con requisitos nuevos. • Codificas la solución ajustada. (3) VENTAJA\: Permite correcciones sin rigidez absoluta. (4) DESVENTAJA\: Volver atrás es COSTOSO (rehacer diseño, parte de código). Por eso métodos ágiles prefieren iteraciones pequeñas (cambios menos costosos). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.1. Modelo en cascada'.
~%-33.3333%Debes continuar codificando ignorando el requisito imposible porque en cascada no puedes volver atrás. #Incorrecto\: Eso sería cascada SIN realimentación (rígido), pero la pregunta especifica CON realimentación\: • Cascada SIN realimentación\: No vuelves atrás (extremadamente rígido, casi nunca usado en realidad). • Cascada CON realimentación\: SÍ puedes volver (modelo usado en práctica). • Ignorar requisito imposible\: (1) Entregas software incompleto. (2) Cliente insatisfecho. (3) Proyecto falla. • NUNCA ignores requisito imposible; debes resolverlo\: (1) Volviendo a análisis (si hay realimentación). (2) O negociando cambio con cliente. Entregar software que NO cumple requisitos es fracaso del proyecto. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.1. Modelo en cascada'.
~%-33.3333%En cascada solo puedes avanzar hacia adelante, por lo que terminas el proyecto y luego lo rehaces desde cero. #Incorrecto\: "Rehacer desde cero" es DESASTROSO y NO es cómo funciona cascada con realimentación\: • Cascada CON realimentación\: Vuelves a fase específica (análisis), NO "desde cero". • Proceso\: (1) Análisis (documentado). (2) Diseño (parte válido se mantiene). (3) Codificación (descubres problema). (4) VUELVES a análisis (ajustas requisito problemático). (5) Actualizas diseño afectado. (6) Continúas codificación. • NO rehaces TODO; solo ajustas lo afectado. • "Rehacer desde cero" solo ocurre si el proyecto fracasa completamente (evitable con realimentación adecuada). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.1. Modelo en cascada'.
~%-33.3333%El modelo en cascada con realimentación cambia automáticamente a metodología ágil cuando hay problemas. #Incorrecto\: NO hay "cambio automático" de metodología\: • Cascada con realimentación sigue siendo CASCADA\: Fases secuenciales con posibilidad de volver atrás. • Ágil\: Iteraciones cortas, desarrollo incremental, sin fases estrictas. • Son MODELOS DIFERENTES\: (1) Cascada + realimentación\: Fases largas, vuelves si necesitas. (2) Ágil\: Iteraciones cortas (2-4 semanas), cambios continuos. • Si usas cascada y descubres problemas, sigues en cascada (con realimentación). • Para cambiar a ágil, necesitas DECISIÓN explícita de cambiar metodología (no ocurre automáticamente). Cascada con realimentación es modelo específico, no "ágil en disfraz". Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.1. Modelo en cascada'.
}

::Modelo – Iterativo incremental::
Tu proyecto debe entregar 10 módulos. En modelo iterativo incremental, ¿cómo organizas el desarrollo?
{
=Divides en 5 iteraciones de 2 semanas. Cada iteración entrega 2 módulos COMPLETOS y funcionales. Cliente puede usar módulos desde iteración 1, obtienes feedback, y ajustas siguientes iteraciones. #Correcto\: Desarrollo iterativo incremental\: (1) PLANIFICACIÓN\: • Iteración 1\: Módulos A, B (completos, probados, desplegables). • Iteración 2\: Módulos C, D + feedback de A,B → ajustes. • Iteración 3\: Módulos E, F + ajustes. • Iteración 4\: Módulos G, H + ajustes. • Iteración 5\: Módulos I, J + ajustes finales. (2) VENTAJAS\: • Cliente usa producto ANTES (desde iteración 1). • Feedback temprano (detectas problemas pronto). • Cambios menos costosos (solo afectan siguientes iteraciones). (3) INCREMENTAL\: Cada iteración AÑADE funcionalidad. (4) ITERATIVO\: Cada iteración REFINA basándose en feedback. Este modelo es base de metodologías ágiles. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.2. Modelo evolutivo' y subsección '2.2.1. Modelo Iterativo Incremental'.
~%-33.3333%Programas 10% de cada módulo en cada iteración, así todos avanzan simultáneamente. #Incorrecto\: Eso NO es incremental; es desarrollo PARALELO fragmentado\: • TU PROPUESTA\: Iteración 1\: 10% de cada módulo (10 módulos al 10% = nada usable). • PROBLEMA\: (1) Cliente NO puede usar nada (ningún módulo completo). (2) No hay feedback útil (todo está incompleto). (3) Al final tienes 10 módulos al 100% al mismo tiempo (sin beneficio incremental). • INCREMENTAL CORRECTO\: Cada iteración entrega ALGO COMPLETO y USABLE. • Ejemplo\: Iteración 1\: Login 100% (usable) > 10 módulos al 10% (no usable). • VALOR TEMPRANO es la clave del incremental. Fragmentar todo simultáneamente pierde el beneficio. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.2. Modelo evolutivo' y subsección '2.2.1. Modelo Iterativo Incremental'.
~%-33.3333%Desarrollo secuencial\: Análisis de todos (2 meses), diseño de todos (2 meses), codificación de todos (6 meses). #Incorrecto\: Eso es modelo en CASCADA, NO iterativo incremental\: • CASCADA\: Fases completas secuenciales (análisis TODO → diseño TODO → código TODO). • ITERATIVO INCREMENTAL\: Ciclos cortos con TODAS las fases por ciclo (análisis+diseño+código de módulos A,B en iteración 1). • PROBLEMA de cascada aquí\: (1) Cliente espera 10 meses para ver ALGO. (2) Sin feedback intermedio. (3) Si hay error en requisitos, se descubre al final (muy costoso). • Iterativo incremental entrega valor cada 2-4 semanas, NO al final de 10 meses. La propuesta describe cascada, opuesto a iterativo incremental. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.2. Modelo evolutivo' y subsección '2.2.1. Modelo Iterativo Incremental'.
~%-33.3333%Entregas documentación en iteración 1, diseño en iteración 2, código en iteración 3. #Incorrecto\: Eso divide por TIPO DE ARTEFACTO, NO por funcionalidad incremental\: • TU PROPUESTA\: Iteración 1 = solo docs (no usable). Iteración 2 = solo diseño (no usable). Iteración 3 = código (usable). • PROBLEMA\: Cliente no puede usar nada hasta iteración 3 (pierde beneficio incremental). • INCREMENTAL CORRECTO\: CADA iteración entrega SOFTWARE FUNCIONAL (docs+diseño+código de ALGUNOS módulos). • Ejemplo correcto\: (1) Iteración 1\: Módulos A,B (análisis+diseño+código completos de A,B). (2) Iteración 2\: Módulos C,D (completos). • VALOR en cada iteración (software usable), NO "artefactos intermedios no ejecutables". Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.2. Modelo evolutivo' y subsección '2.2.1. Modelo Iterativo Incremental'.
}

::Ágil – Manifiesto Ágil (valores)::
Tu equipo debate si documentar exhaustivamente antes de programar o iterar rápido con software funcionando. Según el Manifiesto Ágil, ¿qué se valora MÁS?
{
=Software funcionando sobre documentación extensiva. No elimina documentación, pero prioriza entregar software que funcione sobre documentación exhaustiva que retrasa el desarrollo. #Correcto\: Manifiesto Ágil\: "Software funcionando sobre documentación extensiva". (1) SIGNIFICADO\: • NO dice "sin documentación". • Dice "PRIORIZA software funcionando". • Documentación SUFICIENTE (no exhaustiva). (2) RAZÓN\: • Documentación exhaustiva\: Meses escribiendo docs → software desactualizado. • Software funcionando\: Cliente puede USAR y dar FEEDBACK real. (3) PRÁCTICA\: • Docs mínimos necesarios (README, APIs críticas). • Código autodocumentado (nombres claros, tests como docs). • Docs generados automáticamente (Javadoc, Swagger). (4) OTROS VALORES ÁGILES\: Individuos sobre procesos, colaboración sobre contrato, respuesta al cambio sobre plan. El ágil BALANCEA, no elimina; pero prioriza VALOR ENTREGADO (software) sobre burocracia (docs excesivos). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3. Metodologías Ágiles (Adaptativos)' y subsección '2.3.1. Manifiesto Ágil'.
~%-33.3333%Documentación extensiva sobre software funcionando, porque sin docs el software es imposible de mantener. #Incorrecto\: AL REVÉS. El Manifiesto dice EXACTAMENTE LO OPUESTO\: • Manifiesto\: "Valoramos MÁS el software funcionando QUE la documentación extensiva". • Esto NO significa "sin docs"; significa PRIORIZAR software. • PROBLEMA de docs exhaustivos ANTES de software\: (1) Gastar 3 meses en docs → Cliente no puede probar nada. (2) Requisitos cambian → Docs obsoletos. (3) Docs perfectos de software que no existe aún (inversión prematura). • ÁGIL\: Desarrolla software funcionando rápido → Cliente usa y valida → Ajustas basándote en uso real (no especulación en docs). Docs son SOPORTE, no REEMPLAZO de software funcionando. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3. Metodologías Ágiles (Adaptativos)' y subsección '2.3.1. Manifiesto Ágil'.
~%-33.3333%Ambos son igualmente importantes y deben invertirse el mismo tiempo en documentación que en programación. #Incorrecto\: NO son igualmente importantes en ágil; software tiene PRIORIDAD\: • Manifiesto explícitamente valora "software funcionando sobre documentación". • "Igual importancia" contradiría el principio ágil. • EN PRÁCTICA\: (1) 80% tiempo desarrollo software. (2) 20% tiempo documentación esencial (no exhaustiva). • DOCUMENTACIÓN ESENCIAL\: README, arquitectura básica, APIs públicas. • DOCUMENTACIÓN EXCESIVA (evitar)\: Documentos de requisitos de 500 páginas, diagramas UML exhaustivos que nadie lee. • El VALOR está en el software que el cliente USA, no en docs que nadie lee. Docs son medios; software es el fin. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3. Metodologías Ágiles (Adaptativos)' y subsección '2.3.1. Manifiesto Ágil'.
~%-33.3333%No se debe documentar nada en metodologías ágiles porque ralentiza el desarrollo. #Incorrecto\: EXTREMO FALSO. Ágil NO dice "sin documentación"\: • Manifiesto\: "Software funcionando SOBRE documentación extensiva" (no ELIMINA docs). • DOCUMENTACIÓN ÁGIL\: (1) Suficiente, no exhaustiva. (2) Justo a tiempo (cuando se necesita). (3) Viva (actualizada con código). (4) Automatizada cuando posible (Javadoc, Swagger de APIs). • SIN DOCS\: Código incomprensible, onboarding difícil, mantenimiento imposible. • CON DOCS EXCESIVOS\: Desarrollo lento, docs obsoletos. • BALANCE ÁGIL\: Documentación LEAN (mínima necesaria para éxito). Código autodocumentado + tests + docs esenciales. Cero docs es tan malo como docs excesivos. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3. Metodologías Ágiles (Adaptativos)' y subsección '2.3.1. Manifiesto Ágil'.
}

::Scrum – Roles (Product Owner)::
En Scrum, el cliente quiere añadir una feature urgente que no estaba planeada. ¿Quién decide si se añade al Product Backlog y su prioridad?
{
=El Product Owner, porque es responsable de maximizar el valor del producto, gestionar el Product Backlog y priorizar features según valor de negocio. #Correcto\: Rol del Product Owner (PO)\: (1) RESPONSABILIDADES\: • Gestionar Product Backlog (lista priorizada de features). • Priorizar por valor de negocio. • Decidir QUÉ se desarrolla (no CÓMO). • Interfaz con cliente/stakeholders. • Aceptar o rechazar trabajo completado. (2) EN ESTE CASO\: • Cliente pide feature urgente. • PO evalúa\: ¿Tiene más valor que features actuales? • PO decide\: (a) Añadir al top del backlog (próximo sprint). (b) Añadir más abajo (sprints futuros). (c) Rechazar (no tiene suficiente valor). (3) IMPORTANTE\: Equipo de desarrollo NO decide prioridades (decide cómo implementar). Solo PO prioriza. El PO BALANCEA demandas de stakeholders con valor real. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.3. Los roles en el equipo Scrum'.
~%-33.3333%El Scrum Master decide, porque es el líder del equipo y gestiona el proyecto. #Incorrecto\: El Scrum Master NO decide QUÉ se desarrolla\: • SCRUM MASTER\: (1) Facilita proceso Scrum. (2) Elimina impedimentos. (3) Coach del equipo. (4) NO decide contenido ni prioridades. • PRODUCT OWNER\: Decide QUÉ (features, prioridades). • EQUIPO DESARROLLO\: Decide CÓMO (implementación técnica). • Si Scrum Master decidiera prioridades\: (1) Conflicto de roles con PO. (2) Scrum Master puede no entender valor de negocio. • ROL CORRECTO\: (1) Cliente pide al PO. (2) PO evalúa y prioriza. (3) Scrum Master facilita que el proceso funcione. El Scrum Master NO es "jefe" ni "project manager"; es facilitador. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.3. Los roles en el equipo Scrum'.
~%-33.3333%El equipo de desarrollo vota democráticamente si añadir la feature al backlog. #Incorrecto\: El equipo NO decide QUÉ se desarrolla (decide CÓMO)\: • SEPARACIÓN DE ROLES\: (1) PO\: Decide QUÉ (valor de negocio, prioridades). (2) Equipo\: Decide CÓMO (arquitectura, tecnología, estimación). • Si equipo votara prioridades\: (1) Equipo puede no conocer necesidades de negocio. (2) Puede priorizar features técnicamente interesantes sobre valiosas. (3) Diluye responsabilidad del PO. • PROCESO CORRECTO\: (1) PO prioriza features. (2) Equipo estima esfuerzo. (3) Equipo decide cómo implementar. • El equipo SÍ puede OPINAR ("esta feature es muy compleja, consideramos dividirla"), pero DECISIÓN final de prioridad es del PO. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.3. Los roles en el equipo Scrum'.
~%-33.3333%El cliente decide directamente y lo añade al Sprint Backlog del sprint actual. #Incorrecto\: El cliente NO tiene acceso directo al Sprint Backlog\: • PRODUCT BACKLOG\: Lista de TODO lo pedido (gestionada por PO). Cliente puede pedir features → Van al PRODUCT backlog. • SPRINT BACKLOG\: Subset de Product Backlog comprometido para el sprint ACTUAL. Decidido en Sprint Planning por PO + equipo. • SPRINT EN CURSO\: (1) Sprint Backlog es INMUTABLE durante sprint. (2) NO se añaden features mid-sprint (protege al equipo de cambios constantes). (3) Feature urgente\: Va al Product Backlog, se prioriza, se incluye en PRÓXIMO sprint (no actual). • EXCEPCIÓN\: Si es EXTREMADAMENTE urgente, se puede ABORTAR sprint, re-planear, empezar sprint nuevo (raro, disruptivo). El cliente NO añade directamente; pasa por PO. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.3. Los roles en el equipo Scrum'.
}

::Scrum – Eventos (Daily Scrum)::
En tu equipo Scrum, la Daily Scrum de 15 minutos se convierte en 1 hora de debate técnico detallado. ¿Qué está mal y cómo se corrige?
{
=Daily Scrum debe ser inspección rápida (¿qué hice? ¿qué haré? ¿impedimentos?), NO resolución de problemas. Debates técnicos se posponen para después ("parking lot") en reuniones ad-hoc con personas relevantes. #Correcto\: Daily Scrum correcta\: (1) TIMEBOX\: Máximo 15 minutos (estricto). (2) FORMATO\: Cada miembro responde\: • ¿Qué hice ayer? • ¿Qué haré hoy? • ¿Tengo impedimentos? (3) OBJETIVO\: Sincronización rápida, identificar bloqueos, NO resolverlos. (4) SI SURGE DEBATE\: "Parking lot"\: (1) Anotamos tema. (2) Continuamos Daily. (3) DESPUÉS de Daily, subgrupo relevante discute en detalle. (5) BENEFICIO\: Equipo completo sincronizado en 15 min, NO pierde tiempo en temas que no afectan a todos. (6) ROL SCRUM MASTER\: Facilita, mantiene timebox, previene debates. Daily larga es síntoma de falta de foco. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.4.2. Daily Meeting'.
~%-33.3333%Está bien que Daily dure 1 hora si el equipo está resolviendo problemas importantes. #Incorrecto\: NO está bien; viola principios de Scrum\: • PROBLEMA de Daily de 1 hora\: (1) 9 personas × 1 hora = 9 horas-persona desperdiciadas. (2) Solo 2 personas necesitan el debate técnico; otros 7 pierden tiempo. (3) Daily pierde efectividad (aburrimiento, desconexión). • SCRUM PRINCIPLE\: Reuniones timeboxed (límites estrictos) para eficiencia. • SOLUCIÓN\: (1) Daily\: 15 min de sincronización. (2) Identificar "necesitamos discutir arquitectura de módulo X". (3) DESPUÉS\: 2 personas relevantes discuten (otros siguen trabajando). (4) Reunión ad-hoc de 1 hora con 2 personas = 2 horas-persona (vs 9). Eficiencia 4.5x mayor. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.4.2. Daily Meeting'.
~%-33.3333%Daily Scrum debería eliminarse si el equipo está co-ubicado y se comunica constantemente. #Incorrecto\: Daily Scrum sigue siendo VALIOSA incluso co-ubicados\: • VALOR DIARIO\: (1) Sincronización estructurada (todos al mismo tiempo). (2) Visibilidad de progreso hacia Sprint Goal. (3) Identificación temprana de impedimentos. (4) Accountability (cada uno reporta progreso). • CO-UBICACIÓN ayuda, pero Daily estructura la comunicación\: (1) Sin Daily\: Comunicación ad-hoc, caótica, información fragmentada. (2) Con Daily\: Todos saben qué hacen todos, alineación al Sprint Goal. • EQUIPOS REMOTOS\: Daily es AÚN MÁS crítica (única sincronización regular). • Puedes AJUSTAR formato (si equipo muy pequeño/maduro), pero eliminar pierde beneficios de Scrum. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.4.2. Daily Meeting'.
~%-33.3333%El Scrum Master debe resolver todos los impedimentos durante la Daily Scrum. #Incorrecto\: Scrum Master NO resuelve impedimentos DURANTE Daily\: • DURANTE DAILY\: (1) Equipo IDENTIFICA impedimentos ("bloqueado esperando respuesta de API"). (2) Scrum Master ANOTA (no resuelve). (3) Daily continúa (15 min timebox). • DESPUÉS DE DAILY\: (1) Scrum Master trabaja en ELIMINAR impedimentos (contactar equipo API, escalar si necesario). (2) Puede tomar horas/días (no resuelto en 15 min). • CONFUSIÓN COMÚN\: Daily NO es "reunión de resolución de problemas"; es "reunión de IDENTIFICACIÓN de problemas". • Resolver durante Daily\: Excede timebox, desenfoca equipo. Daily es inspección; resolución es trabajo posterior. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.4.2. Daily Meeting'.
}

::Scrum – Artefactos (Sprint Backlog)::
En Sprint Planning, el equipo seleccionó 8 tareas del Product Backlog para el sprint. ¿Pueden añadirse más tareas mid-sprint si el equipo termina antes?
{
=Sí, PERO solo si el Sprint Goal sigue siendo alcanzable. El equipo puede tomar más tareas del Product Backlog (priorizadas por PO), sin cambiar el Sprint Goal comprometido. #Correcto\: Sprint Backlog dinámico\: (1) REGLA\: Sprint Goal es INMUTABLE. Sprint Backlog es AJUSTABLE (dentro de límites). (2) SI EQUIPO TERMINA ANTES\: • Opción A\: Tomar más tareas del Product Backlog (top priorizado por PO). • Opción B\: Refinar tareas existentes (mejorar calidad, tests, docs). • Opción C\: Apoyar a otros miembros (pair programming). (3) LO QUE NO SE PUEDE\: Cambiar Sprint Goal mid-sprint (requeriría abortar sprint). (4) PROCESO\: (1) Equipo consulta a PO\: "Terminamos todo, ¿qué sigue?" (2) PO indica siguiente prioridad del Product Backlog. (3) Equipo pull tarea. (5) SCRUM FLEXIBLE\: Permite ajustes dentro de sprint sin romper compromiso. El Sprint Backlog es del EQUIPO (puede auto-gestionarse). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.5.2. Sprint Backlog'.
~%-33.3333%No, el Sprint Backlog es completamente inmutable una vez empieza el sprint. #Incorrecto\: DEMASIADO RÍGIDO. Sprint Backlog es AJUSTABLE\: • INMUTABLE\: Sprint Goal (objetivo de negocio del sprint). • AJUSTABLE\: Sprint Backlog (tareas para lograr goal). • RAZÓN\: (1) Emergencia de nuevas tareas (refactoring necesario, bugs descubiertos). (2) Tareas terminan antes de lo estimado (equipo puede hacer más). (3) Tareas tardan más (equipo re-prioriza dentro del sprint). • SCRUM GUIDE\: "El Sprint Backlog es un plan flexible para entregar el Sprint Goal". • PRÁCTICA\: Equipo ajusta Sprint Backlog diariamente según progreso real, SIEMPRE enfocado en lograr Sprint Goal. Rigidez absoluta contradiría principio ágil de "respuesta al cambio". Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.5.2. Sprint Backlog'.
~%-33.3333%El Product Owner puede añadir tareas mid-sprint sin consultar al equipo. #Incorrecto\: PO NO puede imponer tareas mid-sprint unilateralmente\: • DURANTE SPRINT\: El equipo tiene AUTONOMÍA sobre cómo lograr Sprint Goal. • PO NO puede\: (1) Añadir tareas sin consenso del equipo. (2) Cambiar prioridades dentro del sprint comprometido. (3) Interrumpir al equipo con demandas nuevas. • PROCESO CORRECTO si equipo termina antes\: (1) EQUIPO decide si puede hacer más. (2) EQUIPO consulta a PO qué priorizar del Product Backlog. (3) EQUIPO pull tarea (no PO push). • PROTECCIÓN\: Sprint protege al equipo de cambios constantes (pueden enfocarse sin interrupciones). PO prioriza Product Backlog; equipo gestiona Sprint Backlog. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.5.2. Sprint Backlog'.
~%-33.3333%Deben esperar al próximo sprint para tomar nuevas tareas, sin importar cuánto terminen antes. #Incorrecto\: DESPERDICIO. Si equipo termina antes, DEBE hacer más\: • ESPERAR hasta próximo sprint\: (1) Desperdicia capacidad del equipo. (2) Reduce velocity (menor entrega de valor). (3) Desmotiva al equipo (aburrimiento). • SCRUM BUSCA\: Maximizar valor entregado cada sprint. • MEJOR PRÁCTICA\: (1) Equipo termina Sprint Goal. (2) Toma siguiente tarea priorizada del Product Backlog. (3) Continúa hasta fin del sprint. (4) En Sprint Review, muestra TODO lo logrado (incluido extra). • RESULTADO\: Mayor velocity, más valor, equipo productivo. Esperar pasivamente contradice espíritu ágil de maximizar valor. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '3.5.2. Sprint Backlog'.
}

::Ágil – Principios (entrega continua)::
Según principios ágiles, ¿cuál es la preferencia de entrega de software funcionando al cliente?
{
=Entregar frecuentemente (cada 2-4 semanas), con preferencia por periodos cortos, para obtener feedback rápido y ajustar según necesidades reales del cliente. #Correcto\: Principio Ágil de entrega continua\: "Entregar software funcionando frecuentemente, entre dos semanas y dos meses, con preferencia al periodo de tiempo más corto posible". (1) RAZONES\: • Feedback rápido (cliente usa software real, no especulaciones). • Detección temprana de problemas (más barato corregir). • Valor entregado antes (ROI más rápido). • Reducción de riesgo (entregas pequeñas, fallos pequeños). (2) PRÁCTICA MODERNA\: • Sprints de 2 semanas (muy común). • Continuous Delivery (deployer cada commit a staging). • Continuous Deployment (deployer automáticamente a producción tras tests). (3) CONTRASTE CON CASCADA\: Cascada entrega TODO al final (6-12 meses). Ágil entrega ALGO cada 2-4 semanas. Entrega frecuente es FUNDAMENTO del desarrollo ágil. Consulta `EDES-U1.7.-FasesDesarrollo.md`, subsección '3.1.1 Los 12 principios del Manifiesto Ágil'.
~%-33.3333%Entregar una sola vez al final del proyecto cuando todo esté completamente terminado y perfecto. #Incorrecto\: ESO es modelo en CASCADA, OPUESTO a ágil\: • CASCADA\: Análisis (meses) → Diseño (meses) → Código (meses) → ENTREGA (todo de una vez al final). • PROBLEMAS\: (1) Cliente espera 6-12 meses para ver ALGO. (2) Si requisitos están mal, lo descubres AL FINAL (muy costoso). (3) Sin feedback intermedio (alto riesgo). (4) Mercado puede cambiar en 12 meses (software obsoleto antes de entregar). • ÁGIL\: Entrega incremental cada 2-4 semanas. Cliente usa software REAL temprano. Ajustas basándote en feedback. "Entrega única al final" es exactamente lo que ágil EVITA. Consulta `EDES-U1.7.-FasesDesarrollo.md`, subsección '3.1.1 Los 12 principios del Manifiesto Ágil'.
~%-33.3333%Entregar cada 6 meses para asegurar que el software esté completamente probado y sin bugs. #Incorrecto\: 6 meses es DEMASIADO LARGO para ágil\: • Manifiesto Ágil\: "2 semanas a 2 meses, con preferencia por MÁS CORTO". • 6 meses\: (1) Feedback MUY tardío (puedes haber desarrollado features incorrectas durante meses). (2) Riesgo acumulado (muchos cambios sin validar). (3) Mercado cambia (requisitos pueden ser obsoletos). • "PROBADO Y SIN BUGS"\: (1) Testing continuo (CI/CD, tests automatizados) permite calidad CON entregas frecuentes. (2) Esperar 6 meses NO garantiza "sin bugs" (más código = más complejidad = más bugs). • MEJOR\: Entregas pequeñas cada 2 semanas CON testing riguroso (automated tests, CI/CD). Calidad + velocidad, no trade-off. Consulta `EDES-U1.7.-FasesDesarrollo.md`, subsección '3.1.1 Los 12 principios del Manifiesto Ágil'.
~%-33.3333%Entregar solo cuando el cliente solicite explícitamente una nueva versión. #Incorrecto\: Ágil es PROACTIVO en entregas, NO reactivo\: • PROBLEMA de "solo cuando cliente pida"\: (1) Cliente puede no saber QUÉ pedir ni CUÁNDO. (2) Puede pasar mucho tiempo sin entregas (pierde beneficio de feedback). (3) Equipo acumula trabajo sin validar (riesgo). • ÁGIL\: Ritmo REGULAR de entregas (cada 2-4 semanas), independiente de si cliente "pide" explícitamente. (1) Cadencia predecible. (2) Cliente se acostumbra a recibir valor frecuentemente. (3) Feedback se vuelve hábito. • Cliente NO necesita "pedir"\: Equipo ENTREGA regularmente como parte del proceso. Esto educa al cliente en participación continua. Consulta `EDES-U1.7.-FasesDesarrollo.md`, subsección '3.1.1 Los 12 principios del Manifiesto Ágil'.
}

::Kanban – Límite WIP::
Tu equipo Kanban tiene tablero con columnas\: To Do, In Progress, Testing, Done. Hay 10 tareas en "In Progress" y el equipo está atascado. ¿Qué principio Kanban ayuda?
{
=Limitar WIP (Work In Progress). Estableces límite (ej. máximo 3 tareas en In Progress), obligando al equipo a TERMINAR tareas antes de empezar nuevas, mejorando flujo y reduciendo multitasking. #Correcto\: WIP Limit en Kanban\: (1) PROBLEMA\: 10 tareas en progreso\: • Multitasking excesivo. • Nada se termina (todo al 50%). • Context switching (ineficiencia). • Cuellos de botella invisibles. (2) SOLUCIÓN - LÍMITE WIP\: • Establece\: "In Progress\: máximo 3 tareas". • Si 3 tareas en progreso\: NO puedes empezar nueva. • DEBES terminar una (moverla a Testing) antes de pull nueva de To Do. (3) BENEFICIOS\: • Foco (equipo termina tareas, no inicia infinitas). • Flujo continuo (tareas fluyen rápido por el tablero). • Identificación de cuellos de botella (si In Progress se llena, hay problema downstream). (4) TEORÍA\: Ley de Little\: Lead Time = WIP / Throughput. Reducir WIP reduce tiempo de entrega. Kanban optimiza FLUJO, no cantidad en progreso. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.2. Kanban'.
~%-33.3333%Contratar más desarrolladores para trabajar en las 10 tareas simultáneamente. #Incorrecto\: Más personas NO soluciona problema de WIP alto\: • PROBLEMA REAL\: Demasiadas tareas iniciadas (trabajo fragmentado), NO falta de personas. • MÁS PERSONAS con WIP ilimitado\: (1) Aún más tareas en progreso (15, 20). (2) Mismo problema amplificado. (3) Más coordinación necesaria (overhead). • LEY DE BROOKS\: "Añadir personas a proyecto retrasado lo retrasa más" (onboarding, coordinación). • SOLUCIÓN CORRECTA\: LIMITAR WIP (foco en terminar), NO añadir personas. • ANALOGÍA\: Autopista congestionada\: Añadir más carriles NO ayuda si el problema es un cuello de botella aguas abajo. Limitar entrada (WIP limit) mejora flujo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.2. Kanban'.
~%-33.3333%Mover todas las tareas de In Progress directamente a Done para vaciar la columna. #Incorrecto\: FALSO completado. Rompe integridad del proceso\: • Mover a Done sin REALMENTE terminar\: (1) Mentira sobre progreso real. (2) Tareas "done" pero no funcionales. (3) Deuda técnica acumulada. (4) Cliente recibe software roto. • Kanban requiere HONESTIDAD\: Tarea en Done = REALMENTE terminada (coded, tested, deployed, working). • SOLUCIÓN CORRECTA\: (1) Identificar POR QUÉ están atascadas (¿falta claridad? ¿dependencias? ¿demasiado grandes?). (2) TERMINARLAS realmente (pair programming, ayuda mutua). (3) Establecer WIP limit para prevenir futuro. Integridad del proceso es fundamental; mover artificialmente destruye métricas y confianza. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.2. Kanban'.
~%-33.3333%Reorganizar el tablero para tener una sola columna "In Progress/Testing/Done" combinada. #Incorrecto\: Combinar columnas OCULTA problemas, NO los resuelve\: • PROPÓSITO de columnas separadas\: Visualizar FLUJO (dónde están tareas en el proceso). • Combinar "In Progress/Testing/Done"\: (1) Pierde visibilidad (¿cuántas están en testing? ¿cuántas realmente done?). (2) Oculta cuellos de botella (si Testing es lento, no lo ves). (3) Dificulta métricas (lead time, cycle time). • KANBAN\: Visualizar flujo DETALLADAMENTE para identificar y solucionar cuellos de botella. • SOLUCIÓN CORRECTA\: MANTENER columnas separadas + WIP limits + optimizar cuellos de botella. Combinar columnas es "esconder la basura debajo de la alfombra". Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.2. Kanban'.
}

::Metodologías – XP (Programación por parejas)::
Tu equipo considera adoptar programación por parejas (pair programming) de XP. Un desarrollador dice "es desperdicio, dos personas hacen el trabajo de una". ¿Cómo respondes?
{
=Pair programming NO es desperdicio\: Produce código de MEJOR calidad (menos bugs, mejor diseño), conocimiento compartido (no hay "expertos únicos"), y onboarding rápido. Estudios muestran ~15% menos productividad pero ~15% menos bugs. #Correcto\: Beneficios de Pair Programming\: (1) CALIDAD\: • Code review en tiempo real (segundo par detecta bugs inmediatamente). • Mejor diseño (discusión de soluciones). • Menos bugs en producción (15-30% menos según estudios). (2) CONOCIMIENTO COMPARTIDO\: • No hay "bus factor" (si persona X se va, conocimiento se pierde). • Todo el equipo conoce todo el código. (3) ONBOARDING\: Junior + Senior en par → Junior aprende rápidamente. (4) FOCO\: Menos distracciones (social pressure de tener par). (5) COSTO\: Sí, ~15% menos líneas de código/día, pero compensado por menos bugs, menos retrabajo, mejor calidad. TRADE-OFF\: Menos código, MEJOR código. XP prioriza calidad sobre cantidad. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.5. XP (eXtreme Programming)'.
~%-33.3333%Es correcto, pair programming es desperdicio. Mejor trabajar individualmente en tareas separadas. #Incorrecto\: Ignora TODOS los beneficios de pair programming\: • SOLO CONTANDO LÍNEAS DE CÓDIGO\: Parece desperdicio (1+1=1.15 en output). • CONTANDO CALIDAD + MANTENIMIENTO\: (1) Código individual\: Más bugs → Más debugging → Más retrabajo. (2) Código parejas\: Menos bugs → Menos debugging → Entrega más rápida de features sin bugs. • ESTUDIOS\: (1) Initial development\: 15% más lento. (2) Total project time\: Similar o más rápido (menos retrabajo). (3) Bug count\: 15-30% menos. • NO todo debe ser pair programming (tareas triviales pueden ser individuales), pero features complejas/críticas BENEFICIAN de pairing. Es inversión, no desperdicio. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.5. XP (eXtreme Programming)'.
~%-33.3333%Pair programming significa que un desarrollador trabaja mientras el otro observa pasivamente sin contribuir. #Incorrecto\: ESO sería pair programming MAL HECHO. Correcto es COLABORACIÓN ACTIVA\: • MAL\: Conductor escribe código, observador mira pantalla pasivamente (desperdicio). • BIEN\: • CONDUCTOR (driver)\: Escribe código (táctico, implementación). • NAVEGADOR (navigator)\: Revisa lógica, piensa estratégicamente, detecta bugs, sugiere mejoras. • ROTACIÓN\: Cada 15-30 min cambian roles. • DIÁLOGO CONSTANTE\: "¿Y si usamos patrón X?" "Creo que falta validar Y" "Podemos optimizar esto con Z". • Ambos están ACTIVAMENTE involucrados (no pasivo). Si uno es pasivo, el pairing NO funciona (problema de ejecución, no de práctica). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.5. XP (eXtreme Programming)'.
~%-33.3333%Pair programming solo funciona con equipos co-ubicados; es imposible hacerlo remotamente. #Incorrecto\: FALSO. Pair programming remoto es POSIBLE y efectivo\: • HERRAMIENTAS REMOTAS\: (1) VS Code Live Share (editor compartido en tiempo real). (2) Tuple, Pop (apps específicas para pair programming remoto). (3) Zoom/Meet + screen sharing (básico pero funcional). (4) Git Live (collaborative coding). • PRÁCTICAS REMOTAS\: (1) Cámara encendida (comunicación mejor). (2) Audio claro (headsets). (3) Rotación de roles (igual que presencial). • EQUIPOS REMOTOS GLOBALES usan pair programming exitosamente (GitHub, GitLab, Automattic). • DESAFÍO\: Zonas horarias (dificulta sincronización), pero NO imposibilita. Pair programming es sobre COLABORACIÓN, no ubicación física. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '2.3.5. XP (eXtreme Programming)'.
}

::Mantenimiento – Tipos::
Tu aplicación móvil funciona perfectamente, pero iOS lanza nueva versión con cambios en APIs de notificaciones. Debes actualizar tu app para compatibilidad. ¿Qué tipo de mantenimiento es?
{
=Mantenimiento adaptativo, porque adaptas el software a cambios en el entorno externo (nueva versión de iOS, cambios en plataforma) sin añadir funcionalidades ni corregir bugs. #Correcto\: Mantenimiento Adaptativo\: (1) DEFINICIÓN\: Ajustar software a cambios EXTERNOS (SO, plataforma, hardware, regulaciones, APIs de terceros). (2) EJEMPLOS\: • Actualizar a iOS 17 (APIs cambiadas). • Soportar nuevo Android (cambios en permisos). • Actualizar a nueva versión de base de datos (PostgreSQL 15). • Cumplir nueva ley GDPR (cambio regulatorio). (3) CARACTERÍSTICAS\: • Software funcionaba correctamente ANTES del cambio externo. • NO añades features (eso sería evolutivo). • NO corriges bugs (eso sería correctivo). • ADAPTAS a nueva realidad externa. (4) INEVITABILIDAD\: Plataformas evolucionan; adaptación es continua. Los 4 tipos\: Correctivo (bugs), Perfectivo (mejoras), Evolutivo (features), Adaptativo (cambios externos). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
~%-33.3333%Mantenimiento correctivo, porque corriges incompatibilidades con iOS nuevo. #Incorrecto\: NO es bug del software, es cambio EXTERNO\: • CORRECTIVO\: Arregla DEFECTOS del software (crashes, lógica incorrecta, bugs). • Tu app NO tiene bug; funcionaba correctamente con iOS 16. • iOS 17 CAMBIÓ APIs (cambio externo, no defecto tuyo). • DIFERENCIA\: (1) Correctivo\: "Mi código tiene bug" (responsabilidad interna). (2) Adaptativo\: "Entorno cambió" (factor externo). • Aunque el EFECTO es similar (app no funciona en iOS 17), la CAUSA difiere\: (1) Bug\: Código malo desde el inicio. (2) Adaptación\: Código era bueno, entorno cambió. Clasificación correcta\: Adaptativo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
~%-33.3333%Mantenimiento perfectivo, porque perfeccionas la app para usar nuevas features de iOS. #Incorrecto\: SOLO si añades MEJORAS opcionales, NO si es adaptación obligatoria\: • PERFECTIVO\: Mejoras a software que YA funciona (optimización, refactoring, UX mejorada). • ADAPTATIVO\: Ajustes OBLIGATORIOS a cambios externos. • EN ESTE CASO\: iOS cambió APIs → Debes actualizar para que app SIGA FUNCIONANDO. NO es mejora opcional; es adaptación obligatoria. • SI ADEMÁS aprovechas para usar NUEVAS features de iOS 17 (widgets mejorados, etc.) → ESA PARTE sería perfectivo/evolutivo. • Pero el trabajo CORE (actualizar APIs para compatibilidad) es ADAPTATIVO. La clasificación depende de si es obligatorio (adaptativo) u opcional (perfectivo). Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
~%-33.3333%Mantenimiento evolutivo, porque evolucionas la app para soportar nueva versión de iOS. #Incorrecto\: Evolutivo es añadir FEATURES NUEVAS, NO adaptar a cambios externos\: • EVOLUTIVO\: Cliente pide "quiero integración con Apple Pay" (feature nueva). • ADAPTATIVO\: iOS cambió APIs y debes actualizar (cambio externo). • DIFERENCIA\: (1) Evolutivo\: AÑADES capacidades (nueva funcionalidad). (2) Adaptativo\: MANTIENES capacidades existentes en entorno cambiante. • Tu app NO gana features nuevas actualizando APIs; solo SIGUE FUNCIONANDO en iOS 17. • SI AÑADES soporte para iOS 17 features (Live Activities, etc.) → Eso sería evolutivo. Pero actualizar APIs para compatibilidad básica = Adaptativo. Consulta `EDES-U1.7.-FasesDesarrollo.md`, sección '1.8. Mantenimiento'.
}
